import traceback
from datetime import datetime, timedelta
import wmi
import requests
from bs4 import BeautifulSoup
import pythoncom
import ctypes
import winreg
import tkinter as tk
from tkinter import ttk, messagebox, Menu
import threading
import queue
import argparse
import platform
import psutil
import subprocess
import os
import sys
import uuid
import socket
import webbrowser
import json
from pathlib import Path
import re
import time
import hashlib  # Added missing import

# Constants for hiding console windows
CREATE_NO_WINDOW = 0x08000000

# Define themes
LIGHT_THEME = {
    'bg': '#ffffff',
    'fg': '#000000',
    'select_bg': '#e1e1e1',
    'select_fg': '#000000',
    'button_bg': '#f0f0f0',
    'button_fg': '#000000',
    'entry_bg': '#ffffff',
    'entry_fg': '#000000',
    'text_bg': '#ffffff',
    'text_fg': '#000000',
    'log_text_fg': '#00AA00',  # Green for log text
    'frame_bg': '#f0f0f0',
    'label_bg': '#ffffff',
    'label_fg': '#000000',
    'header_bg': '#e0e0e0',
    'header_fg': '#000000',
    'progress_bg': '#4CAF50',
    'admin_fg': 'green',
    'admin_error_fg': 'red',
    'menu_bg': '#f0f0f0',
    'menu_fg': '#000000',
    'task_bg': '#f5f5f5',
    'task_fg': '#000000',
    'task_border': '#cccccc',
    'tooltip_bg': '#ffffe0',
    'tooltip_fg': '#000000',
    'admin_indicator': '#00AA00',  # Green for admin
    'user_indicator': '#FF0000',  # Red for user
}

DARK_THEME = {
    'bg': '#2b2b2b',
    'fg': '#ffffff',
    'select_bg': '#404040',
    'select_fg': '#ffffff',
    'button_bg': '#404040',
    'button_fg': '#ffffff',
    'entry_bg': '#1a1a1a',
    'entry_fg': '#ffffff',
    'text_bg': '#1a1a1a',
    'text_fg': '#ffffff',
    'log_text_fg': '#00FF00',  # Bright green for log text
    'frame_bg': '#333333',
    'label_bg': '#2b2b2b',
    'label_fg': '#ffffff',
    'header_bg': '#1a1a1a',
    'header_fg': '#ffffff',
    'progress_bg': '#4CAF50',
    'admin_fg': '#00ff00',
    'admin_error_fg': '#ff0000',
    'menu_bg': '#404040',
    'menu_fg': '#ffffff',
    'task_bg': '#3c3c3c',
    'task_fg': '#ffffff',
    'task_border': '#555555',
    'tooltip_bg': '#444444',
    'tooltip_fg': '#ffffff',
    'admin_indicator': '#00FF00',  # Bright green for admin
    'user_indicator': '#FF0000',  # Red for user
}


# Enhanced startup logging
def startup_log(message):
    """Log startup messages to both console and file"""
    timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
    log_message = f"{timestamp} - {message}"
    print(log_message)  # Print to console
    try:
        with open("system_cleaner_startup.log", "a") as f:
            f.write(log_message + "\n")
    except:
        pass  # If we can't write to file, at least we printed to console


startup_log("Application starting")

# Clear previous startup logs
if os.path.exists("system_cleaner_startup.log"):
    try:
        os.remove("system_cleaner_startup.log")
    except:
        pass

# Skip relaunch with pythonw.exe for now to troubleshoot
skip_relaunch = True
if '--no-relaunch' not in sys.argv:
    # Only relaunch if we're running from a console and not already using pythonw.exe
    if not getattr(sys, 'frozen', False) and sys.stdout is not None and 'pythonw' not in sys.executable.lower():
        startup_log("Attempting to relaunch with pythonw.exe")
        try:
            pythonw_path = os.path.join(os.path.dirname(sys.executable), 'pythonw.exe')
            if os.path.exists(pythonw_path):
                startup_log(f"Found pythonw.exe at: {pythonw_path}")
                startup_log("Skipping automatic relaunch for debugging")
                skip_relaunch = True
            else:
                startup_log("pythonw.exe not found, continuing in console mode")
        except Exception as e:
            startup_log(f"Error during relaunch attempt: {str(e)}")
            startup_log("Continuing in console mode")

# Check if running on Windows
if os.name != 'nt':
    print("This application is designed to run on Windows only.")
    startup_log("Not running on Windows, exiting")
    sys.exit(1)


# Check dependencies first
def check_dependencies():
    startup_log("Checking dependencies")
    required_modules = [
        'tkinter', 'ctypes', 'subprocess', 'winreg', 'threading',
        'queue', 'time', 'argparse', 'json', 'hashlib', 're', 'pathlib',
        'wmi', 'webbrowser', 'pythoncom'
    ]

    missing_modules = []
    for module in required_modules:
        try:
            __import__(module)
            startup_log(f"Module OK: {module}")
        except ImportError as e:
            missing_modules.append(f"{module}: {str(e)}")
            startup_log(f"Module missing: {module} - {str(e)}")

    if missing_modules:
        print("Missing required modules:")
        startup_log("Missing modules detected:")
        for module in missing_modules:
            print(f"  - {module}")
            startup_log(f"  - {module}")
        print("\nPlease install them using: pip install <module_name>")
        startup_log("Dependency check failed, exiting")
        return False
    startup_log("All dependencies OK")
    return True


if not check_dependencies():
    print("Dependencies check failed. Exiting.")
    sys.exit(1)


class SecurityUtils:
    """Security utilities for safe operations"""

    @staticmethod
    def sanitize_path(path_str):
        """Sanitize file paths to prevent path traversal attacks"""
        try:
            # Convert to Path object and resolve
            path = Path(path_str).resolve()

            # Check if path is within allowed directories
            allowed_roots = [
                Path(os.environ.get('TEMP', 'C:\\Temp')),
                Path(os.environ.get('SystemRoot', 'C:\\Windows')),
                Path('C:\\PowerShell'),
                Path(os.environ.get('APPDATA', 'C:\\Users\\Default\\AppData\\Roaming'))
            ]

            for root in allowed_roots:
                try:
                    path.relative_to(root.resolve())
                    return str(path)
                except ValueError:
                    continue

            # If not in allowed directories, reject
            raise ValueError(f"Path not in allowed directories: {path}")

        except Exception as e:
            raise ValueError(f"Invalid path: {path_str}")

    @staticmethod
    def sanitize_command_args(args):
        """Sanitize command line arguments to prevent injection"""
        safe_args = []
        for arg in args:
            # Remove potentially dangerous characters
            safe_arg = re.sub(r'[;&|`$(){}[\]<>]', '', str(arg))
            # Limit length
            if len(safe_arg) > 1000:
                raise ValueError("Argument too long")
            safe_args.append(safe_arg)
        return safe_args

    @staticmethod
    def validate_registry_key(key_path):
        """Validate registry key paths"""
        allowed_patterns = [
            r'^SOFTWARE\\Microsoft\\Windows\\',
            r'^SOFTWARE\\Policies\\Microsoft\\Windows\\',
            r'^SYSTEM\\CurrentControlSet\\Control\\',
        ]

        for pattern in allowed_patterns:
            if re.match(pattern, key_path, re.IGNORECASE):
                return True

        raise ValueError(f"Registry key not allowed: {key_path}")


class Tooltip:
    """Create a tooltip for a given widget"""

    def __init__(self, widget, text='widget info', theme=DARK_THEME):
        self.widget = widget
        self.text = text
        self.theme = theme
        self.tooltip = None
        self.widget.bind("<Enter>", self.enter)
        self.widget.bind("<Leave>", self.leave)

    def enter(self, event=None):
        x, y, _, _ = self.widget.bbox("insert")
        x += self.widget.winfo_rootx() + 25
        y += self.widget.winfo_rooty() + 25

        # Create a toplevel window
        self.tooltip = tk.Toplevel(self.widget)
        self.tooltip.wm_overrideredirect(True)
        self.tooltip.wm_geometry(f"+{x}+{y}")

        label = tk.Label(
            self.tooltip,
            text=self.text,
            justify=tk.LEFT,
            background=self.theme['tooltip_bg'],
            foreground=self.theme['tooltip_fg'],
            relief=tk.SOLID,
            borderwidth=1,
            font=('Arial', 9)
        )
        label.pack()

    def leave(self, event=None):
        if self.tooltip:
            self.tooltip.destroy()


# PC Reporter class moved outside of SystemCleanerGUI
class PCReporter:
    def __init__(self):
        self.report_data = {
            "system_info": {},
            "hardware": {},
            "software": {},
            "network": {},
            "security": {},
            "users": {},
            "environment": {},
            "processes": [],
            "services": [],
            "devices": [],
            "performance": {},
            "updates": {},
            "vulnerabilities": {},
            "startup_items": {}  # Added for startup items
        }
        self.report_file = "PC_Report.html"

    def collect_system_info(self):
        """Collect basic system information"""
        boot_time = datetime.fromtimestamp(psutil.boot_time())
        uptime = datetime.now() - boot_time

        self.report_data["system_info"] = {
            "Computer Name": socket.gethostname(),
            "Operating System": platform.system(),
            "OS Version": platform.version(),
            "OS Release": platform.release(),
            "Architecture": platform.machine(),
            "Processor": platform.processor(),
            "System UUID": str(uuid.getnode()),
            "Python Version": platform.python_version(),
            "Boot Time": boot_time.strftime("%Y-%m-%d %H:%M:%S"),
            "System Uptime": f"{uptime.days} days, {uptime.seconds // 3600} hours, {(uptime.seconds % 3600) // 60} minutes",
            "Report Generated": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        }

    def collect_hardware_info(self):
        """Collect detailed hardware information"""
        # CPU Information
        cpu_freq = psutil.cpu_freq()
        cpu_info = {
            "Physical Cores": psutil.cpu_count(logical=False),
            "Total Cores": psutil.cpu_count(logical=True),
            "Max Frequency": f"{cpu_freq.max:.2f} MHz" if cpu_freq else "N/A",
            "Current Frequency": f"{cpu_freq.current:.2f} MHz" if cpu_freq else "N/A",
            "Min Frequency": f"{cpu_freq.min:.2f} MHz" if cpu_freq else "N/A",
            "CPU Usage": f"{psutil.cpu_percent(interval=1)}%",
            "CPU Usage Per Core": dict(enumerate(psutil.cpu_percent(interval=1, percpu=True)))
        }

        # Memory Information
        mem = psutil.virtual_memory()
        swap = psutil.swap_memory()
        memory_info = {
            "Total Memory": f"{mem.total / (1024 ** 3):.2f} GB",
            "Available Memory": f"{mem.available / (1024 ** 3):.2f} GB",
            "Used Memory": f"{mem.used / (1024 ** 3):.2f} GB",
            "Memory Percentage": f"{mem.percent}%",
            "Total Swap": f"{swap.total / (1024 ** 3):.2f} GB",
            "Used Swap": f"{swap.used / (1024 ** 3):.2f} GB",
            "Free Swap": f"{swap.free / (1024 ** 3):.2f} GB",
            "Swap Percentage": f"{swap.percent}%",
            "Memory Speed": self._get_memory_speed()
        }

        # Disk Information
        disk_info = {}
        disk_io = psutil.disk_io_counters()
        for partition in psutil.disk_partitions():
            try:
                partition_usage = psutil.disk_usage(partition.mountpoint)
                disk_info[f"Drive {partition.device}"] = {
                    "Mount Point": partition.mountpoint,
                    "File System": partition.fstype,
                    "Total Size": f"{partition_usage.total / (1024 ** 3):.2f} GB",
                    "Used": f"{partition_usage.used / (1024 ** 3):.2f} GB",
                    "Free": f"{partition_usage.free / (1024 ** 3):.2f} GB",
                    "Percentage": f"{partition_usage.percent}%",
                    "Drive Type": self._get_drive_type(partition.device)
                }
            except PermissionError:
                continue

        # Add disk I/O statistics
        if disk_io:
            disk_info["Disk I/O Statistics"] = {
                "Read Count": f"{disk_io.read_count:,}",
                "Write Count": f"{disk_io.write_count:,}",
                "Read Bytes": f"{disk_io.read_bytes / (1024 ** 3):.2f} GB",
                "Write Bytes": f"{disk_io.write_bytes / (1024 ** 3):.2f} GB",
                "Read Time": f"{disk_io.read_time} ms",
                "Write Time": f"{disk_io.write_time} ms"
            }

        # GPU Information
        gpu_info = self._get_gpu_info()

        # Motherboard Information
        motherboard_info = self._get_motherboard_info()

        # Battery Information (for laptops)
        battery_info = self._get_battery_info()

        # Temperature Information
        temp_info = self._get_temperature_info()

        self.report_data["hardware"] = {
            "CPU": cpu_info,
            "Memory": memory_info,
            "Storage": disk_info,
            "Graphics": gpu_info,
            "Motherboard": motherboard_info
        }

        if battery_info:
            self.report_data["hardware"]["Battery"] = battery_info

        if temp_info:
            self.report_data["hardware"]["Temperature"] = temp_info

    def _get_memory_speed(self):
        """Get memory speed information"""
        try:
            if platform.system() == "Windows":
                # Try multiple methods to get memory speed
                commands = [
                    ["wmic", "memorychip", "get", "speed", "/format:list"],
                    ["wmic", "MEMORYCHIP", "get", "Speed", "/value"]
                ]

                for cmd in commands:
                    try:
                        result = subprocess.run(cmd, capture_output=True, text=True, timeout=10,
                                                creationflags=CREATE_NO_WINDOW)
                        if result.returncode == 0:
                            speeds = re.findall(r"Speed=(\d+)", result.stdout)
                            if speeds:
                                return f"{speeds[0]} MHz"
                    except (subprocess.TimeoutExpired, subprocess.SubprocessError):
                        continue

                return "Information not available"
        except Exception:
            return "Information not available"

    def _get_drive_type(self, device):
        """Get drive type (HDD/SSD)"""
        try:
            if platform.system() == "Windows":
                # Clean device name for WMIC query
                clean_device = device.replace('\\', '').replace(':', '')
                commands = [
                    ["wmic", "diskdrive", "where", f"DeviceID='\\\\.\\{clean_device}'", "get", "MediaType",
                     "/format:list"],
                    ["wmic", "diskdrive", "get", "Model,MediaType,Size", "/format:list"],
                    ["powershell", "Get-PhysicalDisk | Select-Object MediaType,DeviceId | Format-List"]
                ]

                for cmd in commands:
                    try:
                        result = subprocess.run(cmd, capture_output=True, text=True, timeout=10,
                                                creationflags=CREATE_NO_WINDOW)
                        if result.returncode == 0:
                            if "SSD" in result.stdout.upper():
                                return "SSD"
                            elif "HDD" in result.stdout.upper() or "FIXED" in result.stdout.upper():
                                return "HDD"
                    except (subprocess.TimeoutExpired, subprocess.SubprocessError):
                        continue

                return "Unknown"
        except Exception:
            return "Unknown"

    def _get_gpu_info(self):
        """Get detailed GPU information"""
        gpu_info = {}
        try:
            if platform.system() == "Windows":
                commands = [
                    ["wmic", "path", "win32_VideoController", "get", "name,adapterram,driverversion,driverdate",
                     "/format:list"],
                    ["wmic", "path", "win32_VideoController", "get", "name", "/value"],
                    ["powershell",
                     "Get-WmiObject -Class Win32_VideoController | Select-Object Name,AdapterRAM,DriverVersion | Format-List"]
                ]

                for cmd in commands:
                    try:
                        result = subprocess.run(cmd, capture_output=True, text=True, timeout=10,
                                                creationflags=CREATE_NO_WINDOW)
                        if result.returncode == 0:
                            gpu_data = {}
                            for line in result.stdout.split('\n'):
                                if '=' in line:
                                    key, value = line.split('=', 1)
                                    gpu_data[key.strip()] = value.strip()
                                elif ':' in line and not line.strip().startswith('-'):
                                    parts = line.split(':', 1)
                                    if len(parts) == 2:
                                        gpu_data[parts[0].strip()] = parts[1].strip()

                            if gpu_data.get("Name"):
                                gpu_info["GPU Name"] = gpu_data["Name"]
                                if gpu_data.get("AdapterRAM"):
                                    try:
                                        ram_mb = int(gpu_data["AdapterRAM"]) // (1024 * 1024)
                                        gpu_info["GPU Memory"] = f"{ram_mb} MB"
                                    except:
                                        pass
                                if gpu_data.get("DriverVersion"):
                                    gpu_info["Driver Version"] = gpu_data["DriverVersion"]
                                if gpu_data.get("DriverDate"):
                                    gpu_info["Driver Date"] = gpu_data["DriverDate"]
                                break
                    except (subprocess.TimeoutExpired, subprocess.SubprocessError):
                        continue
            else:
                # For Linux/Mac
                commands = [
                    ["lspci", "-v"],
                    ["lspci"],
                    ["systeminfo"]  # On some systems
                ]

                for cmd in commands:
                    try:
                        result = subprocess.run(cmd, capture_output=True, text=True, timeout=10,
                                                creationflags=CREATE_NO_WINDOW)
                        if result.returncode == 0:
                            for line in result.stdout.split('\n'):
                                if 'VGA' in line or '3D' in line or 'Display' in line:
                                    gpu_info["GPU"] = line.split(':')[1].strip() if ':' in line else line.strip()
                                    break
                            if gpu_info:
                                break
                    except (subprocess.TimeoutExpired, subprocess.SubprocessError, FileNotFoundError):
                        continue
        except Exception:
            pass

        if not gpu_info:
            gpu_info["GPU"] = "Information not available"

        return gpu_info

    def _get_motherboard_info(self):
        """Get motherboard information with multiple fallback methods"""
        motherboard_info = {}

        try:
            if platform.system() == "Windows":
                # Method 1: Try to get system information using systeminfo command
                try:
                    result = subprocess.run(
                        ["systeminfo"],
                        capture_output=True, text=True, timeout=30,
                        creationflags=CREATE_NO_WINDOW
                    )
                    if result.returncode == 0:
                        lines = result.stdout.split('\n')
                        for line in lines:
                            if "System Model:" in line:
                                motherboard_info["System Model"] = line.split(":", 1)[1].strip()
                            elif "System Manufacturer:" in line:
                                motherboard_info["System Manufacturer"] = line.split(":", 1)[1].strip()
                            elif "System Type:" in line:
                                motherboard_info["System Type"] = line.split(":", 1)[1].strip()
                            elif "BIOS Version:" in line:
                                motherboard_info["BIOS Version"] = line.split(":", 1)[1].strip()
                            elif "BIOS Mode:" in line:
                                motherboard_info["BIOS Mode"] = line.split(":", 1)[1].strip()
                except Exception:
                    pass

                # Method 2: Try WMIC commands if systeminfo didn't work
                if not motherboard_info or len(motherboard_info) < 3:
                    commands = [
                        ("wmic baseboard get manufacturer /format:list", "Manufacturer"),
                        ("wmic baseboard get product /format:list", "Product"),
                        ("wmic baseboard get version /format:list", "Version"),
                        ("wmic bios get serialnumber /format:list", "Serial Number"),
                        ("wmic bios get version /format:list", "BIOS Version"),
                        ("wmic csproduct get name,vendor,identifyingnumber /format:list", "System Info")
                    ]

                    for cmd, key in commands:
                        try:
                            result = subprocess.run(cmd.split(), capture_output=True, text=True, timeout=10,
                                                    creationflags=CREATE_NO_WINDOW)
                            if result.returncode == 0:
                                if "System Info" in key:
                                    # Parse system info
                                    for line in result.stdout.split('\n'):
                                        if '=' in line:
                                            k, v = line.split('=', 1)
                                            if k.strip() == "Name":
                                                motherboard_info["System Model"] = v.strip()
                                            elif k.strip() == "Vendor":
                                                motherboard_info["System Manufacturer"] = v.strip()
                                            elif k.strip() == "IdentifyingNumber":
                                                motherboard_info["System Serial"] = v.strip()
                                else:
                                    match = re.search(rf"{key}=(.+)", result.stdout)
                                    if match:
                                        motherboard_info[key] = match.group(1).strip()
                        except (subprocess.TimeoutExpired, subprocess.SubprocessError):
                            continue

                # Method 3: Try PowerShell commands as fallback
                if not motherboard_info or len(motherboard_info) < 3:
                    try:
                        ps_commands = [
                            "Get-ComputerInfo | Select-Object BiosManufacturer,BiosSerialNumber,BiosVersion | Format-List",
                            "Get-WmiObject -Class Win32_BaseBoard | Select-Object Manufacturer,Product,Version,SerialNumber | Format-List",
                            "Get-WmiObject -Class Win32_ComputerSystemProduct | Select-Object Name,Vendor,UUID | Format-List"
                        ]

                        for ps_cmd in ps_commands:
                            try:
                                result = subprocess.run(
                                    ["powershell", "-Command", ps_cmd],
                                    capture_output=True, text=True, timeout=15,
                                    creationflags=CREATE_NO_WINDOW
                                )
                                if result.returncode == 0:
                                    for line in result.stdout.split('\n'):
                                        if ':' in line and not line.strip().startswith('-'):
                                            parts = line.split(':', 1)
                                            if len(parts) == 2:
                                                k = parts[0].strip()
                                                v = parts[1].strip()
                                                if "Manufacturer" in k and "Bios" in k:
                                                    motherboard_info["BIOS Manufacturer"] = v
                                                elif "SerialNumber" in k:
                                                    motherboard_info["BIOS Serial"] = v
                                                elif "Version" in k and "Bios" in k:
                                                    motherboard_info["BIOS Version"] = v
                                                elif "Manufacturer" in k and "Bios" not in k:
                                                    motherboard_info["System Manufacturer"] = v
                                                elif "Product" in k:
                                                    motherboard_info["System Model"] = v
                                                elif "Name" in k:
                                                    motherboard_info["System Model"] = v
                                                elif "Vendor" in k:
                                                    motherboard_info["System Manufacturer"] = v
                                                elif "UUID" in k:
                                                    motherboard_info["System UUID"] = v
                                        if len(motherboard_info) >= 3:
                                            break
                            except Exception:
                                continue
                    except Exception:
                        pass

        except Exception:
            pass

        # If we still don't have enough information, try to get at least basic info
        if not motherboard_info or len(motherboard_info) < 2:
            try:
                # Try to get system manufacturer from registry
                try:
                    result = subprocess.run(
                        ["reg", "query", "HKEY_LOCAL_MACHINE\\HARDWARE\\DESCRIPTION\\System\\BIOS", "/v",
                         "SystemManufacturer"],
                        capture_output=True, text=True, timeout=5,
                        creationflags=CREATE_NO_WINDOW
                    )
                    if result.returncode == 0:
                        match = re.search(r"SystemManufacturer\s+REG_SZ\s+(.+)", result.stdout)
                        if match:
                            motherboard_info["System Manufacturer"] = match.group(1).strip()
                except Exception:
                    pass

                # Try to get system product name from registry
                try:
                    result = subprocess.run(
                        ["reg", "query", "HKEY_LOCAL_MACHINE\\HARDWARE\\DESCRIPTION\\System\\BIOS", "/v",
                         "SystemProductName"],
                        capture_output=True, text=True, timeout=5,
                        creationflags=CREATE_NO_WINDOW
                    )
                    if result.returncode == 0:
                        match = re.search(r"SystemProductName\s+REG_SZ\s+(.+)", result.stdout)
                        if match:
                            motherboard_info["System Model"] = match.group(1).strip()
                except Exception:
                    pass
            except Exception:
                pass

        if not motherboard_info:
            motherboard_info["Error"] = "Information not available"

        return motherboard_info

    def _get_battery_info(self):
        """Get battery information"""
        try:
            battery = psutil.sensors_battery()
            if battery:
                return {
                    "Battery Percentage": f"{battery.percent}%",
                    "Power Plugged": "Yes" if battery.power_plugged else "No",
                    "Time Left": f"{battery.secsleft // 3600}h {(battery.secsleft % 3600) // 60}m" if battery.secsleft != psutil.POWER_TIME_UNLIMITED else "Unlimited"
                }
        except Exception:
            pass
        return None

    def _get_temperature_info(self):
        """Get temperature sensor information"""
        try:
            temps = psutil.sensors_temperatures()
            if temps:
                temp_info = {}
                for name, entries in temps.items():
                    temp_info[name] = {}
                    for entry in entries:
                        temp_info[name][entry.label or "Sensor"] = f"{entry.current:.1f}°C"
                        if entry.high:
                            temp_info[name][f"{entry.label or 'Sensor'} High"] = f"{entry.high:.1f}°C"
                        if entry.critical:
                            temp_info[name][f"{entry.label or 'Sensor'} Critical"] = f"{entry.critical:.1f}°C"
                return temp_info
        except Exception:
            pass
        return None

    def collect_software_info(self):
        """Collect installed software information"""
        software_info = {}

        try:
            if platform.system() == "Windows":
                # Try multiple methods to get installed software
                # Method 1: Try registry-based approach first (more reliable)
                try:
                    # Get software from HKLM
                    registry_paths = [
                        r"SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall",
                        r"SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
                    ]

                    for registry_path in registry_paths:
                        try:
                            with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, registry_path) as key:
                                for i in range(winreg.QueryInfoKey(key)[0]):
                                    try:
                                        subkey_name = winreg.EnumKey(key, i)
                                        with winreg.OpenKey(key, subkey_name) as subkey:
                                            try:
                                                name = winreg.QueryValueEx(subkey, "DisplayName")[0]
                                                version = winreg.QueryValueEx(subkey, "DisplayVersion")[
                                                    0] if "DisplayVersion" in [item[0] for item in winreg.QueryInfoKey(
                                                    subkey)] else "Unknown"
                                                publisher = winreg.QueryValueEx(subkey, "Publisher")[
                                                    0] if "Publisher" in [item[0] for item in
                                                                          winreg.QueryInfoKey(subkey)] else "Unknown"
                                                install_date = winreg.QueryValueEx(subkey, "InstallDate")[
                                                    0] if "InstallDate" in [item[0] for item in
                                                                            winreg.QueryInfoKey(subkey)] else ""

                                                if install_date and len(install_date) == 8:
                                                    install_date = f"{install_date[:4]}-{install_date[4:6]}-{install_date[6:8]}"

                                                software_info[name] = {
                                                    "Version": version,
                                                    "Vendor": publisher,
                                                    "Install Date": install_date
                                                }
                                            except (WindowsError, KeyError):
                                                continue
                                    except (WindowsError, KeyError):
                                        continue
                        except (WindowsError, KeyError):
                            continue

                    # Get software from HKCU
                    try:
                        with winreg.OpenKey(winreg.HKEY_CURRENT_USER,
                                            r"SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall") as key:
                            for i in range(winreg.QueryInfoKey(key)[0]):
                                try:
                                    subkey_name = winreg.EnumKey(key, i)
                                    with winreg.OpenKey(key, subkey_name) as subkey:
                                        try:
                                            name = winreg.QueryValueEx(subkey, "DisplayName")[0]
                                            version = winreg.QueryValueEx(subkey, "DisplayVersion")[
                                                0] if "DisplayVersion" in [item[0] for item in
                                                                           winreg.QueryInfoKey(subkey)] else "Unknown"
                                            publisher = winreg.QueryValueEx(subkey, "Publisher")[0] if "Publisher" in [
                                                item[0] for item in winreg.QueryInfoKey(subkey)] else "Unknown"
                                            install_date = winreg.QueryValueEx(subkey, "InstallDate")[
                                                0] if "InstallDate" in [item[0] for item in
                                                                        winreg.QueryInfoKey(subkey)] else ""

                                            if install_date and len(install_date) == 8:
                                                install_date = f"{install_date[:4]}-{install_date[4:6]}-{install_date[6:8]}"

                                            software_info[name] = {
                                                "Version": version,
                                                "Vendor": publisher,
                                                "Install Date": install_date
                                            }
                                        except (WindowsError, KeyError):
                                            continue
                                except (WindowsError, KeyError):
                                    continue
                    except (WindowsError, KeyError):
                        pass

                    if software_info:
                        self.report_data["software"] = software_info
                        return
                except Exception as e:
                    pass

                # Method 2: Try PowerShell as fallback
                try:
                    ps_script = '''
                    $software = @()
                    $paths = @(
                        "HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*",
                        "HKLM:\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*",
                        "HKCU:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*"
                    )

                    foreach ($path in $paths) {
                        try {
                            Get-ItemProperty $path -ErrorAction SilentlyContinue | Where-Object { $_.DisplayName } | ForEach-Object {
                                $software += [PSCustomObject]@{
                                    Name = $_.DisplayName
                                    Version = $_.DisplayVersion
                                    Publisher = $_.Publisher
                                    InstallDate = $_.InstallDate
                                }
                            }
                        } catch {
                            # Ignore errors
                        }
                    }

                    $software | ConvertTo-Json
                    '''

                    result = subprocess.run(
                        ["powershell", "-Command", ps_script],
                        capture_output=True, text=True, timeout=30,
                        creationflags=CREATE_NO_WINDOW
                    )

                    if result.returncode == 0 and result.stdout.strip():
                        try:
                            software_data = json.loads(result.stdout)
                            for item in software_data:
                                name = item.get("Name", "")
                                if name:
                                    version = item.get("Version", "Unknown")
                                    publisher = item.get("Publisher", "Unknown")
                                    install_date = item.get("InstallDate", "")

                                    if install_date and len(install_date) == 8:
                                        install_date = f"{install_date[:4]}-{install_date[4:6]}-{install_date[6:8]}"

                                    software_info[name] = {
                                        "Version": version,
                                        "Vendor": publisher,
                                        "Install Date": install_date
                                    }
                        except json.JSONDecodeError:
                            pass

                        if software_info:
                            self.report_data["software"] = software_info
                            return
                except Exception:
                    pass

                # Method 3: Try WMIC as last resort
                try:
                    result = subprocess.run(
                        ["wmic", "product", "get", "name,version,vendor,installdate", "/format:csv"],
                        capture_output=True, text=True, timeout=30,
                        creationflags=CREATE_NO_WINDOW
                    )

                    if result.returncode == 0:
                        lines = result.stdout.split('\n')
                        for line in lines[1:]:  # Skip header
                            if line.strip():
                                parts = line.split(',')
                                if len(parts) >= 4 and parts[1].strip():
                                    install_date = parts[4].strip() if len(parts) > 4 else ""
                                    if install_date and len(install_date) == 8:
                                        install_date = f"{install_date[:4]}-{install_date[4:6]}-{install_date[6:8]}"

                                    software_info[parts[1].strip()] = {
                                        "Version": parts[2].strip(),
                                        "Vendor": parts[3].strip(),
                                        "Install Date": install_date
                                    }

                        if software_info:
                            self.report_data["software"] = software_info
                            return
                except Exception:
                    pass

                # If all methods fail, add error message
                software_info["Error"] = "Could not retrieve software information using multiple methods"
            else:
                # For Linux/Mac, try to get installed packages
                if platform.system() == "Linux":
                    # Try dpkg (Debian/Ubuntu)
                    try:
                        result = subprocess.run(
                            ["dpkg-query", "-W", "-f=${Package}\t${Version}\t${Maintainer}\n"],
                            capture_output=True, text=True,
                            creationflags=CREATE_NO_WINDOW
                        )
                        if result.returncode == 0:
                            for line in result.stdout.split('\n'):
                                if line.strip():
                                    parts = line.split('\t')
                                    if len(parts) >= 2:
                                        software_info[parts[0]] = {
                                            "Version": parts[1],
                                            "Vendor": parts[2] if len(parts) > 2 else "Unknown"
                                        }
                    except FileNotFoundError:
                        # Try rpm (RedHat/CentOS)
                        try:
                            result = subprocess.run(
                                ["rpm", "-qa", "--queryformat", "%{NAME}\t%{VERSION}\t%{VENDOR}\n"],
                                capture_output=True, text=True,
                                creationflags=CREATE_NO_WINDOW
                            )
                            if result.returncode == 0:
                                for line in result.stdout.split('\n'):
                                    if line.strip():
                                        parts = line.split('\t')
                                        if len(parts) >= 2:
                                            software_info[parts[0]] = {
                                                "Version": parts[1],
                                                "Vendor": parts[2] if len(parts) > 2 else "Unknown"
                                            }
                        except FileNotFoundError:
                            pass
        except Exception as e:
            software_info["Error"] = f"Could not retrieve software information: {str(e)}"

        self.report_data["software"] = software_info

    def collect_startup_info(self):
        """Collect startup items information"""
        startup_info = {
            "Registry": {},
            "Startup Folders": {}
        }

        try:
            if platform.system() == "Windows":
                # Collect registry startup items
                registry_paths = [
                    (winreg.HKEY_CURRENT_USER, r"SOFTWARE\Microsoft\Windows\CurrentVersion\Run"),
                    (winreg.HKEY_CURRENT_USER, r"SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce"),
                    (winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Windows\CurrentVersion\Run"),
                    (winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce"),
                    (winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Run"),
                    (winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\RunOnce")
                ]

                for root, path in registry_paths:
                    try:
                        with winreg.OpenKey(root, path) as key:
                            key_name = f"HK{'CU' if root == winreg.HKEY_CURRENT_USER else 'LM'}\\{path}"
                            startup_info["Registry"][key_name] = {}

                            for i in range(winreg.QueryInfoKey(key)[0]):
                                try:
                                    name, value, _ = winreg.EnumValue(key, i)
                                    startup_info["Registry"][key_name][name] = {
                                        "Value": value,
                                        "Status": "Enabled"
                                    }
                                except (WindowsError, KeyError):
                                    continue
                    except (WindowsError, KeyError):
                        continue

                # Collect startup folder items
                startup_folders = [
                    os.path.join(os.environ.get('APPDATA', ''), "Microsoft", "Windows", "Start Menu", "Programs", "Startup"),
                    os.path.join(os.environ.get('ProgramData', ''), "Microsoft", "Windows", "Start Menu", "Programs", "Startup")
                ]

                for folder_path in startup_folders:
                    try:
                        if os.path.exists(folder_path):
                            folder_name = os.path.basename(folder_path)
                            startup_info["Startup Folders"][folder_name] = {}

                            for item in os.listdir(folder_path):
                                item_path = os.path.join(folder_path, item)
                                if os.path.isfile(item_path):
                                    startup_info["Startup Folders"][folder_name][item] = {
                                        "Path": item_path,
                                        "Status": "Enabled"
                                    }
                    except Exception:
                        continue

        except Exception as e:
            startup_info["Error"] = f"Could not retrieve startup information: {str(e)}"

        self.report_data["startup_items"] = startup_info

    def _collect_windows_updates(self):
        """Collect Windows update information"""
        try:
            commands = [
                ["wmic", "qfe", "get", "hotfixid,installedon,installedby", "/format:csv"],
                ["wmic", "qfe", "list", "brief"],
                ["powershell", "Get-HotFix | Select-Object HotFixID,InstalledOn | Format-Table"]
            ]

            for cmd in commands:
                try:
                    result = subprocess.run(cmd, capture_output=True, text=True, timeout=30,
                                            creationflags=CREATE_NO_WINDOW)
                    if result.returncode == 0:
                        updates = []
                        lines = result.stdout.split('\n')
                        for line in lines[1:]:  # Skip header
                            if line.strip():
                                parts = line.split(',')
                                if len(parts) >= 4:
                                    updates.append({
                                        "Hotfix ID": parts[1].strip(),
                                        "Installed On": parts[2].strip(),
                                        "Installed By": parts[3].strip()
                                    })
                        if updates:
                            self.report_data["updates"] = updates[:20]  # Last 20 updates
                            break
                except (subprocess.TimeoutExpired, subprocess.SubprocessError):
                    continue
        except Exception:
            self.report_data["updates"] = {"Error": "Could not retrieve update information"}

    def collect_vulnerability_info(self):
        """Collect vulnerability and security update information"""
        vulnerability_info = {}

        try:
            if platform.system() == "Windows":
                # Get Windows Update status
                try:
                    result = subprocess.run(
                        ["powershell", "(Get-WmiObject -Class Win32_QuickFixEngineering).Count"],
                        capture_output=True, text=True, timeout=15,
                        creationflags=CREATE_NO_WINDOW
                    )
                    if result.returncode == 0:
                        try:
                            update_count = int(result.stdout.strip())
                            vulnerability_info["Installed Updates Count"] = str(update_count)
                        except ValueError:
                            pass
                except Exception:
                    pass

                # Check for pending updates
                try:
                    result = subprocess.run(
                        ["powershell",
                         "(New-Object -ComObject Microsoft.Update.Session).CreateUpdateSearcher().Search(\"IsInstalled=0\").Updates.Count"],
                        capture_output=True, text=True, timeout=30,
                        creationflags=CREATE_NO_WINDOW
                    )
                    if result.returncode == 0:
                        try:
                            pending_count = int(result.stdout.strip())
                            if pending_count > 0:
                                vulnerability_info["Pending Updates"] = f"{pending_count} updates available"
                                vulnerability_info["Status"] = "Updates Available"
                            else:
                                vulnerability_info["Pending Updates"] = "No pending updates"
                                vulnerability_info["Status"] = "Up to Date"
                        except ValueError:
                            pass
                except Exception:
                    pass

                # Get last scan date
                try:
                    result = subprocess.run(
                        ["powershell",
                         "(Get-WmiObject -Class Win32_QuickFixEngineering | Sort-Object -Property InstalledOn -Descending | Select-Object -First 1).InstalledOn"],
                        capture_output=True, text=True, timeout=15,
                        creationflags=CREATE_NO_WINDOW
                    )
                    if result.returncode == 0 and result.stdout.strip():
                        vulnerability_info["Last Update Scan"] = result.stdout.strip()
                except Exception:
                    pass

                # Check for Windows Defender status
                try:
                    result = subprocess.run(
                        ["powershell",
                         "Get-MpComputerStatus | Select-Object AntispywareEnabled, AntivirusEnabled, NISEnabled, RealTimeProtectionEnabled | Format-List"],
                        capture_output=True, text=True, timeout=15,
                        creationflags=CREATE_NO_WINDOW
                    )
                    if result.returncode == 0:
                        defender_status = {}
                        for line in result.stdout.split('\n'):
                            if ':' in line and not line.strip().startswith('-'):
                                parts = line.split(':', 1)
                                if len(parts) == 2:
                                    key = parts[0].strip()
                                    value = parts[1].strip()
                                    if value:
                                        defender_status[key] = value
                        if defender_status:
                            vulnerability_info["Windows Defender"] = defender_status
                except Exception:
                    pass

                # Check for Windows version and end of life status
                try:
                    result = subprocess.run(
                        ["powershell",
                         "Get-ComputerInfo | Select-Object WindowsProductName, WindowsVersion, OsVersion | Format-List"],
                        capture_output=True, text=True, timeout=15,
                        creationflags=CREATE_NO_WINDOW
                    )
                    if result.returncode == 0:
                        version_info = {}
                        for line in result.stdout.split('\n'):
                            if ':' in line and not line.strip().startswith('-'):
                                parts = line.split(':', 1)
                                if len(parts) == 2:
                                    key = parts[0].strip()
                                    value = parts[1].strip()
                                    if value:
                                        version_info[key] = value

                        if version_info.get("WindowsProductName"):
                            product_name = version_info["WindowsProductName"]
                            # Check if it's a supported version
                            if "Windows 10" in product_name or "Windows 11" in product_name:
                                vulnerability_info["Windows Support Status"] = "Supported"
                            elif "Windows 7" in product_name or "Windows 8" in product_name or "Windows Server 2012" in product_name:
                                vulnerability_info["Windows Support Status"] = "End of Life - Security Risk"
                            else:
                                vulnerability_info["Windows Support Status"] = "Unknown"
                except Exception:
                    pass

                # Check for firewall status
                try:
                    result = subprocess.run(
                        ["netsh", "advfirewall", "show", "allprofiles"],
                        capture_output=True, text=True, timeout=10,
                        creationflags=CREATE_NO_WINDOW
                    )
                    if result.returncode == 0:
                        firewall_profiles = {}
                        for line in result.stdout.split('\n'):
                            if 'State' in line:
                                parts = line.strip().split()
                                if len(parts) >= 3:
                                    profile = parts[0]
                                    state = parts[2]
                                    firewall_profiles[profile] = state
                        if firewall_profiles:
                            vulnerability_info["Windows Firewall"] = firewall_profiles
                except Exception:
                    pass
        except Exception:
            pass

        self.report_data["vulnerabilities"] = vulnerability_info

    def collect_network_info(self):
        """Collect network information"""
        network_info = {}

        # Get network interfaces
        interfaces = {}
        for interface, addrs in psutil.net_if_addrs().items():
            interface_info = {"IP Addresses": []}
            for addr in addrs:
                if addr.family == socket.AF_INET:
                    interface_info["IP Addresses"].append({
                        "Address": addr.address,
                        "Netmask": addr.netmask,
                        "Broadcast": addr.broadcast
                    })
                elif addr.family == socket.AF_INET6:
                    interface_info["IPv6"] = addr.address
                elif addr.family == psutil.AF_LINK:
                    interface_info["MAC Address"] = addr.address
            interfaces[interface] = interface_info

        # Get network statistics
        net_io = psutil.net_io_counters()
        network_stats = {
            "Bytes Sent": f"{net_io.bytes_sent / (1024 ** 3):.2f} GB",
            "Bytes Received": f"{net_io.bytes_recv / (1024 ** 3):.2f} GB",
            "Packets Sent": f"{net_io.packets_sent:,}",
            "Packets Received": f"{net_io.packets_recv:,}",
            "Errin": f"{net_io.errin}",
            "Errout": f"{net_io.errout}",
            "Dropin": f"{net_io.dropin}",
            "Dropout": f"{net_io.dropout}"
        }

        # Get active connections
        connections = []
        try:
            for conn in psutil.net_connections():
                if conn.status == 'ESTABLISHED':
                    connections.append({
                        "Local Address": f"{conn.laddr.ip}:{conn.laddr.port}" if conn.laddr else "N/A",
                        "Remote Address": f"{conn.raddr.ip}:{conn.raddr.port}" if conn.raddr else "N/A",
                        "Status": conn.status,
                        "PID": conn.pid
                    })
        except Exception:
            pass

        # Get DNS servers
        dns_servers = self._get_dns_servers()

        network_info = {
            "Interfaces": interfaces,
            "Statistics": network_stats,
            "Active Connections": connections[:20],  # Top 20 connections
            "DNS Servers": dns_servers
        }

        self.report_data["network"] = network_info

    def _get_dns_servers(self):
        """Get DNS server information"""
        try:
            if platform.system() == "Windows":
                commands = [
                    ["nslookup", "localhost"],
                    ["ipconfig", "/all"],
                    ["powershell", "Get-DnsClientServerAddress | Select-Object ServerAddresses | Format-List"]
                ]

                for cmd in commands:
                    try:
                        result = subprocess.run(cmd, capture_output=True, text=True, timeout=10,
                                                creationflags=CREATE_NO_WINDOW)
                        if result.returncode == 0:
                            if "nslookup" in cmd[0]:
                                servers = re.findall(r"Server:\s*(.+)", result.stdout)
                                if servers:
                                    return servers
                            else:
                                # Parse DNS servers from ipconfig
                                dns_servers = re.findall(r"DNS Servers[\.:\s]+(.+)", result.stdout)
                                if dns_servers:
                                    return [dns.strip() for dns in dns_servers if dns.strip()]
                    except (subprocess.TimeoutExpired, subprocess.SubprocessError):
                        continue
            else:
                with open("/etc/resolv.conf", "r") as f:
                    content = f.read()
                    servers = re.findall(r"nameserver\s+(.+)", content)
                    return servers if servers else ["Could not determine"]
        except Exception:
            pass
        return ["Could not determine"]

    def collect_security_info(self):
        """Collect security-related information"""
        security_info = {}

        try:
            if platform.system() == "Windows":
                # Get Windows Defender status
                try:
                    commands = [
                        ["powershell",
                         "Get-MpComputerStatus | Select-Object AMServiceEnabled, AntispywareEnabled, AntivirusEnabled, NISEnabled, RealTimeProtectionEnabled, QuickScanAge, FullScanAge"],
                        ["powershell", "Get-MpPreference | Select-Object DisableRealtimeMonitoring"],
                        ["wmic", "/namespace:\\\\root\\securitycenter2", "path", "antivirusproduct", "get",
                         "displayName", "/format:list"]
                    ]

                    for cmd in commands:
                        try:
                            result = subprocess.run(cmd, capture_output=True, text=True, timeout=10,
                                                    creationflags=CREATE_NO_WINDOW)
                            if result.returncode == 0:
                                defender_status = {}
                                for line in result.stdout.split('\n'):
                                    if ':' in line and not line.startswith('-'):
                                        parts = line.split(':', 1)
                                        if len(parts) == 2:
                                            key = parts[0].strip()
                                            value = parts[1].strip()
                                            if value:
                                                defender_status[key] = value
                                if defender_status:
                                    security_info["Windows Defender"] = defender_status
                                    break
                        except (subprocess.TimeoutExpired, subprocess.SubprocessError):
                            continue
                except Exception:
                    security_info["Windows Defender"] = "Status not available"

                # Get Windows Firewall status
                try:
                    result = subprocess.run(
                        ["netsh", "advfirewall", "show", "allprofiles"],
                        capture_output=True, text=True, timeout=10,
                        creationflags=CREATE_NO_WINDOW
                    )
                    if result.returncode == 0:
                        firewall_status = {}
                        for line in result.stdout.split('\n'):
                            if 'State' in line:
                                parts = line.strip().split()
                                if len(parts) >= 3:
                                    profile = parts[0]
                                    state = parts[2]
                                    firewall_status[profile] = state
                        security_info["Windows Firewall"] = firewall_status
                except Exception:
                    security_info["Windows Firewall"] = "Status not available"

                # Get UAC status
                try:
                    result = subprocess.run(
                        ["reg", "query", "HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System", "/v",
                         "EnableLUA"],
                        capture_output=True, text=True, timeout=10,
                        creationflags=CREATE_NO_WINDOW
                    )
                    if result.returncode == 0:
                        uac_enabled = "0x1" in result.stdout
                        security_info["User Account Control"] = "Enabled" if uac_enabled else "Disabled"
                except Exception:
                    security_info["User Account Control"] = "Status not available"
            else:
                security_info["Note"] = "Security software detection not implemented for this OS"
        except Exception as e:
            security_info["Error"] = f"Could not retrieve security information: {str(e)}"

        self.report_data["security"] = security_info

    def collect_user_info(self):
        """Collect user account information"""
        user_info = {}

        try:
            if platform.system() == "Windows":
                # Get user accounts
                try:
                    result = subprocess.run(
                        ["net", "user"],
                        capture_output=True, text=True, timeout=10,
                        creationflags=CREATE_NO_WINDOW
                    )
                    if result.returncode == 0:
                        users = []
                        lines = result.stdout.split('\n')
                        for line in lines:
                            if line.strip() and not line.startswith('-') and not line.startswith('The command'):
                                users.append(line.strip())
                        user_info["User Accounts"] = users
                except Exception:
                    pass

                # Get current user details
                current_user = os.environ.get("USERNAME", "Unknown")
                user_info["Current User"] = current_user

                # Get user groups
                try:
                    result = subprocess.run(
                        ["net", "user", current_user],
                        capture_output=True, text=True, timeout=10,
                        creationflags=CREATE_NO_WINDOW
                    )
                    if result.returncode == 0:
                        groups = []
                        for line in result.stdout.split('\n'):
                            if "Local Group Memberships" in line:
                                groups_line = line.split('*', 1)[1].strip()
                                groups = [g.strip() for g in groups_line.split() if g.strip()]
                                break
                        user_info["User Groups"] = groups
                except Exception:
                    pass
            else:
                # For Linux/Mac, get users from /etc/passwd
                if os.path.exists("/etc/passwd"):
                    users = []
                    with open("/etc/passwd", "r") as f:
                        for line in f:
                            if not line.startswith("#"):
                                parts = line.split(":")
                                if len(parts) >= 1:
                                    users.append(parts[0])
                    user_info["User Accounts"] = users

                user_info["Current User"] = os.environ.get("USER", "Unknown")
        except Exception as e:
            user_info["Error"] = f"Could not retrieve user information: {str(e)}"

        self.report_data["users"] = user_info

    def collect_environment_info(self):
        """Collect environment variables"""
        self.report_data["environment"] = dict(os.environ)

    def collect_process_info(self):
        """Collect running processes"""
        processes = []

        try:
            for proc in psutil.process_iter(
                    ['pid', 'name', 'username', 'cpu_percent', 'memory_percent', 'memory_info', 'create_time']):
                try:
                    create_time = datetime.fromtimestamp(proc.info['create_time']).strftime(
                        "%Y-%m-%d %H:%M:%S")
                    memory_mb = proc.info['memory_info'].rss / (1024 * 1024) if proc.info['memory_info'] else 0

                    processes.append({
                        "PID": proc.info['pid'],
                        "Name": proc.info['name'],
                        "User": proc.info['username'],
                        "CPU %": f"{proc.info['cpu_percent']:.1f}%",
                        "Memory %": f"{proc.info['memory_percent']:.1f}%",
                        "Memory (MB)": f"{memory_mb:.1f}",
                        "Started": create_time
                    })
                except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
                    pass
        except Exception:
            pass

        # Sort by memory usage
        processes.sort(key=lambda x: float(x["Memory %"].rstrip('%')), reverse=True)
        self.report_data["processes"] = processes[:30]  # Top 30 processes

    def collect_service_info(self):
        """Collect system services"""
        services = []

        try:
            if platform.system() == "Windows":
                # Get Windows services
                commands = [
                    ["sc", "query", "type=", "service", "state=", "all"],
                    ["powershell", "Get-Service | Select-Object Name,Status,StartType | Format-Table"]
                ]

                for cmd in commands:
                    try:
                        result = subprocess.run(cmd, capture_output=True, text=True, timeout=30,
                                                creationflags=CREATE_NO_WINDOW)
                        if result.returncode == 0:
                            lines = result.stdout.split('\n')
                            current_service = {}
                            for line in lines:
                                if line.strip():
                                    if "SERVICE_NAME:" in line:
                                        if current_service:
                                            services.append(current_service)
                                        current_service = {"Name": line.split(":", 1)[1].strip()}
                                    elif "DISPLAY_NAME:" in line:
                                        current_service["Display Name"] = line.split(":", 1)[1].strip()
                                    elif "TYPE" in line:
                                        current_service["Type"] = line.split(":", 1)[1].strip()
                                    elif "STATE" in line:
                                        current_service["State"] = line.split(":", 1)[1].strip()
                                    elif "START_TYPE" in line:
                                        current_service["Start Type"] = line.split(":", 1)[1].strip()
                            if current_service:
                                services.append(current_service)
                            if services:
                                break
                    except (subprocess.TimeoutExpired, subprocess.SubprocessError):
                        continue
            else:
                # For Linux/Mac, try to get systemd services
                if platform.system() == "Linux":
                    try:
                        result = subprocess.run(
                            ["systemctl", "list-units", "--type=service", "--no-pager"],
                            capture_output=True, text=True, timeout=30,
                            creationflags=CREATE_NO_WINDOW
                        )
                        if result.returncode == 0:
                            lines = result.stdout.split('\n')
                            for line in lines[1:]:  # Skip header
                                if line.strip() and not line.startswith('UNIT'):
                                    parts = line.split()
                                    if len(parts) >= 4:
                                        services.append({
                                            "Name": parts[0],
                                            "Load": parts[1],
                                            "Active": parts[2],
                                            "State": parts[3],
                                            "Description": " ".join(parts[4:]) if len(parts) > 4 else ""
                                        })
                    except (subprocess.TimeoutExpired, subprocess.SubprocessError, FileNotFoundError):
                        pass
        except Exception as e:
            services.append({"Error": f"Could not retrieve service information: {str(e)}"})

        self.report_data["services"] = services[:50]  # Top 50 services

    def collect_device_info(self):
        """Collect hardware devices with improved Windows support"""
        devices = []

        try:
            if platform.system() == "Windows":
                # Try multiple methods to get device information
                commands = [
                    ["wmic", "path", "win32_PnPEntity", "get", "name,deviceid,description,manufacturer",
                     "/format:csv"],
                    ["wmic", "path", "win32_PnPEntity", "get", "name,description", "/format:list"],
                    ["powershell", "Get-PnpDevice | Select-Object FriendlyName,DeviceID,Status | Format-Table"],
                    ["powershell",
                     "Get-WmiObject -Class Win32_PnPEntity | Select-Object Name,DeviceID,Description,Manufacturer | Format-Table"],
                    ["devcon", "list"]  # If devcon is available
                ]

                for cmd in commands:
                    try:
                        result = subprocess.run(cmd, capture_output=True, text=True, timeout=30,
                                                creationflags=CREATE_NO_WINDOW)
                        if result.returncode == 0:
                            lines = result.stdout.split('\n')
                            for line in lines[1:]:  # Skip header
                                if line.strip():
                                    parts = line.split(',')
                                    if len(parts) >= 5 and parts[1].strip():
                                        devices.append({
                                            "Name": parts[1].strip(),
                                            "Description": parts[2].strip(),
                                            "Manufacturer": parts[3].strip(),
                                            "Device ID": parts[4].strip()
                                        })
                                    elif len(parts) >= 3 and parts[0].strip():
                                        # Alternative format
                                        devices.append({
                                            "Name": parts[0].strip(),
                                            "Description": parts[1].strip() if len(parts) > 1 else "",
                                            "Manufacturer": parts[2].strip() if len(parts) > 2 else "",
                                            "Device ID": "N/A"
                                        })
                                if devices:
                                    break
                    except (subprocess.TimeoutExpired, subprocess.SubprocessError, FileNotFoundError):
                        continue

                # If still no devices, try to get basic device categories
                if not devices:
                    try:
                        device_classes = [
                            "win32_Processor",
                            "win32_VideoController",
                            "win32_SoundDevice",
                            "win32_NetworkAdapter",
                            "win32_DiskDrive",
                            "win32_BaseBoard"
                        ]

                        for device_class in device_classes:
                            try:
                                result = subprocess.run(
                                    ["wmic", "path", device_class, "get", "name,manufacturer", "/format:list"],
                                    capture_output=True, text=True, timeout=10,
                                    creationflags=CREATE_NO_WINDOW
                                )
                                if result.returncode == 0:
                                    device_data = {}
                                    for line in result.stdout.split('\n'):
                                        if '=' in line:
                                            key, value = line.split('=', 1)
                                            device_data[key.strip()] = value.strip()

                                    if device_data.get("Name"):
                                        devices.append({
                                            "Name": device_data["Name"],
                                            "Description": device_class.split('_')[1],
                                            "Manufacturer": device_data.get("Manufacturer", "Unknown"),
                                            "Device ID": "N/A"
                                        })
                            except Exception:
                                continue
                    except Exception:
                        pass

            else:
                # For Linux/Mac, try to get devices from lspci
                commands = [
                    ["lspci", "-v"],
                    ["lspci"],
                    ["lsusb"]  # USB devices
                ]

                for cmd in commands:
                    try:
                        result = subprocess.run(cmd, capture_output=True, text=True, timeout=10,
                                                creationflags=CREATE_NO_WINDOW)
                        if result.returncode == 0:
                            current_device = {}
                            for line in result.stdout.split('\n'):
                                if line.strip() and not line.startswith('\t'):
                                    if current_device:
                                        devices.append(current_device)
                                    parts = line.split(':', 1)
                                    if len(parts) >= 2:
                                        current_device = {
                                            "ID": parts[0].strip(),
                                            "Name": parts[1].strip(),
                                            "Description": cmd[0].upper()
                                        }
                                elif line.strip().startswith('\t') and current_device:
                                    if "Subsystem:" in line:
                                        current_device["Subsystem"] = line.split(':', 1)[1].strip()
                            if current_device:
                                devices.append(current_device)
                            if devices:
                                break
                    except (subprocess.TimeoutExpired, subprocess.SubprocessError, FileNotFoundError):
                        continue
        except Exception as e:
            devices.append({"Error": f"Could not retrieve device information: {str(e)}"})

        self.report_data["devices"] = devices[:100]  # Top 100 devices

    def collect_performance_metrics(self):
        """Collect performance metrics"""
        perf_data = {}

        # CPU load average (Linux/Mac) or CPU usage history
        if hasattr(psutil, 'getloadavg'):
            perf_data["Load Average"] = psutil.getloadavg()

        # Memory pressure
        mem = psutil.virtual_memory()
        perf_data["Memory Pressure"] = {
            "Available": f"{mem.available / (1024 ** 3):.2f} GB",
            "Percent Used": f"{mem.percent}%"
        }

        # Disk usage summary
        disk_usage = {}
        for partition in psutil.disk_partitions():
            try:
                usage = psutil.disk_usage(partition.mountpoint)
                disk_usage[partition.device] = {
                    "Used": f"{usage.percent}%",
                    "Free": f"{usage.free / (1024 ** 3):.2f} GB"
                }
            except:
                continue
        perf_data["Disk Usage"] = disk_usage

        self.report_data["performance"] = perf_data

    def generate_html_report(self):
        """Generate HTML report from collected data"""
        html_content = """<!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>PC System Report</title>
            <style>
                * {
                    margin: 0;
                    padding: 0;
                    box-sizing: border-box;
                }

                body {
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
                    line-height: 1.6;
                    color: #2c3e50;
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    min-height: 100vh;
                    padding: 20px;
                }

                .container {
                    max-width: 1400px;
                    margin: 0 auto;
                    background: white;
                    border-radius: 20px;
                    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
                    overflow: hidden;
                }

                header {
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    padding: 40px;
                    text-align: center;
                }

                h1 {
                    font-size: 2.5rem;
                    font-weight: 700;
                    margin-bottom: 10px;
                    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
                }

                .subtitle {
                    font-size: 1.1rem;
                    opacity: 0.9;
                }

                .summary-cards {
                    display: grid;
                    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
                    gap: 20px;
                    padding: 30px;
                    background: #f8f9fa;
                }

                .card {
                    background: white;
                    border-radius: 15px;
                    padding: 25px;
                    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
                    transition: transform 0.3s ease, box-shadow 0.3s ease;
                }

                .card:hover {
                    transform: translateY(-5px);
                    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
                }

                .card h3 {
                    color: #667eea;
                    font-size: 1.1rem;
                    margin-bottom: 15px;
                    display: flex;
                    align-items: center;
                }

                .card h3::before {
                    content: '';
                    width: 4px;
                    height: 20px;
                    background: #667eea;
                    margin-right: 10px;
                    border-radius: 2px;
                }

                .card-value {
                    font-size: 1.8rem;
                    font-weight: 700;
                    color: #2c3e50;
                    margin-bottom: 5px;
                }

                .card-label {
                    color: #7f8c8d;
                    font-size: 0.9rem;
                }

                .content {
                    padding: 30px;
                }

                .section {
                    margin-bottom: 40px;
                }

                h2 {
                    color: #2c3e50;
                    font-size: 1.8rem;
                    margin-bottom: 20px;
                    padding-bottom: 10px;
                    border-bottom: 3px solid #667eea;
                    display: flex;
                    align-items: center;
                }

                h2::before {
                    content: '';
                    width: 8px;
                    height: 30px;
                    background: #667eea;
                    margin-right: 15px;
                    border-radius: 4px;
                }

                h3 {
                    color: #34495e;
                    font-size: 1.3rem;
                    margin-top: 25px;
                    margin-bottom: 15px;
                    padding-left: 15px;
                    border-left: 3px solid #667eea;
                }

                table {
                    width: 100%;
                    border-collapse: collapse;
                    margin-bottom: 20px;
                    background: white;
                    border-radius: 10px;
                    overflow: hidden;
                    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
                }

                th, td {
                    padding: 15px;
                    text-align: left;
                    border-bottom: 1px solid #ecf0f1;
                }

                th {
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    font-weight: 600;
                    text-transform: uppercase;
                    font-size: 0.85rem;
                    letter-spacing: 0.5px;
                }

                tr:nth-child(even) {
                    background: #f8f9fa;
                }

                tr:hover {
                    background: #e8f4fd;
                    transition: background 0.3s ease;
                }

                .key {
                    font-weight: 600;
                    color: #2c3e50;
                    width: 35%;
                }

                .value {
                    color: #34495e;
                    word-break: break-word;
                }

                .nested-table {
                    margin-left: 20px;
                    width: calc(100% - 20px);
                    margin-top: 10px;
                }

                .collapsible {
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    cursor: pointer;
                    padding: 18px 25px;
                    width: 100%;
                    border: none;
                    text-align: left;
                    outline: none;
                    font-size: 1rem;
                    font-weight: 600;
                    border-radius: 10px;
                    margin-bottom: 10px;
                    transition: all 0.3s ease;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                }

                .collapsible:hover {
                    transform: translateY(-2px);
                    box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
                }

                .collapsible::after {
                    content: '+';
                    font-size: 1.5rem;
                    transition: transform 0.3s ease;
                }

                .collapsible.active::after {
                    transform: rotate(45deg);
                }

                .content-collapsible {
                    padding: 0;
                    display: none;
                    overflow: hidden;
                    background: white;
                    margin-bottom: 20px;
                    border-radius: 10px;
                    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
                }

                .progress-bar {
                    width: 100%;
                    background-color: #ecf0f1;
                    border-radius: 10px;
                    height: 25px;
                    margin-top: 8px;
                    overflow: hidden;
                }

                .progress {
                    height: 100%;
                    background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
                    border-radius: 10px;
                    text-align: center;
                    color: white;
                    line-height: 25px;
                    font-weight: 600;
                    font-size: 0.9rem;
                    transition: width 0.5s ease;
                }

                .badge {
                    display: inline-block;
                    padding: 4px 12px;
                    background: #667eea;
                    color: white;
                    border-radius: 20px;
                    font-size: 0.85rem;
                    font-weight: 600;
                    margin-left: 10px;
                }

                .badge.success {
                    background: #27ae60;
                }

                .badge.warning {
                    background: #f39c12;
                }

                .badge.danger {
                    background: #e74c3c;
                }

                .alert {
                    padding: 15px;
                    margin-bottom: 20px;
                    border-radius: 10px;
                    display: flex;
                    align-items: center;
                }

                .alert.danger {
                    background-color: #fdecea;
                    border-left: 5px solid #e74c3c;
                    color: #e74c3c;
                }

                .alert.warning {
                    background-color: #fef9e7;
                    border-left: 5px solid #f39c12;
                    color: #f39c12;
                }

                .alert.success {
                    background-color: #eafaf1;
                    border-left: 5px solid #27ae60;
                    color: #27ae60;
                }

                .alert-icon {
                    margin-right: 15px;
                    font-size: 1.5rem;
                }

                footer {
                    background: #2c3e50;
                    color: white;
                    text-align: center;
                    padding: 30px;
                    font-size: 0.9rem;
                }

                .highlight {
                    background: linear-gradient(120deg, #a8edea 0%, #fed6e3 100%);
                    padding: 2px 6px;
                    border-radius: 4px;
                    font-weight: 600;
                }

                .startup-enabled {
                    color: #27ae60;
                    font-weight: 600;
                }

                .startup-disabled {
                    color: #e74c3c;
                    font-weight: 600;
                }

                @media (max-width: 768px) {
                    .container {
                        border-radius: 0;
                    }

                    h1 {
                        font-size: 2rem;
                    }

                    .summary-cards {
                        grid-template-columns: 1fr;
                        padding: 20px;
                    }

                    .content {
                        padding: 20px;
                    }

                    table {
                        font-size: 0.9rem;
                    }

                    th, td {
                        padding: 10px;
                    }
                }
            </style>
        </head>
        <body>
            <div class="container">
                <header>
                    <h1>PC System Report</h1>
                    <p class="subtitle">Generated on """ + self.report_data["system_info"]["Report Generated"] + """</p>
                </header>

                <div class="summary-cards">
                    <div class="card">
                        <h3>System</h3>
                        <div class="card-value">""" + self.report_data["system_info"]["Operating System"] + """</div>
                        <div class="card-label">Operating System</div>
                    </div>
                    <div class="card">
                        <h3>Processor</h3>
                        <div class="card-value">""" + str(self.report_data["hardware"]["CPU"]["Total Cores"]) + """</div>
                        <div class="card-label">CPU Cores</div>
                    </div>
                    <div class="card">
                        <h3>Memory</h3>
                        <div class="card-value">""" + self.report_data["hardware"]["Memory"]["Total Memory"] + """</div>
                        <div class="card-label">Total RAM</div>
                    </div>
                    <div class="card">
                        <h3>Uptime</h3>
                        <div class="card-value">""" + self.report_data["system_info"]["System Uptime"].split(',')[0] + """</div>
                        <div class="card-label">System Running</div>
                    </div>
                </div>

                <div class="content">
                    """ + self._generate_security_alerts() + """

                    <div class="section">
                        <h2>System Information</h2>
                        <table>
                            """ + self._generate_dict_table(self.report_data["system_info"]) + """
                        </table>
                    </div>

                    <div class="section">
                        <h2>Hardware Information</h2>
                        """ + self._generate_hardware_tables() + """
                    </div>

                    <div class="section">
                        <h2>Software Information <span class="badge">""" + str(len(self.report_data["software"])) + """</span></h2>
                        <button type="button" class="collapsible">View Installed Software</button>
                        <div class="content-collapsible">
                            <table>
                                """ + self._generate_dict_table(self.report_data["software"]) + """
                            </table>
                        </div>
                    </div>

                    """ + self._generate_updates_section() + """

                    <div class="section">
                        <h2>Security Vulnerabilities</h2>
                        """ + self._generate_vulnerability_section() + """
                    </div>

                    <div class="section">
                        <h2>Network Information</h2>
                        """ + self._generate_network_tables() + """
                    </div>

                    <div class="section">
                        <h2>Security Information</h2>
                        <table>
                            """ + self._generate_security_table(self.report_data["security"]) + """
                        </table>
                    </div>

                    <div class="section">
                        <h2>User Information</h2>
                        <table>
                            """ + self._generate_users_table(self.report_data["users"]) + """
                        </table>
                    </div>

                    <div class="section">
                        <h2>Startup Items <span class="badge">""" + str(self._count_startup_items()) + """</span></h2>
                        <button type="button" class="collapsible">View Startup Items</button>
                        <div class="content-collapsible">
                            """ + self._generate_startup_items_table() + """
                        </div>
                    </div>

                    <div class="section">
                        <h2>Running Processes <span class="badge">""" + str(len(self.report_data["processes"])) + """</span></h2>
                        <table>
                            """ + self._generate_processes_table(self.report_data["processes"]) + """
                        </table>
                    </div>

                    <div class="section">
                        <h2>System Services <span class="badge">""" + str(len(self.report_data["services"])) + """</span></h2>
                        <button type="button" class="collapsible">View System Services</button>
                        <div class="content-collapsible">
                            <table>
                                """ + self._generate_services_table(self.report_data["services"]) + """
                            </table>
                        </div>
                    </div>

                    <div class="section">
                        <h2>Hardware Devices <span class="badge">""" + str(len(self.report_data["devices"])) + """</span></h2>
                        <button type="button" class="collapsible">View Hardware Devices</button>
                        <div class="content-collapsible">
                            <table>
                                """ + self._generate_devices_table(self.report_data["devices"]) + """
                            </table>
                        </div>
                    </div>

                    <div class="section">
                        <h2>Environment Variables <span class="badge">""" + str(len(self.report_data["environment"])) + """</span></h2>
                        <button type="button" class="collapsible">View Environment Variables</button>
                        <div class="content-collapsible">
                            <table>
                                """ + self._generate_dict_table(self.report_data["environment"]) + """
                            </table>
                        </div>
                    </div>
                </div>

                <footer>
                    <p>PC Reporter - Comprehensive System Analysis Tool</p>
                    <p>Report generated on """ + self.report_data["system_info"]["Report Generated"] + """</p>
                </footer>
            </div>

            <script>
                var coll = document.getElementsByClassName("collapsible");
                var i;

                for (i = 0; i < coll.length; i++) {
                    coll[i].addEventListener("click", function() {
                        this.classList.toggle("active");
                        var content = this.nextElementSibling;
                        if (content.style.display === "block") {
                            content.style.display = "none";
                        } else {
                            content.style.display = "block";
                        }
                    });
                }

                // Add smooth scroll behavior
                document.querySelectorAll('a[href^="#"]').forEach(anchor => {
                    anchor.addEventListener("click", function (e) {
                        e.preventDefault();
                        document.querySelector(this.getAttribute("href")).scrollIntoView({
                            behavior: "smooth"
                        });
                    });
                });
            </script>
        </body>
        </html>"""

        # Write to file with UTF-8 encoding
        try:
            with open(self.report_file, "w", encoding='utf-8') as f:
                f.write(html_content)
        except Exception as e:
            print(f"Error writing HTML file: {e}")
            # Fallback: try without encoding parameter
            with open(self.report_file, "w") as f:
                f.write(html_content)

        return self.report_file

    def _count_startup_items(self):
        """Count the total number of startup items"""
        count = 0
        if "startup_items" in self.report_data:
            startup_data = self.report_data["startup_items"]
            for category, items in startup_data.items():
                if isinstance(items, dict):
                    for subcategory, subitems in items.items():
                        if isinstance(subitems, dict):
                            count += len(subitems)
        return count

    def _generate_startup_items_table(self):
        """Generate HTML table for startup items"""
        if "startup_items" not in self.report_data or not self.report_data["startup_items"]:
            return "<p>No startup items information available.</p>"

        startup_data = self.report_data["startup_items"]
        html = ""

        for category, items in startup_data.items():
            if isinstance(items, dict):
                html += f"<h3>{category}</h3>"
                for subcategory, subitems in items.items():
                    if isinstance(subitems, dict):
                        html += f"<h4>{subcategory}</h4>"
                        html += "<table>"
                        html += "<tr><th>Name</th><th>Value/Path</th><th>Status</th></tr>"
                        for name, info in subitems.items():
                            if isinstance(info, dict):
                                value_path = info.get("Value", info.get("Path", "N/A"))
                                status = info.get("Status", "Unknown")
                                status_class = "startup-enabled" if status == "Enabled" else "startup-disabled" if status == "Disabled" else ""
                                html += f"<tr><td>{name}</td><td>{value_path}</td><td class='{status_class}'>{status}</td></tr>"
                        html += "</table>"

        return html

    def _generate_security_alerts(self):
        """Generate security alerts based on vulnerability information"""
        alerts = ""

        if "vulnerabilities" in self.report_data and self.report_data["vulnerabilities"]:
            vuln = self.report_data["vulnerabilities"]

            # Check for pending updates
            if vuln.get("Status") == "Updates Available":
                alerts += """
                        <div class="alert warning">
                            <div class="alert-icon">⚠️</div>
                            <div>
                                <strong>Security Updates Available</strong><br>
                                Your system has pending security updates. Please install them as soon as possible to protect against vulnerabilities.
                            </div>
                        </div>
                        """

            # Check for Windows support status
            if vuln.get("Windows Support Status") == "End of Life - Security Risk":
                alerts += """
                        <div class="alert danger">
                            <div class="alert-icon">🔴</div>
                            <div>
                                <strong>Unsupported Windows Version</strong><br>
                                Your Windows version is no longer supported by Microsoft. This means you won't receive security updates and are at high risk. Consider upgrading to a supported version.
                            </div>
                        </div>
                        """

            # Check for Windows Defender status
            if "Windows Defender" in vuln:
                defender = vuln["Windows Defender"]
                if isinstance(defender, dict):
                    if defender.get("RealTimeProtectionEnabled") == "False":
                        alerts += """
                                <div class="alert danger">
                                    <div class="alert-icon">🔴</div>
                                    <div>
                                        <strong>Real-time Protection Disabled</strong><br>
                                        Windows Defender real-time protection is disabled. Your system is not protected against malware in real-time.
                                    </div>
                                </div>
                                """
                    elif defender.get("AntivirusEnabled") == "False":
                        alerts += """
                                <div class="alert danger">
                                    <div class="alert-icon">🔴</div>
                                    <div>
                                        <strong>Antivirus Disabled</strong><br>
                                        Windows Defender antivirus is disabled. Your system is not protected against viruses and malware.
                                    </div>
                                </div>
                                """

            # Check for firewall status
            if "Windows Firewall" in vuln:
                firewall = vuln["Windows Firewall"]
                if isinstance(firewall, dict):
                    for profile, status in firewall.items():
                        if status.lower() == "off":
                            alerts += f"""
                                    <div class="alert danger">
                                        <div class="alert-icon">🔴</div>
                                        <div>
                                            <strong>Firewall Disabled</strong><br>
                                            Windows Firewall is turned off for the {profile} profile. Your system may be vulnerable to network attacks.
                                        </div>
                                    </div>
                                    """
                            break  # Only show one firewall alert

        return alerts

    def _generate_vulnerability_section(self):
        """Generate HTML for the vulnerability section"""
        if "vulnerabilities" not in self.report_data or not self.report_data["vulnerabilities"]:
            return "<p>No vulnerability information available.</p>"

        vuln = self.report_data["vulnerabilities"]
        rows = ""

        for key, value in vuln.items():
            if key == "Windows Defender" and isinstance(value, dict):
                rows += f"<tr><td class='key'>{key}</td><td class='value'><table class='nested-table'>"
                for sub_key, sub_value in value.items():
                    status = "success" if "True" in str(sub_value) else "danger" if "False" in str(
                        sub_value) else ""
                    badge = f" <span class='badge {status}'>{sub_value}</span>" if status else f" {sub_value}"
                    rows += f"<tr><td class='key'>{sub_key}</td><td class='value'>{badge}</td></tr>"
                rows += "</table></td></tr>"
            elif key == "Windows Firewall" and isinstance(value, dict):
                rows += f"<tr><td class='key'>{key}</td><td class='value'><table class='nested-table'>"
                for profile, status in value.items():
                    status_class = "success" if status.lower() == "on" else "danger" if status.lower() == "off" else ""
                    badge = f" <span class='badge {status_class}'>{status}</span>" if status_class else f" {status}"
                    rows += f"<tr><td class='key'>{profile}</td><td class='value'>{badge}</td></tr>"
                rows += "</table></td></tr>"
            elif key == "Status":
                status_class = "success" if value == "Up to Date" else "warning" if value == "Updates Available" else ""
                badge = f" <span class='badge {status_class}'>{value}</span>" if status_class else f" {value}"
                rows += f"<tr><td class='key'>{key}</td><td class='value'>{badge}</td></tr>"
            elif key == "Windows Support Status":
                status_class = "success" if value == "Supported" else "danger" if "End of Life" in value else ""
                badge = f" <span class='badge {status_class}'>{value}</span>" if status_class else f" {value}"
                rows += f"<tr><td class='key'>{key}</td><td class='value'>{badge}</td></tr>"
            else:
                rows += f"<tr><td class='key'>{key}</td><td class='value'>{value}</td></tr>"

        return f"<table>{rows}</table>"

    def _generate_updates_section(self):
        """Generate Windows updates section"""
        if "updates" in self.report_data and self.report_data["updates"]:
            return """
                    <div class="section">
                        <h2>Windows Updates <span class="badge">""" + str(len(self.report_data["updates"])) + """</span></h2>
                        <button type="button" class="collapsible">View Recent Updates</button>
                        <div class="content-collapsible">
                            <table>
                                """ + self._generate_updates_table(self.report_data["updates"]) + """
                            </table>
                        </div>
                    </div>
                    """
        return ""

    def _generate_updates_table(self, data):
        """Generate HTML table for Windows updates"""
        if isinstance(data, dict) and "Error" in data:
            return f"<tr><td colspan='3'>{data['Error']}</td></tr>"

        rows = "<tr><th>Hotfix ID</th><th>Installed On</th><th>Installed By</th></tr>"
        for update in data:
            rows += f"<tr><td>{update.get('Hotfix ID', '')}</td><td>{update.get('Installed On', '')}</td><td>{update.get('Installed By', '')}</td></tr>"

        return rows

    def _generate_hardware_tables(self):
        """Generate HTML tables for hardware information"""
        hardware_tables = ""
        for category, data in self.report_data["hardware"].items():
            if isinstance(data, dict):
                hardware_tables += f"<h3>{category}</h3>"
                if category == "Storage":
                    hardware_tables += self._generate_storage_table(data)
                elif category == "CPU" and "CPU Usage Per Core" in data:
                    hardware_tables += self._generate_cpu_table(data)
                else:
                    hardware_tables += self._generate_dict_table(data)
        return hardware_tables

    def _generate_cpu_table(self, data):
        """Generate HTML table for CPU information with per-core usage"""
        rows = ""
        for key, value in data.items():
            if key == "CPU Usage Per Core":
                rows += f"<tr><td class='key'>{key}</td><td class='value'>"
                for core, usage in value.items():
                    rows += f"<div style='margin-bottom: 5px;'>Core {core}: <span class='highlight'>{usage}%</span></div>"
                rows += "</td></tr>"
            else:
                rows += f"<tr><td class='key'>{key}</td><td class='value'>{value}</td></tr>"
        return rows

    def _generate_network_tables(self):
        """Generate HTML tables for network information"""
        network_tables = ""
        for category, data in self.report_data["network"].items():
            if category == "Interfaces":
                network_tables += "<h3>Network Interfaces</h3>"
                network_tables += self._generate_interfaces_table(data)
            elif category == "Active Connections":
                network_tables += "<h3>Active Connections</h3>"
                network_tables += self._generate_connections_table(data)
            elif category == "DNS Servers":
                network_tables += "<h3>DNS Servers</h3>"
                network_tables += self._generate_list_table(data, "DNS Server")
            else:
                network_tables += f"<h3>{category}</h3>"
                network_tables += self._generate_dict_table(data)
        return network_tables

    def _generate_list_table(self, data, label):
        """Generate HTML table from list data"""
        if not data:
            return "<tr><td>No data available</td></tr>"

        rows = ""
        for item in data:
            rows += f"<tr><td class='value'><div class='highlight'>{item}</div></td></tr>"

        return rows

    def _generate_connections_table(self, data):
        """Generate HTML table for active connections"""
        if not data:
            return "<tr><td colspan='4'>No active connections</td></tr>"

        rows = "<tr><th>Local Address</th><th>Remote Address</th><th>Status</th><th>PID</th></tr>"
        for conn in data:
            rows += f"<tr><td>{conn['Local Address']}</td><td>{conn['Remote Address']}</td><td>{conn['Status']}</td><td>{conn['PID']}</td></tr>"

        return rows

    def _generate_dict_table(self, data):
        """Generate HTML table from dictionary data"""
        if not data:
            return "<tr><td colspan='2'>No data available</td></tr>"

        rows = ""
        for key, value in data.items():
            if isinstance(value, dict):
                rows += f"<tr><td class='key'>{key}</td><td class='value'><table class='nested-table'>"
                for sub_key, sub_value in value.items():
                    rows += f"<tr><td class='key'>{sub_key}</td><td class='value'>{sub_value}</td></tr>"
                rows += "</table></td></tr>"
            else:
                rows += f"<tr><td class='key'>{key}</td><td class='value'>{value}</td></tr>"

        return rows

    def _generate_storage_table(self, data):
        """Generate HTML table for storage information"""
        if not data:
            return "<tr><td colspan='2'>No storage information available</td></tr>"

        rows = ""
        for drive, info in data.items():
            rows += f"<tr><td class='key'>{drive}</td><td class='value'><table class='nested-table'>"
            for key, value in info.items():
                if key == "Percentage":
                    # Add a progress bar for percentage
                    rows += f"<tr><td class='key'>{key}</td><td class='value'>"
                    rows += f"<div class='progress-bar'><div class='progress' style='width:{value}'>{value}</div></div>"
                    rows += "</td></tr>"
                else:
                    rows += f"<tr><td class='key'>{key}</td><td class='value'>{value}</td></tr>"
            rows += "</table></td></tr>"

        return rows

    def _generate_interfaces_table(self, data):
        """Generate HTML table for network interfaces"""
        if not data:
            return "<tr><td colspan='2'>No network interface information available</td></tr>"

        rows = ""
        for interface, info in data.items():
            rows += f"<tr><td class='key'>{interface}</td><td class='value'><table class='nested-table'>"
            for key, value in info.items():
                if key == "IP Addresses" and isinstance(value, list):
                    rows += f"<tr><td class='key'>{key}</td><td class='value'>"
                    for ip in value:
                        rows += f"<div class='highlight'>{ip['Address']}</div> Netmask: {ip['Netmask']}<br>"
                    rows += "</td></tr>"
                else:
                    rows += f"<tr><td class='key'>{key}</td><td class='value'>{value}</td></tr>"
            rows += "</table></td></tr>"

        return rows

    def _generate_security_table(self, data):
        """Generate HTML table for security information"""
        if not data:
            return "<tr><td colspan='2'>No security information available</td></tr>"

        rows = ""
        for key, value in data.items():
            if isinstance(value, dict):
                rows += f"<tr><td class='key'>{key}</td><td class='value'><table class='nested-table'>"
                for sub_key, sub_value in value.items():
                    status = "success" if "Enabled" in str(sub_value) or "On" in str(
                        sub_value) else "danger" if "Disabled" in str(sub_value) or "Off" in str(sub_value) else ""
                    badge = f" <span class='badge {status}'>{sub_value}</span>" if status else f" {sub_value}"
                    rows += f"<tr><td class='key'>{sub_key}</td><td class='value'>{badge}</td></tr>"
                rows += "</table></td></tr>"
            else:
                rows += f"<tr><td class='key'>{key}</td><td class='value'>{value}</td></tr>"

        return rows

    def _generate_users_table(self, data):
        """Generate HTML table for user information"""
        if not data:
            return "<tr><td colspan='2'>No user information available</td></tr>"

        rows = ""
        for key, value in data.items():
            if key == "User Accounts" and isinstance(value, list):
                rows += f"<tr><td class='key'>{key}</td><td class='value'>"
                for user in value:
                    rows += f"<div class='highlight'>{user}</div>"
                rows += "</td></tr>"
            elif key == "User Groups" and isinstance(value, list):
                rows += f"<tr><td class='key'>{key}</td><td class='value'>"
                for group in value:
                    rows += f"<span class='badge'>{group}</span> "
                rows += "</td></tr>"
            else:
                rows += f"<tr><td class='key'>{key}</td><td class='value'>{value}</td></tr>"

        return rows

    def _generate_processes_table(self, data):
        """Generate HTML table for processes"""
        if not data:
            return "<tr><td colspan='6'>No process information available</td></tr>"

        rows = "<tr><th>PID</th><th>Name</th><th>User</th><th>CPU %</th><th>Memory %</th><th>Memory (MB)</th><th>Started</th></tr>"
        for process in data:
            rows += f"<tr><td>{process['PID']}</td><td>{process['Name']}</td><td>{process['User']}</td><td>{process['CPU %']}</td><td>{process['Memory %']}</td><td>{process['Memory (MB)']}</td><td>{process['Started']}</td></tr>"

        return rows

    def _generate_services_table(self, data):
        """Generate HTML table for services"""
        if not data:
            return "<tr><td colspan='5'>No service information available</td></tr>"

        # Determine headers based on the first service
        if data and isinstance(data[0], dict):
            headers = list(data[0].keys())
            rows = "<tr>" + "".join([f"<th>{h}</th>" for h in headers]) + "</tr>"

            for service in data:
                rows += "<tr>"
                for header in headers:
                    value = service.get(header, '')
                    if header == "State":
                        if "RUNNING" in value:
                            value = f"<span class='badge success'>{value}</span>"
                        elif "STOPPED" in value:
                            value = f"<span class='badge danger'>{value}</span>"
                        else:
                            value = f"<span class='badge warning'>{value}</span>"
                    rows += f"<td>{value}</td>"
                rows += "</tr>"

            return rows

        return "<tr><td colspan='5'>Invalid service data format</td></tr>"

    def _generate_devices_table(self, data):
        """Generate HTML table for devices"""
        if not data:
            return "<tr><td colspan='4'>No device information available</td></tr>"

        rows = "<tr><th>Name</th><th>Description</th><th>Manufacturer</th><th>Device ID</th></tr>"
        for device in data:
            if "Error" in device:
                rows += f"<tr><td colspan='4'>{device['Error']}</td></tr>"
            else:
                rows += f"<tr><td>{device.get('Name', '')}</td><td>{device.get('Description', '')}</td><td>{device.get('Manufacturer', '')}</td><td>{device.get('Device ID', '')}</td></tr>"

        return rows


class SystemCleanerGUI:
    def __init__(self, root, theme=DARK_THEME):
        try:
            self.root = root
            self.theme = theme
            self.current_theme = 'dark'
            self.widgets = []
            self.widget_fonts = {}  # Store original font settings for each widget
            self.font_size_factor = 1.0  # Default font size factor

            # Load font size preference if it exists
            try:
                if os.path.exists("font_size_pref.json"):
                    with open("font_size_pref.json", "r") as f:
                        pref = json.load(f)
                        self.font_size_factor = pref.get("font_size_factor", 1.0)
            except:
                pass

            self.root.title("WINDOWS SYSTEM CLEANER")
            self.root.geometry("1200x900")  # Increased window size
            self.root.minsize(1000, 700)  # Set minimum size
            self.root.resizable(True, True)

            # Apply theme to root
            self.root.configure(bg=self.theme['bg'])

            # Create menu
            self.create_menu()

            # Task progress tracking
            self.task_progress = {}
            self.total_tasks = 0
            self.completed_tasks = 0
            self.start_time = None
            self.progress_active = False

            # Create GUI elements
            self.create_widgets()

            # Check if running as admin
            self.admin_status = self.is_admin()
            self.update_admin_status()

            # Queue for thread communication
            self.queue = queue.Queue()

        except Exception as e:
            messagebox.showerror("Initialization Error", f"Failed to initialize GUI: {str(e)}")
            sys.exit(1)

    def create_menu(self):
        """Create the application menu"""
        menubar = Menu(self.root, bg=self.theme['menu_bg'], fg=self.theme['menu_fg'])
        self.root.config(menu=menubar)

        # View menu
        view_menu = Menu(menubar, tearoff=0, bg=self.theme['menu_bg'], fg=self.theme['menu_fg'])
        menubar.add_cascade(label="View", menu=view_menu)

        # Dark mode toggle
        self.dark_mode_var = tk.BooleanVar(value=True)
        view_menu.add_checkbutton(
            label="Dark Mode",
            variable=self.dark_mode_var,
            command=self.toggle_dark_mode
        )

        # Font size menu
        font_menu = Menu(menubar, tearoff=0, bg=self.theme['menu_bg'], fg=self.theme['menu_fg'])
        menubar.add_cascade(label="Change Font Size", menu=font_menu)

        # Font size options
        self.font_size_var = tk.IntVar(value=10)  # Default to medium
        font_menu.add_radiobutton(
            label="Small",
            variable=self.font_size_var,
            value=8,
            command=lambda: self.change_font_size(8)
        )
        font_menu.add_radiobutton(
            label="Medium",
            variable=self.font_size_var,
            value=10,
            command=lambda: self.change_font_size(10)
        )
        font_menu.add_radiobutton(
            label="Large",
            variable=self.font_size_var,
            value=12,
            command=lambda: self.change_font_size(12)
        )
        font_menu.add_radiobutton(
            label="Extra Large",
            variable=self.font_size_var,
            value=14,
            command=lambda: self.change_font_size(14)
        )

        # Register menu for theme updates
        self.widgets.append(('menu', menubar))
        self.widgets.append(('menu', view_menu))
        self.widgets.append(('menu', font_menu))

    def change_font_size(self, size):
        """Change the font size of all widgets in the GUI"""
        # Calculate the factor based on the default size (10)
        self.font_size_factor = size / 10.0

        # Save the preference
        try:
            with open("font_size_pref.json", "w") as f:
                json.dump({"font_size_factor": self.font_size_factor}, f)
        except:
            pass

        # Update all widget fonts
        self.update_all_fonts()

    def update_all_fonts(self):
        """Update the font size of all registered widgets"""
        for widget, original_font in self.widget_fonts.items():
            if original_font:
                # original_font is a tuple: (family, size, ...)
                family = original_font[0]
                base_size = original_font[1]
                # The rest of the tuple (if any) are the style options
                style = original_font[2:] if len(original_font) > 2 else ()
                new_size = int(base_size * self.font_size_factor)
                new_font = (family, new_size) + style
                try:
                    widget.config(font=new_font)
                except:
                    pass  # Ignore errors

    def toggle_dark_mode(self):
        """Toggle between light and dark mode"""
        if self.dark_mode_var.get():
            self.current_theme = 'dark'
            self.theme = DARK_THEME
        else:
            self.current_theme = 'light'
            self.theme = LIGHT_THEME

        # Apply theme to all widgets
        self.apply_theme()

        # Update progress bar style
        self.style.configure("green.Horizontal.TProgressbar", background=self.theme['progress_bg'])

        # Save theme preference
        try:
            with open("theme_pref.json", "w") as f:
                json.dump({"dark_mode": self.dark_mode_var.get()}, f)
        except:
            pass

    def apply_theme(self):
        """Apply the current theme to all registered widgets"""
        for widget_type, widget in self.widgets:
            try:
                if widget_type == 'label':
                    widget.config(bg=self.theme['label_bg'], fg=self.theme['label_fg'])
                elif widget_type == 'button':
                    widget.config(bg=self.theme['button_bg'], fg=self.theme['button_fg'])
                elif widget_type == 'entry':
                    widget.config(bg=self.theme['entry_bg'], fg=self.theme['entry_fg'])
                elif widget_type == 'text':
                    widget.config(bg=self.theme['text_bg'], fg=self.theme['text_fg'])
                elif widget_type == 'log':
                    widget.config(bg=self.theme['text_bg'], fg=self.theme['log_text_fg'])
                elif widget_type == 'frame':
                    widget.config(bg=self.theme['frame_bg'])
                elif widget_type == 'labelframe':
                    widget.config(bg=self.theme['frame_bg'], fg=self.theme['fg'])
                elif widget_type == 'checkbutton':
                    widget.config(bg=self.theme['frame_bg'], fg=self.theme['fg'],
                                  selectcolor=self.theme['frame_bg'])
                elif widget_type == 'progress':
                    widget.config(style="green.Horizontal.TProgressbar")
                elif widget_type == 'menu':
                    # For menus, we need to update the menu itself and its items
                    widget.config(bg=self.theme['menu_bg'], fg=self.theme['menu_fg'])
                    # Update menu items
                    if isinstance(widget, Menu):
                        for index in range(widget.index(tk.END) + 1):
                            try:
                                widget.entryconfig(index, bg=self.theme['menu_bg'], fg=self.theme['menu_fg'])
                            except:
                                pass
            except Exception as e:
                pass  # Silently ignore theme application errors

        # Update root window
        self.root.configure(bg=self.theme['bg'])

        # Update additional frames
        if hasattr(self, 'left_frame'):
            self.left_frame.configure(bg=self.theme['bg'])
        if hasattr(self, 'right_frame'):
            self.right_frame.configure(bg=self.theme['bg'])

    def create_widgets(self):
        try:
            # Header frame
            self.header_frame = tk.Frame(self.root, bd=2, relief=tk.RAISED, bg=self.theme['header_bg'])
            self.header_frame.pack(fill=tk.X)
            self.widgets.append(('frame', self.header_frame))

            # Title
            title_font = ('Arial', 16, 'bold')
            self.title_label = tk.Label(
                self.header_frame,
                text="WINDOWS SYSTEM CLEANER",
                font=title_font,
                bg=self.theme['header_bg'],
                fg=self.theme['header_fg']
            )
            self.title_label.pack(side=tk.LEFT, padx=20, pady=15)
            self.widgets.append(('label', self.title_label))
            self.widget_fonts[self.title_label] = title_font

            # Main container
            self.main_container = tk.Frame(self.root, bd=2, relief=tk.SUNKEN, bg=self.theme['bg'])
            self.main_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=(0, 10))
            self.widgets.append(('frame', self.main_container))

            # Admin status frame
            admin_frame = tk.Frame(self.main_container, bg=self.theme['bg'])
            admin_frame.pack(fill=tk.X, pady=(0, 10))  # Reduced from 15 to 10
            self.widgets.append(('frame', admin_frame))

            admin_font = ('Arial', 10)
            self.admin_label = tk.Label(admin_frame, text="", font=admin_font,
                                        bg=self.theme['bg'], fg=self.theme['admin_fg'])
            self.admin_label.pack(side=tk.LEFT, padx=(0, 10))
            self.widgets.append(('label', self.admin_label))
            self.widget_fonts[self.admin_label] = admin_font

            # Create a frame for the two columns
            columns_frame = tk.Frame(self.main_container, bg=self.theme['bg'])
            columns_frame.pack(fill=tk.BOTH, expand=True)
            self.widgets.append(('frame', columns_frame))

            # Left column - Core System tasks and App settings
            self.left_frame = tk.Frame(columns_frame, bg=self.theme['bg'])
            self.left_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 5), pady=(0, 10))
            self.widgets.append(('frame', self.left_frame))

            # Core System tasks frame (in left column)
            task_frame_font = ('Arial', 10, 'bold')
            self.task_frame = tk.LabelFrame(
                self.left_frame,
                text="CORE SYSTEM TASKS",
                font=task_frame_font,
                bd=2,
                relief=tk.GROOVE,
                bg=self.theme['frame_bg'],
                fg=self.theme['fg']
            )
            self.task_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 5))  # Reduced from 20 to 10
            self.widgets.append(('labelframe', self.task_frame))
            self.widget_fonts[self.task_frame] = task_frame_font

            # App settings frame (in left column)
            app_frame_font = ('Arial', 10, 'bold')
            self.app_frame = tk.LabelFrame(
                self.left_frame,
                text="APP SETTINGS",
                font=app_frame_font,
                bd=2,
                relief=tk.GROOVE,
                bg=self.theme['frame_bg'],
                fg=self.theme['fg']
            )
            self.app_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))  # Reduced from 20 to 10
            self.widgets.append(('labelframe', self.app_frame))
            self.widget_fonts[self.app_frame] = app_frame_font

            # Right column - Additional tasks
            self.right_frame = tk.Frame(columns_frame, bg=self.theme['bg'])
            self.right_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=(5, 0),
                                  pady=(0, 10))  # Reduced from 20 to 10
            self.widgets.append(('frame', self.right_frame))

            # Additional system tasks frame (in right column)
            additional_task_frame_font = ('Arial', 10, 'bold')
            self.additional_task_frame = tk.LabelFrame(
                self.right_frame,
                text="ADDITIONAL SYSTEM TASKS",
                font=additional_task_frame_font,
                bd=2,
                relief=tk.GROOVE,
                bg=self.theme['frame_bg'],
                fg=self.theme['fg']
            )
            self.additional_task_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))  # Reduced from 20 to 10
            self.widgets.append(('labelframe', self.additional_task_frame))
            self.widget_fonts[self.additional_task_frame] = additional_task_frame_font

            # Core system tasks checkboxes (left column)
            self.checkbox_frame = tk.Frame(self.task_frame, bg=self.theme['frame_bg'])
            self.checkbox_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)  # Reduced from 15,10 to 10,5
            self.widgets.append(('frame', self.checkbox_frame))

            # App settings checkboxes (left column)
            self.app_checkbox_frame = tk.Frame(self.app_frame, bg=self.theme['frame_bg'])
            self.app_checkbox_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)  # Reduced from 15,10 to 10,5
            self.widgets.append(('frame', self.app_checkbox_frame))

            # Additional system tasks checkboxes (right column)
            self.additional_checkbox_frame = tk.Frame(self.additional_task_frame, bg=self.theme['frame_bg'])
            self.additional_checkbox_frame.pack(fill=tk.BOTH, expand=True, padx=10,
                                                pady=5)  # Reduced from 15,10 to 10,5
            self.widgets.append(('frame', self.additional_checkbox_frame))

            # Task variables
            self.clean_temp = tk.BooleanVar(value=False)
            self.disk_cleanup = tk.BooleanVar(value=False)
            self.disable_fast_startup = tk.BooleanVar(value=False)
            self.repair_system = tk.BooleanVar(value=False)
            self.autopilot_csv = tk.BooleanVar(value=False)
            self.chk_dsk = tk.BooleanVar(value=False)
            self.windows_adjustments = tk.BooleanVar(value=False)
            self.windows_updates = tk.BooleanVar(value=False)
            self.device_firmware = tk.BooleanVar(value=False)
            self.flush_dns = tk.BooleanVar(value=False)
            self.ipconfig_all = tk.BooleanVar(value=False)
            self.change_dns = tk.BooleanVar(value=False)
            self.pc_report = tk.BooleanVar(value=False)  # New PC Report option
            self.chris_titus_utility = tk.BooleanVar(value=False)  # New Chris Titus Utility option

            # App settings variables
            self.stop_background_apps_var = tk.BooleanVar(value=False)
            self.disable_startup_apps_var = tk.BooleanVar(value=False)
            self.update_apps = tk.BooleanVar(value=False)

            # Create core system tasks checkboxes (left column) - with smaller font and padding
            temp_font = ('Arial', 8)
            temp_frame = tk.Frame(self.checkbox_frame, bg=self.theme['frame_bg'])
            temp_frame.pack(fill=tk.X, pady=1)

            self.temp_checkbox = tk.Checkbutton(
                temp_frame,
                text="Clean Temp Files (%TEMP%, TEMP, PREFETCH)",
                variable=self.clean_temp,
                font=temp_font,
                anchor=tk.W,
                bg=self.theme['frame_bg'],
                fg=self.theme['fg'],
                selectcolor=self.theme['frame_bg']
            )
            self.temp_checkbox.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.widgets.append(('checkbutton', self.temp_checkbox))
            self.widget_fonts[self.temp_checkbox] = temp_font

            # Add admin indicator
            temp_indicator = tk.Label(
                temp_frame,
                text="A",
                font=('Arial', 8, 'bold'),
                bg=self.theme['frame_bg'],
                fg=self.theme['admin_indicator']
            )
            temp_indicator.pack(side=tk.RIGHT, padx=(5, 0))

            # Add tooltip
            Tooltip(self.temp_checkbox, "Removes temporary files from system directories to free up disk space",
                    self.theme)
            Tooltip(temp_indicator, "Requires Administrator privileges", self.theme)

            disk_cleanup_font = ('Arial', 8)
            disk_cleanup_frame = tk.Frame(self.checkbox_frame, bg=self.theme['frame_bg'])
            disk_cleanup_frame.pack(fill=tk.X, pady=1)

            self.disk_cleanup_checkbox = tk.Checkbutton(
                disk_cleanup_frame,
                text="Disk Cleanup (All Options)",
                variable=self.disk_cleanup,
                font=disk_cleanup_font,
                anchor=tk.W,
                bg=self.theme['frame_bg'],
                fg=self.theme['fg'],
                selectcolor=self.theme['frame_bg']
            )
            self.disk_cleanup_checkbox.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.widgets.append(('checkbutton', self.disk_cleanup_checkbox))
            self.widget_fonts[self.disk_cleanup_checkbox] = disk_cleanup_font

            # Add admin indicator
            disk_cleanup_indicator = tk.Label(
                disk_cleanup_frame,
                text="A",
                font=('Arial', 8, 'bold'),
                bg=self.theme['frame_bg'],
                fg=self.theme['admin_indicator']
            )
            disk_cleanup_indicator.pack(side=tk.RIGHT, padx=(5, 0))

            # Add tooltip
            Tooltip(self.disk_cleanup_checkbox,
                    "Runs Windows Disk Cleanup with all options enabled to remove unnecessary files", self.theme)
            Tooltip(disk_cleanup_indicator, "Requires Administrator privileges", self.theme)

            fast_startup_font = ('Arial', 8)
            fast_startup_frame = tk.Frame(self.checkbox_frame, bg=self.theme['frame_bg'])
            fast_startup_frame.pack(fill=tk.X, pady=1)

            self.fast_startup_checkbox = tk.Checkbutton(
                fast_startup_frame,
                text="Disable Fast Startup",
                variable=self.disable_fast_startup,
                font=fast_startup_font,
                anchor=tk.W,
                bg=self.theme['frame_bg'],
                fg=self.theme['fg'],
                selectcolor=self.theme['frame_bg']
            )
            self.fast_startup_checkbox.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.widgets.append(('checkbutton', self.fast_startup_checkbox))
            self.widget_fonts[self.fast_startup_checkbox] = fast_startup_font

            # Add admin indicator
            fast_startup_indicator = tk.Label(
                fast_startup_frame,
                text="A",
                font=('Arial', 8, 'bold'),
                bg=self.theme['frame_bg'],
                fg=self.theme['admin_indicator']
            )
            fast_startup_indicator.pack(side=tk.RIGHT, padx=(5, 0))

            # Add tooltip
            Tooltip(self.fast_startup_checkbox,
                    "Disables Windows Fast Startup feature for faster shutdowns and better compatibility", self.theme)
            Tooltip(fast_startup_indicator, "Requires Administrator privileges", self.theme)

            # Create additional system tasks checkboxes (right column) - with smaller font and padding
            pc_report_font = ('Arial', 8)
            pc_report_frame = tk.Frame(self.additional_checkbox_frame, bg=self.theme['frame_bg'])
            pc_report_frame.pack(fill=tk.X, pady=1)

            self.pc_report_checkbox = tk.Checkbutton(
                pc_report_frame,
                text="PC Report (Detailed System Information)",
                variable=self.pc_report,
                font=pc_report_font,
                anchor=tk.W,
                bg=self.theme['frame_bg'],
                fg=self.theme['fg'],
                selectcolor=self.theme['frame_bg']
            )
            self.pc_report_checkbox.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.widgets.append(('checkbutton', self.pc_report_checkbox))
            self.widget_fonts[self.pc_report_checkbox] = pc_report_font

            # Add user indicator
            pc_report_indicator = tk.Label(
                pc_report_frame,
                text="U",
                font=('Arial', 8, 'bold'),
                bg=self.theme['frame_bg'],
                fg=self.theme['user_indicator']
            )
            pc_report_indicator.pack(side=tk.RIGHT, padx=(5, 0))

            # Add tooltip
            Tooltip(self.pc_report_checkbox, "Generates a detailed system report similar to Belarc Advisor", self.theme)
            Tooltip(pc_report_indicator, "Can be run as standard user", self.theme)

            # Chris Titus Windows Utility checkbox
            chris_titus_font = ('Arial', 8)
            chris_titus_frame = tk.Frame(self.additional_checkbox_frame, bg=self.theme['frame_bg'])
            chris_titus_frame.pack(fill=tk.X, pady=1)

            self.chris_titus_checkbox = tk.Checkbutton(
                chris_titus_frame,
                text="Chris Titus Windows Utility",
                variable=self.chris_titus_utility,
                font=chris_titus_font,
                anchor=tk.W,
                bg=self.theme['frame_bg'],
                fg=self.theme['fg'],
                selectcolor=self.theme['frame_bg']
            )
            self.chris_titus_checkbox.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.widgets.append(('checkbutton', self.chris_titus_checkbox))
            self.widget_fonts[self.chris_titus_checkbox] = chris_titus_font

            # Add admin indicator
            chris_titus_indicator = tk.Label(
                chris_titus_frame,
                text="A",
                font=('Arial', 8, 'bold'),
                bg=self.theme['frame_bg'],
                fg=self.theme['admin_indicator']
            )
            chris_titus_indicator.pack(side=tk.RIGHT, padx=(5, 0))

            # Add tooltip
            Tooltip(self.chris_titus_checkbox, "Runs Chris Titus Windows Utility script for system optimization", self.theme)
            Tooltip(chris_titus_indicator, "Requires Administrator privileges", self.theme)

            windows_updates_font = ('Arial', 8)
            windows_updates_frame = tk.Frame(self.additional_checkbox_frame, bg=self.theme['frame_bg'])
            windows_updates_frame.pack(fill=tk.X, pady=1)

            self.windows_updates_checkbox = tk.Checkbutton(
                windows_updates_frame,
                text="Check and Install Windows Updates",
                variable=self.windows_updates,
                font=windows_updates_font,
                anchor=tk.W,
                bg=self.theme['frame_bg'],
                fg=self.theme['fg'],
                selectcolor=self.theme['frame_bg']
            )
            self.windows_updates_checkbox.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.widgets.append(('checkbutton', self.windows_updates_checkbox))
            self.widget_fonts[self.windows_updates_checkbox] = windows_updates_font

            # Add admin indicator
            windows_updates_indicator = tk.Label(
                windows_updates_frame,
                text="A",
                font=('Arial', 8, 'bold'),
                bg=self.theme['frame_bg'],
                fg=self.theme['admin_indicator']
            )
            windows_updates_indicator.pack(side=tk.RIGHT, padx=(5, 0))

            # Add tooltip
            Tooltip(self.windows_updates_checkbox,
                    "Checks for and installs available Windows updates (may require reboot)", self.theme)
            Tooltip(windows_updates_indicator, "Requires Administrator privileges", self.theme)

            device_firmware_font = ('Arial', 8)
            device_firmware_frame = tk.Frame(self.additional_checkbox_frame, bg=self.theme['frame_bg'])
            device_firmware_frame.pack(fill=tk.X, pady=1)

            self.device_firmware_checkbox = tk.Checkbutton(
                device_firmware_frame,
                text="Device Firmware Updates",
                variable=self.device_firmware,
                font=device_firmware_font,
                anchor=tk.W,
                bg=self.theme['frame_bg'],
                fg=self.theme['fg'],
                selectcolor=self.theme['frame_bg']
            )
            self.device_firmware_checkbox.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.widgets.append(('checkbutton', self.device_firmware_checkbox))
            self.widget_fonts[self.device_firmware_checkbox] = device_firmware_font

            # Add admin indicator
            device_firmware_indicator = tk.Label(
                device_firmware_frame,
                text="A",
                font=('Arial', 8, 'bold'),
                bg=self.theme['frame_bg'],
                fg=self.theme['admin_indicator']
            )
            device_firmware_indicator.pack(side=tk.RIGHT, padx=(5, 0))

            # Add tooltip
            Tooltip(self.device_firmware_checkbox,
                    "Checks for and installs firmware updates for Dell, HP, and Lenovo systems", self.theme)
            Tooltip(device_firmware_indicator, "Requires Administrator privileges", self.theme)

            repair_system_font = ('Arial', 8)
            repair_system_frame = tk.Frame(self.additional_checkbox_frame, bg=self.theme['frame_bg'])
            repair_system_frame.pack(fill=tk.X, pady=1)

            self.repair_system_checkbox = tk.Checkbutton(
                repair_system_frame,
                text="Repair System (SFC/DISM)",
                variable=self.repair_system,
                font=repair_system_font,
                anchor=tk.W,
                bg=self.theme['frame_bg'],
                fg=self.theme['fg'],
                selectcolor=self.theme['frame_bg']
            )
            self.repair_system_checkbox.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.widgets.append(('checkbutton', self.repair_system_checkbox))
            self.widget_fonts[self.repair_system_checkbox] = repair_system_font

            # Add admin indicator
            repair_system_indicator = tk.Label(
                repair_system_frame,
                text="A",
                font=('Arial', 8, 'bold'),
                bg=self.theme['frame_bg'],
                fg=self.theme['admin_indicator']
            )
            repair_system_indicator.pack(side=tk.RIGHT, padx=(5, 0))

            # Add tooltip
            Tooltip(self.repair_system_checkbox,
                    "Repairs Windows system files using SFC and DISM tools (may take 30+ minutes)", self.theme)
            Tooltip(repair_system_indicator, "Requires Administrator privileges", self.theme)

            chk_dsk_font = ('Arial', 8)
            chk_dsk_frame = tk.Frame(self.additional_checkbox_frame, bg=self.theme['frame_bg'])
            chk_dsk_frame.pack(fill=tk.X, pady=1)

            self.chk_dsk_checkbox = tk.Checkbutton(
                chk_dsk_frame,
                text="CHKDSK C: /R (Requires Reboot)",
                variable=self.chk_dsk,
                font=chk_dsk_font,
                anchor=tk.W,
                bg=self.theme['frame_bg'],
                fg=self.theme['fg'],
                selectcolor=self.theme['frame_bg']
            )
            self.chk_dsk_checkbox.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.widgets.append(('checkbutton', self.chk_dsk_checkbox))
            self.widget_fonts[self.chk_dsk_checkbox] = chk_dsk_font

            # Add admin indicator
            chk_dsk_indicator = tk.Label(
                chk_dsk_frame,
                text="A",
                font=('Arial', 8, 'bold'),
                bg=self.theme['frame_bg'],
                fg=self.theme['admin_indicator']
            )
            chk_dsk_indicator.pack(side=tk.RIGHT, padx=(5, 0))

            # Add tooltip
            Tooltip(self.chk_dsk_checkbox, "Schedules CHKDSK to run on next reboot to check and repair disk errors",
                    self.theme)
            Tooltip(chk_dsk_indicator, "Requires Administrator privileges", self.theme)

            windows_adjustments_font = ('Arial', 8)
            windows_adjustments_frame = tk.Frame(self.additional_checkbox_frame, bg=self.theme['frame_bg'])
            windows_adjustments_frame.pack(fill=tk.X, pady=1)

            self.windows_adjustments_checkbox = tk.Checkbutton(
                windows_adjustments_frame,
                text="Windows Adjustments",
                variable=self.windows_adjustments,
                font=windows_adjustments_font,
                anchor=tk.W,
                bg=self.theme['frame_bg'],
                fg=self.theme['fg'],
                selectcolor=self.theme['frame_bg']
            )
            self.windows_adjustments_checkbox.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.widgets.append(('checkbutton', self.windows_adjustments_checkbox))
            self.widget_fonts[self.windows_adjustments_checkbox] = windows_adjustments_font

            # Add admin indicator
            windows_adjustments_indicator = tk.Label(
                windows_adjustments_frame,
                text="A",
                font=('Arial', 8, 'bold'),
                bg=self.theme['frame_bg'],
                fg=self.theme['admin_indicator']
            )
            windows_adjustments_indicator.pack(side=tk.RIGHT, padx=(5, 0))

            # Add tooltip
            Tooltip(self.windows_adjustments_checkbox,
                    "Disables Focus Assist, transparency effects, and Game Bar for better performance", self.theme)
            Tooltip(windows_adjustments_indicator, "Requires Administrator privileges", self.theme)

            flush_dns_font = ('Arial', 8)
            flush_dns_frame = tk.Frame(self.additional_checkbox_frame, bg=self.theme['frame_bg'])
            flush_dns_frame.pack(fill=tk.X, pady=1)

            self.flush_dns_checkbox = tk.Checkbutton(
                flush_dns_frame,
                text="Flush DNS and Renew IP",
                variable=self.flush_dns,
                font=flush_dns_font,
                anchor=tk.W,
                bg=self.theme['frame_bg'],
                fg=self.theme['fg'],
                selectcolor=self.theme['frame_bg']
            )
            self.flush_dns_checkbox.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.widgets.append(('checkbutton', self.flush_dns_checkbox))
            self.widget_fonts[self.flush_dns_checkbox] = flush_dns_font

            # Add user indicator
            flush_dns_indicator = tk.Label(
                flush_dns_frame,
                text="U",
                font=('Arial', 8, 'bold'),
                bg=self.theme['frame_bg'],
                fg=self.theme['user_indicator']
            )
            flush_dns_indicator.pack(side=tk.RIGHT, padx=(5, 0))

            # Add tooltip
            Tooltip(self.flush_dns_checkbox, "Flushes DNS cache and renews IP address to resolve network issues",
                    self.theme)
            Tooltip(flush_dns_indicator, "Can be run as standard user", self.theme)

            ipconfig_all_font = ('Arial', 8)
            ipconfig_all_frame = tk.Frame(self.additional_checkbox_frame, bg=self.theme['frame_bg'])
            ipconfig_all_frame.pack(fill=tk.X, pady=1)

            self.ipconfig_all_checkbox = tk.Checkbutton(
                ipconfig_all_frame,
                text="Display IP Configuration",
                variable=self.ipconfig_all,
                font=ipconfig_all_font,
                anchor=tk.W,
                bg=self.theme['frame_bg'],
                fg=self.theme['fg'],
                selectcolor=self.theme['frame_bg']
            )
            self.ipconfig_all_checkbox.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.widgets.append(('checkbutton', self.ipconfig_all_checkbox))
            self.widget_fonts[self.ipconfig_all_checkbox] = ipconfig_all_font

            # Add user indicator
            ipconfig_all_indicator = tk.Label(
                ipconfig_all_frame,
                text="U",
                font=('Arial', 8, 'bold'),
                bg=self.theme['frame_bg'],
                fg=self.theme['user_indicator']
            )
            ipconfig_all_indicator.pack(side=tk.RIGHT, padx=(5, 0))

            # Add tooltip
            Tooltip(self.ipconfig_all_checkbox, "Displays detailed network configuration information", self.theme)
            Tooltip(ipconfig_all_indicator, "Can be run as standard user", self.theme)

            change_dns_font = ('Arial', 8)
            change_dns_frame = tk.Frame(self.additional_checkbox_frame, bg=self.theme['frame_bg'])
            change_dns_frame.pack(fill=tk.X, pady=1)

            self.change_dns_checkbox = tk.Checkbutton(
                change_dns_frame,
                text="Change DNS to 1.1.1.1 and 8.8.8.8",
                variable=self.change_dns,
                font=change_dns_font,
                anchor=tk.W,
                bg=self.theme['frame_bg'],
                fg=self.theme['fg'],
                selectcolor=self.theme['frame_bg']
            )
            self.change_dns_checkbox.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.widgets.append(('checkbutton', self.change_dns_checkbox))
            self.widget_fonts[self.change_dns_checkbox] = change_dns_font

            # Add admin indicator
            change_dns_indicator = tk.Label(
                change_dns_frame,
                text="A",
                font=('Arial', 8, 'bold'),
                bg=self.theme['frame_bg'],
                fg=self.theme['admin_indicator']
            )
            change_dns_indicator.pack(side=tk.RIGHT, padx=(5, 0))

            # Add tooltip
            Tooltip(self.change_dns_checkbox, "Changes DNS servers to Cloudflare (1.1.1.1) and Google (8.8.8.8)",
                    self.theme)
            Tooltip(change_dns_indicator, "Requires Administrator privileges", self.theme)

            autopilot_csv_font = ('Arial', 8)
            autopilot_csv_frame = tk.Frame(self.additional_checkbox_frame, bg=self.theme['frame_bg'])
            autopilot_csv_frame.pack(fill=tk.X, pady=1)

            self.autopilot_csv_checkbox = tk.Checkbutton(
                autopilot_csv_frame,
                text="AutoPilot CSV Creation",
                variable=self.autopilot_csv,
                font=autopilot_csv_font,
                anchor=tk.W,
                bg=self.theme['frame_bg'],
                fg=self.theme['fg'],
                selectcolor=self.theme['frame_bg']
            )
            self.autopilot_csv_checkbox.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.widgets.append(('checkbutton', self.autopilot_csv_checkbox))
            self.widget_fonts[self.autopilot_csv_checkbox] = autopilot_csv_font

            # Add admin indicator
            autopilot_csv_indicator = tk.Label(
                autopilot_csv_frame,
                text="A",
                font=('Arial', 8, 'bold'),
                bg=self.theme['frame_bg'],
                fg=self.theme['admin_indicator']
            )
            autopilot_csv_indicator.pack(side=tk.RIGHT, padx=(5, 0))

            # Add tooltip
            Tooltip(self.autopilot_csv_checkbox, "Creates an AutoPilot CSV file for Windows deployment", self.theme)
            Tooltip(autopilot_csv_indicator, "Requires Administrator privileges", self.theme)

            # Note about system repair (moved to additional tasks section) - with smaller font
            note_font = ('Arial', 7)
            self.note_label = tk.Label(
                self.additional_task_frame,
                text="Note: System repair may take 30+ minutes. CHKDSK, Windows Updates and Firmware require reboot.",
                font=note_font,
                fg=self.theme['admin_error_fg'],
                bg=self.theme['frame_bg']
            )
            self.note_label.pack(anchor=tk.W, padx=10, pady=(0, 5))  # Reduced from 15,10 to 10,5
            self.widgets.append(('label', self.note_label))
            self.widget_fonts[self.note_label] = note_font

            # App settings checkboxes (left column) - with smaller font and padding
            stop_background_apps_font = ('Arial', 8)
            stop_background_apps_frame = tk.Frame(self.app_checkbox_frame, bg=self.theme['frame_bg'])
            stop_background_apps_frame.pack(fill=tk.X, pady=1)

            self.stop_background_apps_checkbox = tk.Checkbutton(
                stop_background_apps_frame,
                text="Stop Background Apps",
                variable=self.stop_background_apps_var,
                font=stop_background_apps_font,
                anchor=tk.W,
                bg=self.theme['frame_bg'],
                fg=self.theme['fg'],
                selectcolor=self.theme['frame_bg']
            )
            self.stop_background_apps_checkbox.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.widgets.append(('checkbutton', self.stop_background_apps_checkbox))
            self.widget_fonts[self.stop_background_apps_checkbox] = stop_background_apps_font

            # Add user indicator
            stop_background_apps_indicator = tk.Label(
                stop_background_apps_frame,
                text="U",
                font=('Arial', 8, 'bold'),
                bg=self.theme['frame_bg'],
                fg=self.theme['user_indicator']
            )
            stop_background_apps_indicator.pack(side=tk.RIGHT, padx=(5, 0))

            # Add tooltip
            Tooltip(self.stop_background_apps_checkbox,
                    "Disables background applications from running to save resources", self.theme)
            Tooltip(stop_background_apps_indicator, "Can be run as standard user", self.theme)

            disable_startup_apps_font = ('Arial', 8)
            disable_startup_apps_frame = tk.Frame(self.app_checkbox_frame, bg=self.theme['frame_bg'])
            disable_startup_apps_frame.pack(fill=tk.X, pady=1)

            self.disable_startup_apps_checkbox = tk.Checkbutton(
                disable_startup_apps_frame,
                text="Disable Startup Apps (Except OneDrive)",
                variable=self.disable_startup_apps_var,
                font=disable_startup_apps_font,
                anchor=tk.W,
                bg=self.theme['frame_bg'],
                fg=self.theme['fg'],
                selectcolor=self.theme['frame_bg']
            )
            self.disable_startup_apps_checkbox.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.widgets.append(('checkbutton', self.disable_startup_apps_checkbox))
            self.widget_fonts[self.disable_startup_apps_checkbox] = disable_startup_apps_font

            # Add user indicator
            disable_startup_apps_indicator = tk.Label(
                disable_startup_apps_frame,
                text="U",
                font=('Arial', 8, 'bold'),
                bg=self.theme['frame_bg'],
                fg=self.theme['user_indicator']
            )
            disable_startup_apps_indicator.pack(side=tk.RIGHT, padx=(5, 0))

            # Add tooltip
            Tooltip(self.disable_startup_apps_checkbox,
                    "Disables startup applications except OneDrive to improve boot time", self.theme)
            Tooltip(disable_startup_apps_indicator, "Can be run as standard user", self.theme)

            update_apps_font = ('Arial', 8)
            update_apps_frame = tk.Frame(self.app_checkbox_frame, bg=self.theme['frame_bg'])
            update_apps_frame.pack(fill=tk.X, pady=1)

            self.update_apps_checkbox = tk.Checkbutton(
                update_apps_frame,
                text="Update Apps (Winget)",
                variable=self.update_apps,
                font=update_apps_font,
                anchor=tk.W,
                bg=self.theme['frame_bg'],
                fg=self.theme['fg'],
                selectcolor=self.theme['frame_bg']
            )
            self.update_apps_checkbox.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.widgets.append(('checkbutton', self.update_apps_checkbox))
            self.widget_fonts[self.update_apps_checkbox] = update_apps_font

            # Add admin indicator
            update_apps_indicator = tk.Label(
                update_apps_frame,
                text="A",
                font=('Arial', 8, 'bold'),
                bg=self.theme['frame_bg'],
                fg=self.theme['admin_indicator']
            )
            update_apps_indicator.pack(side=tk.RIGHT, padx=(5, 0))

            # Add tooltip
            Tooltip(self.update_apps_checkbox, "Updates installed applications using Windows Package Manager (winget)",
                    self.theme)
            Tooltip(update_apps_indicator, "Requires Administrator privileges", self.theme)

            # Action buttons frame
            button_frame = tk.Frame(self.main_container, bg=self.theme['bg'])
            button_frame.pack(fill=tk.X, pady=(0, 10))  # Reduced from 20 to 10
            self.widgets.append(('frame', button_frame))

            run_button_font = ('Arial', 10, 'bold')
            self.run_button = tk.Button(
                button_frame,
                text="RUN SELECTED TASKS",
                font=run_button_font,
                command=self.run_selected_tasks,
                bg=self.theme['button_bg'],
                fg=self.theme['button_fg'],
                padx=15,  # Reduced from 20 to 15
                pady=8  # Reduced from 10 to 8
            )
            self.run_button.pack(side=tk.LEFT, padx=(0, 10))
            self.widgets.append(('button', self.run_button))
            self.widget_fonts[self.run_button] = run_button_font

            exit_button_font = ('Arial', 10)
            self.exit_button = tk.Button(
                button_frame,
                text="EXIT",
                font=exit_button_font,
                command=self.root.quit,
                bg=self.theme['button_bg'],
                fg=self.theme['button_fg'],
                padx=15,  # Reduced from 20 to 15
                pady=8  # Reduced from 10 to 8
            )
            self.exit_button.pack(side=tk.LEFT)
            self.widgets.append(('button', self.exit_button))
            self.widget_fonts[self.exit_button] = exit_button_font

            # Progress section (initially hidden)
            self.progress_section = tk.Frame(self.main_container, bg=self.theme['bg'])
            self.widgets.append(('frame', self.progress_section))

            # Current task label
            current_task_font = ('Arial', 9, 'bold')
            self.current_task_label = tk.Label(
                self.progress_section,
                text="Current Task: None",
                font=current_task_font,
                bg=self.theme['bg'],
                fg=self.theme['fg']
            )
            self.current_task_label.pack(anchor=tk.W, padx=10)
            self.widgets.append(('label', self.current_task_label))
            self.widget_fonts[self.current_task_label] = current_task_font

            # Progress bar frame
            progress_bar_frame = tk.Frame(self.progress_section, bg=self.theme['bg'])
            progress_bar_frame.pack(fill=tk.X, padx=10, pady=2)  # Reduced from 5 to 2
            self.widgets.append(('frame', progress_bar_frame))

            # Progress bar (green, animated)
            self.progress_bar = ttk.Progressbar(
                progress_bar_frame,
                orient=tk.HORIZONTAL,
                length=300,  # Reduced from 400 to 300
                mode='indeterminate'
            )
            self.progress_bar.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.widgets.append(('progress', self.progress_bar))

            # Progress percentage label
            progress_percent_font = ('Arial', 9)
            self.progress_percent_label = tk.Label(
                progress_bar_frame,
                text="",
                font=progress_percent_font,
                bg=self.theme['bg'],
                fg=self.theme['fg']
            )
            self.progress_percent_label.pack(side=tk.LEFT, padx=(10, 0))
            self.widgets.append(('label', self.progress_percent_label))
            self.widget_fonts[self.progress_percent_label] = progress_percent_font

            # Time remaining label
            time_remaining_font = ('Arial', 9)
            self.time_remaining_label = tk.Label(
                self.progress_section,
                text="",
                font=time_remaining_font,
                bg=self.theme['bg'],
                fg=self.theme['fg']
            )
            self.time_remaining_label.pack(anchor=tk.W, padx=10)
            self.widgets.append(('label', self.time_remaining_label))
            self.widget_fonts[self.time_remaining_label] = time_remaining_font

            # Unified log area (merged Task Progress and Activity Log)
            self.log_container = tk.Frame(self.main_container, bg=self.theme['bg'])
            self.log_container.pack(fill=tk.BOTH, expand=True, pady=(0, 5))  # Reduced from 10 to 5
            self.widgets.append(('frame', self.log_container))

            log_label_font = ('Arial', 10, 'bold')
            self.log_label = tk.Label(
                self.log_container,
                text="ACTIVITY LOG",
                font=log_label_font,
                bg=self.theme['bg'],
                fg=self.theme['fg']
            )
            self.log_label.pack(anchor=tk.W, pady=(0, 2))  # Reduced from 5 to 2
            self.widgets.append(('label', self.log_label))
            self.widget_fonts[self.log_label] = log_label_font

            # Create a frame for the text and scrollbar
            self.log_frame = tk.Frame(self.log_container, bd=2, relief=tk.SUNKEN, bg=self.theme['bg'])
            self.log_frame.pack(fill=tk.BOTH, expand=True)
            self.widgets.append(('frame', self.log_frame))

            # Create the text widget with larger height and green text
            log_area_font = ('Courier', 8)
            self.log_area = tk.Text(
                self.log_frame,
                wrap=tk.WORD,
                font=log_area_font,
                height=30,  # Increased height for larger log area
                padx=5,
                pady=5,
                bg=self.theme['text_bg'],
                fg=self.theme['log_text_fg']  # Green text color
            )
            self.log_area.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            self.widgets.append(('log', self.log_area))  # Register as 'log' type
            self.widget_fonts[self.log_area] = log_area_font

            # Create the scrollbar
            self.log_scrollbar = ttk.Scrollbar(
                self.log_frame,
                orient=tk.VERTICAL,
                command=self.log_area.yview
            )
            self.log_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

            # Configure the text widget to use the scrollbar
            self.log_area.config(yscrollcommand=self.log_scrollbar.set)

            # Configure progress bar style to green
            self.style = ttk.Style()
            self.style.configure("green.Horizontal.TProgressbar", background=self.theme['progress_bg'])
            self.progress_bar.config(style="green.Horizontal.TProgressbar")

            # Apply the current font size factor to all widgets
            self.update_all_fonts()

        except Exception as e:
            raise

    def is_admin(self):
        try:
            result = ctypes.windll.shell32.IsUserAnAdmin()
            return result
        except Exception as e:
            return False

    def update_admin_status(self):
        if self.admin_status:
            self.admin_label.config(
                text="[+] Admin privileges OK",
                fg=self.theme['admin_fg']
            )
        else:
            self.admin_label.config(
                text="[-] Admin privileges required",
                fg=self.theme['admin_error_fg']
            )

    def log_message(self, message, task_name=None):
        try:
            # Add timestamp
            timestamp = time.strftime("[%H:%M:%S]")
            # Basic sanitization to prevent log injection
            safe_message = re.sub(r'[\x00-\x1f\x7f-\x9f]', '', str(message))

            # Format message based on task context
            if task_name:
                # Indent task-related messages
                formatted_message = f"{timestamp} [{task_name}] {safe_message}"
            else:
                formatted_message = f"{timestamp} {safe_message}"

            # Add color tags for admin status messages
            if "Admin privileges OK" in safe_message:
                formatted_message = f"<span style='color:{self.theme['admin_fg']}'>{formatted_message}</span>"

            self.log_area.insert(tk.END, f"{formatted_message}\n")
            self.log_area.see(tk.END)
            self.root.update_idletasks()
        except Exception as e:
            pass  # Silently ignore logging errors

    def show_progress(self, show=True):
        """Show or hide the progress section"""
        if show and not self.progress_active:
            self.progress_section.pack(fill=tk.X, pady=(0, 10))
            self.progress_bar.start(10)
            self.progress_active = True
        elif not show and self.progress_active:
            self.progress_bar.stop()
            self.progress_section.pack_forget()
            self.progress_active = False

    def update_progress_info(self, task_name=None, info=None):
        """Update progress information"""
        if task_name:
            self.current_task_label.config(text=f"Current Task: {task_name}")
        if info:
            self.progress_percent_label.config(text=info)

    def run_selected_tasks(self):
        # Disable button during operation
        self.run_button.config(state=tk.DISABLED)

        # Get selected tasks
        tasks = []
        if self.clean_temp.get():
            tasks.append("clean_temp")
        if self.disk_cleanup.get():
            tasks.append("disk_cleanup")
        if self.disable_fast_startup.get():
            tasks.append("disable_fast_startup")
        if self.update_apps.get():
            tasks.append("update_apps")
        if self.windows_updates.get():
            tasks.append("windows_updates")
        if self.device_firmware.get():
            tasks.append("device_firmware")
        if self.repair_system.get():
            tasks.append("repair_system")
        if self.chk_dsk.get():
            tasks.append("chk_dsk")
        if self.windows_adjustments.get():
            tasks.append("windows_adjustments")
        if self.flush_dns.get():
            tasks.append("flush_dns")
        if self.ipconfig_all.get():
            tasks.append("ipconfig_all")
        if self.change_dns.get():
            tasks.append("change_dns")
        if self.autopilot_csv.get():
            tasks.append("autopilot_csv")
        if self.pc_report.get():  # New PC Report task
            tasks.append("pc_report")
        if self.chris_titus_utility.get():  # New Chris Titus Utility task
            tasks.append("chris_titus_utility")
        if self.stop_background_apps_var.get():
            tasks.append("stop_background_apps")
        if self.disable_startup_apps_var.get():
            tasks.append("disable_startup_apps")

        if not tasks:
            self.log_message("No tasks selected!")
            self.run_button.config(state=tk.NORMAL)
            return

        # Show progress bar
        self.show_progress(True)

        # Start worker thread
        self.log_message("Starting selected tasks...")
        threading.Thread(target=self.execute_tasks, args=(tasks,), daemon=True).start()

        # Start queue processing
        self.root.after(100, self.process_queue)

    def execute_tasks(self, tasks):
        if not self.admin_status:
            self.queue.put("ERROR: Administrator privileges required!")
            self.queue.put("Please restart the application as administrator.")
            self.queue.put("TASKS_FAILED")
            return

        for task in tasks:
            try:
                # Map task names to display names
                task_display_names = {
                    "clean_temp": "Clean Temp Files",
                    "disk_cleanup": "Disk Cleanup",
                    "disable_fast_startup": "Disable Fast Startup",
                    "update_apps": "Update Apps",
                    "windows_updates": "Windows Updates",
                    "device_firmware": "Device Firmware Updates",
                    "repair_system": "Repair System",
                    "chk_dsk": "Check Disk",
                    "windows_adjustments": "Windows Adjustments",
                    "flush_dns": "Flush DNS and Renew IP",
                    "ipconfig_all": "Display IP Configuration",
                    "change_dns": "Change DNS to 1.1.1.1 and 8.8.8.8",
                    "autopilot_csv": "AutoPilot CSV Creation",
                    "pc_report": "PC Report",
                    "chris_titus_utility": "Chris Titus Windows Utility",
                    "stop_background_apps": "Stop Background Apps",
                    "disable_startup_apps": "Disable Startup Apps"
                }

                display_name = task_display_names.get(task, task)
                self.queue.put(f"TASK_START:{task}:{display_name}")

                if task == "clean_temp":
                    self.clean_temp_files()
                elif task == "disk_cleanup":
                    self.run_disk_cleanup()
                elif task == "disable_fast_startup":
                    self.perform_disable_fast_startup()
                elif task == "update_apps":
                    self.update_installed_apps()
                elif task == "windows_updates":
                    self.check_and_install_windows_updates()
                elif task == "device_firmware":
                    self.check_and_install_device_firmware()
                elif task == "repair_system":
                    self.repair_system_files()
                elif task == "chk_dsk":
                    self.run_chk_dsk()
                elif task == "windows_adjustments":
                    self.perform_windows_adjustments()
                elif task == "flush_dns":
                    self.flush_dns_and_renew_ip()
                elif task == "ipconfig_all":
                    self.display_ip_config()
                elif task == "change_dns":
                    self.change_dns_servers()
                elif task == "autopilot_csv":
                    self.create_autopilot_csv()
                elif task == "pc_report":  # New PC Report task
                    self.generate_pc_report()
                elif task == "chris_titus_utility":  # New Chris Titus Utility task
                    self.run_chris_titus_utility()
                elif task == "stop_background_apps":
                    self.stop_background_apps()
                elif task == "disable_startup_apps":
                    self.disable_startup_apps()

                self.queue.put(f"TASK_END:{task}")
            except Exception as e:
                self.queue.put(f"Error in task {task}: {str(e)}")

        self.queue.put("All selected tasks completed!")
        self.queue.put("TASKS_COMPLETE")

    def process_queue(self):
        try:
            while True:
                msg = self.queue.get_nowait()

                # Handle task start
                if msg.startswith("TASK_START:"):
                    parts = msg.split(":", 2)
                    if len(parts) >= 3:
                        task_id = parts[1]
                        display_name = parts[2]
                        self.log_message(f"Starting task: {display_name}", display_name)
                        self.update_progress_info(display_name, "0%")

                # Handle task progress
                elif msg.startswith("PROGRESS:"):
                    parts = msg.split(":", 2)
                    if len(parts) >= 3:
                        task_name = parts[1]
                        progress_info = parts[2]

                        # Extract progress percentage if available
                        progress_match = re.search(r'(\d+)%', progress_info)
                        if progress_match:
                            progress = progress_match.group(1)
                            self.update_progress_info(task_name, f"{progress}%")

                        self.log_message(progress_info, task_name)

                # Handle task end
                elif msg.startswith("TASK_END:"):
                    task_id = msg.split(":", 1)[1]
                    # Find the display name for this task
                    task_display_names = {
                        "clean_temp": "Clean Temp Files",
                        "disk_cleanup": "Disk Cleanup",
                        "disable_fast_startup": "Disable Fast Startup",
                        "update_apps": "Update Apps",
                        "windows_updates": "Windows Updates",
                        "device_firmware": "Device Firmware Updates",
                        "repair_system": "Repair System",
                        "chk_dsk": "Check Disk",
                        "windows_adjustments": "Windows Adjustments",
                        "flush_dns": "Flush DNS and Renew IP",
                        "ipconfig_all": "Display IP Configuration",
                        "change_dns": "Change DNS to 1.1.1.1 and 8.8.8.8",
                        "autopilot_csv": "AutoPilot CSV Creation",
                        "pc_report": "PC Report",
                        "chris_titus_utility": "Chris Titus Windows Utility",
                        "stop_background_apps": "Stop Background Apps",
                        "disable_startup_apps": "Disable Startup Apps"
                    }

                    display_name = task_display_names.get(task_id, task_id)
                    self.log_message(f"Task completed: {display_name}", display_name)
                    self.update_progress_info(display_name, "100%")

                # Handle regular messages
                else:
                    self.log_message(msg)

                # Handle task completion
                if msg == "TASKS_COMPLETE":
                    self.run_button.config(state=tk.NORMAL)
                    self.show_progress(False)
                    self.update_progress_info("None", "")
                    self.log_message("Tasks finished successfully!")
                elif msg == "TASKS_FAILED":
                    self.run_button.config(state=tk.NORMAL)
                    self.show_progress(False)
                    self.update_progress_info("None", "")
        except queue.Empty:
            self.root.after(100, self.process_queue)

    # ==================== CHRIS TITUS UTILITY METHODS ====================
    def run_chris_titus_utility(self):
        """Run Chris Titus Windows Utility using PowerShell script"""
        self.queue.put("PROGRESS:Chris Titus Utility:Starting Chris Titus Windows Utility...")
        self.queue.put("PROGRESS:Chris Titus Utility:This will download and run the utility from christitus.com")

        try:
            # PowerShell command to run the Chris Titus Windows Utility
            ps_command = "irm christitus.com/win | iex"

            self.queue.put("PROGRESS:Chris Titus Utility:Executing PowerShell command...")
            self.queue.put(f"PROGRESS:Chris Titus Utility:Command: {ps_command}")

            # Run PowerShell command
            result = subprocess.run(
                ['powershell', '-Command', ps_command],
                capture_output=True,
                text=True,
                check=False,
                timeout=600,  # 10 minute timeout
                creationflags=CREATE_NO_WINDOW  # Hide console window
            )

            # Log output
            if result.stdout.strip():
                self.queue.put("PROGRESS:Chris Titus Utility:Output:")
                for line in result.stdout.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:Chris Titus Utility:  {line.strip()}")

            if result.stderr.strip():
                self.queue.put("PROGRESS:Chris Titus Utility:Errors:")
                for line in result.stderr.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:Chris Titus Utility:  {line.strip()}")

            # Check return code
            if result.returncode == 0:
                self.queue.put("PROGRESS:Chris Titus Utility:Chris Titus Windows Utility completed successfully")
            else:
                self.queue.put(f"PROGRESS:Chris Titus Utility:Completed with return code: {result.returncode}")

        except subprocess.TimeoutExpired:
            self.queue.put("PROGRESS:Chris Titus Utility:Operation timed out after 10 minutes")
        except Exception as e:
            self.queue.put(f"PROGRESS:Chris Titus Utility:Error running Chris Titus Utility: {str(e)}")

    # ==================== PC REPORT METHODS ====================
    def generate_pc_report(self):
        """Generate a comprehensive PC report using the new PCReporter class"""
        self.queue.put("PROGRESS:PC Report:Starting comprehensive PC report generation...")
        self.queue.put("PROGRESS:PC Report:This may take several minutes. Please be patient.")

        try:
            # Create a PCReporter instance
            reporter = PCReporter()

            # Collect all system information
            self.queue.put("PROGRESS:PC Report:Collecting system information...")
            reporter.collect_system_info()

            self.queue.put("PROGRESS:PC Report:Collecting hardware information...")
            reporter.collect_hardware_info()

            self.queue.put("PROGRESS:PC Report:Collecting software information...")
            reporter.collect_software_info()

            self.queue.put("PROGRESS:PC Report:Collecting network information...")
            reporter.collect_network_info()

            self.queue.put("PROGRESS:PC Report:Collecting security information...")
            reporter.collect_security_info()

            self.queue.put("PROGRESS:PC Report:Collecting user information...")
            reporter.collect_user_info()

            self.queue.put("PROGRESS:PC Report:Collecting environment variables...")
            reporter.collect_environment_info()

            self.queue.put("PROGRESS:PC Report:Collecting running processes...")
            reporter.collect_process_info()

            self.queue.put("PROGRESS:PC Report:Collecting system services...")
            reporter.collect_service_info()

            self.queue.put("PROGRESS:PC Report:Collecting hardware devices...")
            reporter.collect_device_info()

            self.queue.put("PROGRESS:PC Report:Collecting performance metrics...")
            reporter.collect_performance_metrics()

            self.queue.put("PROGRESS:PC Report:Checking for security vulnerabilities...")
            reporter.collect_vulnerability_info()

            self.queue.put("PROGRESS:PC Report:Collecting startup items information...")
            reporter.collect_startup_info()

            # Generate HTML report
            self.queue.put("PROGRESS:PC Report:Generating HTML report...")
            report_file = reporter.generate_html_report()

            # Get the full path to the report
            report_path = os.path.abspath(report_file)

            self.queue.put(f"PROGRESS:PC Report:Report saved to: {report_path}")

            # Open the report in the default browser
            self.queue.put("PROGRESS:PC Report:Opening report in default browser...")
            webbrowser.open(f"file:///{report_path}")

            self.queue.put("PROGRESS:PC Report:PC Report generation completed successfully!")

        except Exception as e:
            self.queue.put(f"PROGRESS:PC Report:Error generating PC Report: {str(e)}")
            import traceback
            self.queue.put(f"PROGRESS:PC Report:Traceback: {traceback.format_exc()}")

    # ==================== SYSTEM TASKS METHODS ====================

    def clean_temp_files(self):
        """Clean temporary files from system directories"""
        self.queue.put("PROGRESS:Clean Temp Files:Starting temporary files cleanup...")
        self.queue.put("PROGRESS:Clean Temp Files:Checking temporary directories...")

        try:
            temp_paths = [
                os.environ.get('TEMP', 'C:\\Temp'),
                os.path.join(os.environ.get('SystemRoot', 'C:\\Windows'), 'Temp'),
                os.path.join(os.environ.get('SystemRoot', 'C:\\Windows'), 'Prefetch')
            ]

            for i, path in enumerate(temp_paths):
                try:
                    # Sanitize path
                    safe_path = SecurityUtils.sanitize_path(path)
                    self.queue.put(
                        f"PROGRESS:Clean Temp Files:Processing directory {i + 1}/{len(temp_paths)}: {safe_path}")

                    # Check if path exists
                    if not os.path.exists(safe_path):
                        self.queue.put(f"PROGRESS:Clean Temp Files:Path does not exist: {safe_path}")
                        continue

                    # Count files before deletion
                    try:
                        file_count = len(os.listdir(safe_path))
                        self.queue.put(f"PROGRESS:Clean Temp Files:Found {file_count} items in {safe_path}")
                    except:
                        self.queue.put(f"PROGRESS:Clean Temp Files:Unable to count items in {safe_path}")

                    # Use PowerShell to clean files with detailed output
                    ps_command = f'''
                    $ErrorActionPreference = 'SilentlyContinue'
                    $path = "{safe_path}"
                    $deletedCount = 0
                    $failedCount = 0

                    if (Test-Path $path) {{
                        Get-ChildItem -Path $path -Force | ForEach-Object {{
                            try {{
                                Remove-Item -Path $_.FullName -Recurse -Force -ErrorAction Stop
                                $deletedCount++
                                Write-Host "Deleted: $($_.Name)"
                            }} catch {{
                                $failedCount++
                                Write-Host "Could not delete: $($_.Name) - $($_.Exception.Message)"
                            }}
                        }}
                    }}

                    Write-Host "Summary: Deleted $deletedCount items, Failed: $failedCount items"
                    '''

                    # Run PowerShell command
                    self.queue.put(f"PROGRESS:Clean Temp Files:Executing PowerShell cleanup command...")
                    result = subprocess.run(
                        ['powershell', '-Command', ps_command],
                        capture_output=True,
                        text=True,
                        check=False,
                        timeout=300,  # 5 minute timeout
                        creationflags=CREATE_NO_WINDOW  # Hide console window
                    )

                    # Log output
                    if result.stdout.strip():
                        for line in result.stdout.strip().split('\n'):
                            if line.strip():
                                self.queue.put(f"PROGRESS:Clean Temp Files:{line.strip()}")

                    if result.stderr.strip():
                        self.queue.put(f"PROGRESS:Clean Temp Files:Errors: {result.stderr.strip()}")

                except ValueError as e:
                    self.queue.put(f"PROGRESS:Clean Temp Files:Invalid path rejected: {path}")
                except subprocess.TimeoutExpired:
                    self.queue.put(f"PROGRESS:Clean Temp Files:Timeout cleaning: {path}")
                except Exception as e:
                    self.queue.put(f"PROGRESS:Clean Temp Files:Error cleaning {path}: {str(e)}")

            self.queue.put("PROGRESS:Clean Temp Files:Temporary files cleanup completed")

        except Exception as e:
            self.queue.put(f"PROGRESS:Clean Temp Files:Error in clean temp files: {str(e)}")

    def run_disk_cleanup(self):
        """Run Windows disk cleanup with all options enabled"""
        self.queue.put("PROGRESS:Disk Cleanup:Starting disk cleanup with all options...")
        self.queue.put("PROGRESS:Disk Cleanup:This process may take several minutes. Please be patient.")

        try:
            # Safe registry manipulation with validation
            registry_key_path = r"SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\VolumeCaches"

            # Validate registry path
            SecurityUtils.validate_registry_key(registry_key_path)

            try:
                # Open the key
                self.queue.put("PROGRESS:Disk Cleanup:Accessing Windows registry...")
                key = winreg.OpenKey(
                    winreg.HKEY_LOCAL_MACHINE,
                    registry_key_path,
                    0,
                    winreg.KEY_READ
                )

                # Get all subkeys (cleanup items)
                subkey_count = winreg.QueryInfoKey(key)[0]
                cleanup_items = []

                for i in range(subkey_count):
                    subkey_name = winreg.EnumKey(key, i)
                    cleanup_items.append(subkey_name)

                winreg.CloseKey(key)
                self.queue.put(f"PROGRESS:Disk Cleanup:Found {len(cleanup_items)} cleanup items")

                # Set StateFlags value for each item to 2 (selected for profile 1)
                for i, item in enumerate(cleanup_items):
                    try:
                        self.queue.put(f"PROGRESS:Disk Cleanup:Configuring item {i + 1}/{len(cleanup_items)}: {item}")
                        item_key_path = f"{registry_key_path}\\{item}"
                        # Validate each subkey path
                        SecurityUtils.validate_registry_key(item_key_path)

                        item_key = winreg.OpenKey(
                            winreg.HKEY_LOCAL_MACHINE,
                            item_key_path,
                            0,
                            winreg.KEY_WRITE
                        )

                        # Set StateFlags to 2 (selected for profile 1)
                        winreg.SetValueEx(item_key, "StateFlags", 0, winreg.REG_DWORD, 2)
                        winreg.CloseKey(item_key)
                        self.queue.put(f"PROGRESS:Disk Cleanup:Enabled: {item}")
                    except Exception as e:
                        self.queue.put(f"PROGRESS:Disk Cleanup:Error enabling {item}: {str(e)}")

                self.queue.put("PROGRESS:Disk Cleanup:All cleanup options enabled")

                # Run disk cleanup safely
                try:
                    self.queue.put("PROGRESS:Disk Cleanup:Executing: cleanmgr /sagerun:1")
                    self.queue.put("PROGRESS:Disk Cleanup:Starting disk cleanup process...")

                    result = subprocess.run(
                        ['cleanmgr', '/sagerun:1'],
                        capture_output=True,
                        text=True,
                        check=False,
                        timeout=1800,  # 30 minute timeout
                        creationflags=CREATE_NO_WINDOW  # Hide console window
                    )

                    if result.returncode == 0:
                        self.queue.put("PROGRESS:Disk Cleanup:Disk cleanup completed successfully")
                    else:
                        self.queue.put(
                            f"PROGRESS:Disk Cleanup:Disk cleanup completed with return code: {result.returncode}")

                    if result.stdout.strip():
                        self.queue.put(f"PROGRESS:Disk Cleanup:Output: {result.stdout.strip()}")
                    if result.stderr.strip():
                        self.queue.put(f"PROGRESS:Disk Cleanup:Errors: {result.stderr.strip()}")

                except subprocess.TimeoutExpired:
                    self.queue.put("PROGRESS:Disk Cleanup:Disk cleanup timed out after 30 minutes")
                except Exception as e:
                    self.queue.put(f"PROGRESS:Disk Cleanup:Error running disk cleanup: {str(e)}")

            except Exception as e:
                self.queue.put(f"PROGRESS:Disk Cleanup:Error configuring registry: {str(e)}")

        except Exception as e:
            self.queue.put(f"PROGRESS:Disk Cleanup:Error in disk cleanup: {str(e)}")

    def perform_disable_fast_startup(self):
        """Disable Windows fast startup feature"""
        self.queue.put("PROGRESS:Disable Fast Startup:Starting fast startup disable process...")
        try:
            # Step 1: Disable hibernation safely
            self.queue.put("PROGRESS:Disable Fast Startup:Step 1: Disabling hibernation...")
            try:
                self.queue.put("PROGRESS:Disable Fast Startup:Executing: powercfg /h off")
                result = subprocess.run(
                    ['powercfg', '/h', 'off'],
                    capture_output=True,
                    text=True,
                    check=True,
                    timeout=30,
                    creationflags=CREATE_NO_WINDOW  # Hide console window
                )
                self.queue.put("PROGRESS:Disable Fast Startup:Hibernation disabled successfully")
                if result.stdout.strip():
                    self.queue.put(f"PROGRESS:Disable Fast Startup:Output: {result.stdout.strip()}")
            except subprocess.CalledProcessError as e:
                self.queue.put(f"PROGRESS:Disable Fast Startup:Powercfg error: {str(e)}")
                return
            except subprocess.TimeoutExpired:
                self.queue.put("PROGRESS:Disable Fast Startup:Powercfg command timed out")
                return

            # Step 2: Update registry safely
            self.queue.put("PROGRESS:Disable Fast Startup:Step 2: Updating registry settings...")
            registry_key_path = r"SYSTEM\CurrentControlSet\Control\Session Manager\Power"
            registry_value = "HiberbootEnabled"

            try:
                # Validate registry path
                SecurityUtils.validate_registry_key(registry_key_path)

                # Open the key with write access
                self.queue.put("PROGRESS:Disable Fast Startup:Opening registry key for write access...")
                key = winreg.OpenKey(
                    winreg.HKEY_LOCAL_MACHINE,
                    registry_key_path,
                    0,
                    winreg.KEY_WRITE
                )

                # Set the value to 0 (disable Fast Startup)
                self.queue.put("PROGRESS:Disable Fast Startup:Setting HiberbootEnabled to 0...")
                winreg.SetValueEx(key, registry_value, 0, winreg.REG_DWORD, 0)
                winreg.CloseKey(key)
                self.queue.put("PROGRESS:Disable Fast Startup:Registry updated successfully")
            except WindowsError as e:
                if e.errno == 2:  # Key not found
                    try:
                        # Create the key
                        self.queue.put("PROGRESS:Disable Fast Startup:Registry key not found, creating it...")
                        key = winreg.CreateKey(
                            winreg.HKEY_LOCAL_MACHINE,
                            registry_key_path
                        )
                        # Set the value
                        self.queue.put("PROGRESS:Disable Fast Startup:Setting HiberbootEnabled to 0 in new key...")
                        winreg.SetValueEx(key, registry_value, 0, winreg.REG_DWORD, 0)
                        winreg.CloseKey(key)
                        self.queue.put("PROGRESS:Disable Fast Startup:Registry key created and updated")
                    except Exception as create_error:
                        self.queue.put(
                            f"PROGRESS:Disable Fast Startup:Error creating registry key: {str(create_error)}")
                else:
                    self.queue.put(f"PROGRESS:Disable Fast Startup:Registry error: {str(e)}")

            # Step 3: Verify changes
            self.queue.put("PROGRESS:Disable Fast Startup:Step 3: Verifying changes...")
            try:
                key = winreg.OpenKey(
                    winreg.HKEY_LOCAL_MACHINE,
                    registry_key_path,
                    0,
                    winreg.KEY_READ
                )
                value, _ = winreg.QueryValueEx(key, registry_value)
                winreg.CloseKey(key)

                if value == 0:
                    self.queue.put("PROGRESS:Disable Fast Startup:Fast startup disabled successfully")
                else:
                    self.queue.put(f"PROGRESS:Disable Fast Startup:Warning: Registry value is {value}, expected 0")
            except WindowsError as e:
                self.queue.put(f"PROGRESS:Disable Fast Startup:Could not verify registry: {str(e)}")

        except Exception as e:
            self.queue.put(f"PROGRESS:Disable Fast Startup:Error disabling fast startup: {str(e)}")

    def check_and_install_windows_updates(self):
        """Check for and install Windows updates with detailed progress"""
        self.queue.put("PROGRESS:Windows Updates:Starting Windows Update process...")
        self.queue.put("PROGRESS:Windows Updates:This process may take a long time. Please be patient.")

        try:
            # PowerShell script to check for and install Windows updates with detailed progress
            ps_script = '''
            try {
                # Create update session
                $updateSession = New-Object -ComObject Microsoft.Update.Session
                $updateSearcher = $updateSession.CreateUpdateSearcher()

                Write-Host "Phase: Searching for updates..."
                # Search for updates
                Write-Host "Searching for updates..."
                $searchResult = $updateSearcher.Search("IsInstalled=0")

                if ($searchResult.Updates.Count -eq 0) {
                    Write-Host "No updates found."
                    exit 0
                }

                Write-Host "Found $($searchResult.Updates.Count) updates:"
                foreach ($update in $searchResult.Updates) {
                    Write-Host "- $($update.Title)"
                }

                # Download updates
                $updatesToDownload = New-Object -ComObject Microsoft.Update.UpdateColl
                foreach ($update in $searchResult.Updates) {
                    if (-not $update.IsDownloaded) {
                        $updatesToDownload.Add($update) | Out-Null
                    }
                }

                if ($updatesToDownload.Count -gt 0) {
                    Write-Host "Phase: Downloading updates..."
                    Write-Host "Downloading $($updatesToDownload.Count) updates..."
                    $downloader = $updateSession.CreateUpdateDownloader()
                    $downloader.Updates = $updatesToDownload
                    $downloadResult = $downloader.Download()

                    if ($downloadResult.ResultCode -eq 2) {
                        Write-Host "Updates downloaded successfully."
                    } else {
                        Write-Host "Failed to download updates. Result code: $($downloadResult.ResultCode)"
                        exit 1
                    }
                } else {
                    Write-Host "All updates are already downloaded."
                }

                # Install updates
                $updatesToInstall = New-Object -ComObject Microsoft.Update.UpdateColl
                foreach ($update in $searchResult.Updates) {
                    if ($update.IsDownloaded) {
                        $updatesToInstall.Add($update) | Out-Null
                    }
                }

                if ($updatesToInstall.Count -gt 0) {
                    Write-Host "Phase: Installing updates..."
                    Write-Host "Installing $($updatesToInstall.Count) updates..."
                    $installer = $updateSession.CreateUpdateInstaller()
                    $installer.Updates = $updatesToInstall
                    $installResult = $installer.Install()

                    if ($installResult.ResultCode -eq 2) {
                        Write-Host "Updates installed successfully."

                        if ($installResult.RebootRequired) {
                            Write-Host "A system reboot is required to complete the installation."
                            exit 2
                        }
                    } else {
                        Write-Host "Failed to install updates. Result code: $($installResult.ResultCode)"
                        exit 1
                    }
                } else {
                    Write-Host "No updates to install."
                }

                exit 0
            }
            catch {
                Write-Error "Error checking/installing updates: $($_.Exception.Message)"
                exit 1
            }
            '''

            # Run PowerShell script
            self.queue.put("PROGRESS:Windows Updates:Executing PowerShell update script...")
            result = subprocess.run(
                ['powershell', '-Command', ps_script],
                capture_output=True,
                text=True,
                check=False,
                timeout=7200,  # 2 hour timeout (updates can take a long time)
                creationflags=CREATE_NO_WINDOW  # Hide console window
            )

            # Log output
            if result.stdout.strip():
                for line in result.stdout.strip().split('\n'):
                    line = line.strip()
                    if line:
                        if line.startswith("Phase:"):
                            phase = line.replace("Phase:", "").strip()
                            self.queue.put(f"PROGRESS:Windows Updates:{phase}...")
                        elif line.startswith("Found") or line.startswith("Downloading") or line.startswith(
                                "Installing"):
                            self.queue.put(f"PROGRESS:Windows Updates:{line}")
                        elif line.startswith("- "):
                            self.queue.put(f"PROGRESS:Windows Updates:Update: {line[2:]}")
                        else:
                            self.queue.put(f"PROGRESS:Windows Updates:{line}")

            if result.stderr.strip():
                self.queue.put("PROGRESS:Windows Updates:Errors:")
                for line in result.stderr.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:Windows Updates:  {line.strip()}")

            # Check return code
            if result.returncode == 0:
                self.queue.put("PROGRESS:Windows Updates:Windows updates completed successfully")
            elif result.returncode == 2:
                self.queue.put("PROGRESS:Windows Updates:Windows updates installed successfully")
                self.queue.put("PROGRESS:Windows Updates:A system reboot is required to complete the installation")
                self.queue.put("WINDOWS_UPDATES_REBOOT_REQUIRED")
                self.root.after(100, self.prompt_reboot_for_updates)
            else:
                self.queue.put(
                    f"PROGRESS:Windows Updates:Windows updates completed with return code: {result.returncode}")

        except subprocess.TimeoutExpired:
            self.queue.put("PROGRESS:Windows Updates:Windows updates process timed out after 2 hours")
        except Exception as e:
            self.queue.put(f"PROGRESS:Windows Updates:Error in Windows updates: {str(e)}")

    def check_and_install_device_firmware(self):
        """Check for and install device firmware updates"""
        self.queue.put("PROGRESS:Device Firmware:Starting device firmware update process...")
        self.queue.put("PROGRESS:Device Firmware:This process may take a long time. Please be patient.")

        # Initialize COM for this thread
        initialized = False
        try:
            try:
                pythoncom.CoInitialize()
                initialized = True
            except Exception as e:
                self.queue.put(f"PROGRESS:Device Firmware:COM initialization failed: {str(e)}")
                return

            # Get device information
            self.queue.put("PROGRESS:Device Firmware:Detecting device information...")

            # Try to get WMI information with error handling
            try:
                c = wmi.WMI()

                # Get system manufacturer and model
                try:
                    system_info = c.Win32_ComputerSystem()[0]
                    manufacturer = system_info.Manufacturer.strip().lower()
                    model = system_info.Model.strip()
                    self.queue.put(f"PROGRESS:Device Firmware:Manufacturer: {manufacturer}")
                    self.queue.put(f"PROGRESS:Device Firmware:Model: {model}")
                except Exception as e:
                    self.queue.put(f"PROGRESS:Device Firmware:Error getting system info: {str(e)}")
                    manufacturer = "unknown"
                    model = "unknown"

                # Get serial number
                try:
                    bios_info = c.Win32_BIOS()[0]
                    serial_number = bios_info.SerialNumber.strip()
                    self.queue.put(f"PROGRESS:Device Firmware:Serial Number: {serial_number}")
                except Exception as e:
                    self.queue.put(f"PROGRESS:Device Firmware:Error getting BIOS info: {str(e)}")
                    serial_number = "unknown"

            except Exception as e:
                self.queue.put(f"PROGRESS:Device Firmware:Error initializing WMI: {str(e)}")
                self.queue.put("PROGRESS:Device Firmware:Unable to detect device information")
                self.queue.put("PROGRESS:Device Firmware:Please visit your manufacturer's support website manually")
                return

            # Check for supported manufacturers
            if 'dell' in manufacturer:
                self.queue.put("PROGRESS:Device Firmware:Detected Dell system")
                self.update_dell_firmware(model, serial_number)
            elif 'hp' in manufacturer or 'hewlett packard' in manufacturer:
                self.queue.put("PROGRESS:Device Firmware:Detected HP system")
                self.update_hp_firmware(model, serial_number)
            elif 'lenovo' in manufacturer:
                self.queue.put("PROGRESS:Device Firmware:Detected Lenovo system")
                self.update_lenovo_firmware(model, serial_number)
            else:
                self.queue.put(f"PROGRESS:Device Firmware:Unsupported manufacturer: {manufacturer}")
                self.queue.put("PROGRESS:Device Firmware:Please visit your manufacturer's support website manually")

                # Open manufacturer's support website
                try:
                    if 'dell' in manufacturer:
                        webbrowser.open("https://www.dell.com/support")
                    elif 'hp' in manufacturer or 'hewlett packard' in manufacturer:
                        webbrowser.open("https://support.hp.com")
                    elif 'lenovo' in manufacturer:
                        webbrowser.open("https://support.lenovo.com")
                    else:
                        webbrowser.open("https://www.bing.com/search?q=" + manufacturer + "+support")
                    self.queue.put("PROGRESS:Device Firmware:Opened manufacturer support website")
                except Exception as e:
                    self.queue.put(f"PROGRESS:Device Firmware:Error opening web browser: {str(e)}")

        except Exception as e:
            self.queue.put(f"PROGRESS:Device Firmware:Error in device firmware update: {str(e)}")
        finally:
            if initialized:
                pythoncom.CoUninitialize()

    def update_dell_firmware(self, model, serial_number):
        """Update Dell firmware using Dell Command Update or open support website"""
        self.queue.put("PROGRESS:Device Firmware:Checking for Dell Command Update...")

        # Check if Dell Command Update is installed
        dell_command_update_paths = [
            r"C:\Program Files\Dell\CommandUpdate\dcu-cli.exe",
            r"C:\Program Files (x86)\Dell\CommandUpdate\dcu-cli.exe"
        ]

        dcu_found = False
        for path in dell_command_update_paths:
            try:
                if os.path.exists(path):
                    dcu_found = True
                    self.queue.put(f"PROGRESS:Device Firmware:Dell Command Update found at: {path}")

                    # Run Dell Command Update
                    try:
                        self.queue.put("PROGRESS:Device Firmware:Running Dell Command Update...")
                        self.queue.put("PROGRESS:Device Firmware:Command: dcu-cli /scan /applyUpdates")

                        result = subprocess.run(
                            [path, '/scan', '/applyUpdates'],
                            capture_output=True,
                            text=True,
                            check=False,
                            timeout=3600,  # 1 hour timeout
                            creationflags=CREATE_NO_WINDOW  # Hide console window
                        )

                        if result.stdout.strip():
                            self.queue.put("PROGRESS:Device Firmware:Dell Command Update Output:")
                            for line in result.stdout.strip().split('\n'):
                                if line.strip():
                                    self.queue.put(f"PROGRESS:Device Firmware:  {line.strip()}")

                        if result.stderr.strip():
                            self.queue.put("PROGRESS:Device Firmware:Dell Command Update Errors:")
                            for line in result.stderr.strip().split('\n'):
                                if line.strip():
                                    self.queue.put(f"PROGRESS:Device Firmware:  {line.strip()}")

                        if result.returncode == 0:
                            self.queue.put("PROGRESS:Device Firmware:Dell firmware updates completed successfully")
                        else:
                            self.queue.put(
                                f"PROGRESS:Device Firmware:Dell Command Update completed with code: {result.returncode}")

                    except subprocess.TimeoutExpired:
                        self.queue.put("PROGRESS:Device Firmware:Dell Command Update timed out after 1 hour")
                    except Exception as e:
                        self.queue.put(f"PROGRESS:Device Firmware:Error running Dell Command Update: {str(e)}")

                    break
            except Exception as e:
                self.queue.put(f"PROGRESS:Device Firmware:Error checking path {path}: {str(e)}")
                continue

        if not dcu_found:
            self.queue.put("PROGRESS:Device Firmware:Dell Command Update not found")
            self.queue.put("PROGRESS:Device Firmware:Opening Dell support website...")

            # Open Dell support website with model pre-filled
            try:
                support_url = f"https://www.dell.com/support/home/en-us?app=drivers&serviceTag={serial_number}"
                self.queue.put(f"PROGRESS:Device Firmware:Opening: {support_url}")
                webbrowser.open(support_url)
                self.queue.put("PROGRESS:Device Firmware:Please download and install firmware updates manually")
            except Exception as e:
                self.queue.put(f"PROGRESS:Device Firmware:Error opening Dell support website: {str(e)}")
                # Fallback to generic Dell support page
                try:
                    webbrowser.open("https://www.dell.com/support")
                    self.queue.put("PROGRESS:Device Firmware:Opened generic Dell support page")
                except Exception as e2:
                    self.queue.put(f"PROGRESS:Device Firmware:Error opening generic support page: {str(e2)}")

    def update_hp_firmware(self, model, serial_number):
        """Update HP firmware using HP Support Assistant or open support website"""
        self.queue.put("PROGRESS:Device Firmware:Checking for HP Support Assistant...")

        # Check if HP Support Assistant is installed
        hp_support_assistant_paths = [
            r"C:\Program Files (x86)\Hewlett-Packard\HP Support Framework\HPSA.exe",
            r"C:\Program Files\Hewlett-Packard\HP Support Framework\HPSA.exe"
        ]

        hpsa_found = False
        for path in hp_support_assistant_paths:
            try:
                if os.path.exists(path):
                    hpsa_found = True
                    self.queue.put(f"PROGRESS:Device Firmware:HP Support Assistant found at: {path}")

                    # Run HP Support Assistant
                    try:
                        self.queue.put("PROGRESS:Device Firmware:Running HP Support Assistant...")

                        # HP Support Assistant doesn't have a good CLI, so we'll just open it
                        subprocess.Popen([path], creationflags=CREATE_NO_WINDOW)  # Hide console window
                        self.queue.put("PROGRESS:Device Firmware:HP Support Assistant opened")
                        self.queue.put(
                            "PROGRESS:Device Firmware:Please check for updates in the HP Support Assistant window")

                    except Exception as e:
                        self.queue.put(f"PROGRESS:Device Firmware:Error opening HP Support Assistant: {str(e)}")

                    break
            except Exception as e:
                self.queue.put(f"PROGRESS:Device Firmware:Error checking path {path}: {str(e)}")
                continue

        if not hpsa_found:
            self.queue.put("PROGRESS:Device Firmware:HP Support Assistant not found")
            self.queue.put("PROGRESS:Device Firmware:Opening HP support website...")

            # Open HP support website
            try:
                # Clean up model name for URL
                clean_model = re.sub(r'[^a-zA-Z0-9\- ]', '', model)
                clean_model = re.sub(r'\s+', '-', clean_model)
                support_url = f"https://support.hp.com/us-en/drivers/{clean_model}"
                self.queue.put(f"PROGRESS:Device Firmware:Opening: {support_url}")
                webbrowser.open(support_url)
                self.queue.put("PROGRESS:Device Firmware:Please download and install firmware updates manually")
            except Exception as e:
                self.queue.put(f"PROGRESS:Device Firmware:Error opening HP support website: {str(e)}")
                # Fallback to generic HP support page
                try:
                    webbrowser.open("https://support.hp.com")
                    self.queue.put("PROGRESS:Device Firmware:Opened generic HP support page")
                except Exception as e2:
                    self.queue.put(f"PROGRESS:Device Firmware:Error opening generic support page: {str(e2)}")

    def update_lenovo_firmware(self, model, serial_number):
        """Update Lenovo firmware using Lenovo Vantage or open support website"""
        self.queue.put("PROGRESS:Device Firmware:Checking for Lenovo Vantage...")

        # Check if Lenovo Vantage is installed
        lenovo_vantage_paths = [
            r"C:\Program Files\Lenovo\VantageService\LenovoVantage.exe",
            r"C:\Program Files (x86)\Lenovo\VantageService\LenovoVantage.exe"
        ]

        vantage_found = False
        for path in lenovo_vantage_paths:
            try:
                if os.path.exists(path):
                    vantage_found = True
                    self.queue.put(f"PROGRESS:Device Firmware:Lenovo Vantage found at: {path}")

                    # Run Lenovo Vantage
                    try:
                        self.queue.put("PROGRESS:Device Firmware:Running Lenovo Vantage...")

                        # Lenovo Vantage doesn't have a good CLI, so we'll just open it
                        subprocess.Popen([path], creationflags=CREATE_NO_WINDOW)  # Hide console window
                        self.queue.put("PROGRESS:Device Firmware:Lenovo Vantage opened")
                        self.queue.put("PROGRESS:Device Firmware:Please check for updates in the Lenovo Vantage window")

                    except Exception as e:
                        self.queue.put(f"PROGRESS:Device Firmware:Error opening Lenovo Vantage: {str(e)}")

                    break
            except Exception as e:
                self.queue.put(f"PROGRESS:Device Firmware:Error checking path {path}: {str(e)}")
                continue

        if not vantage_found:
            self.queue.put("PROGRESS:Device Firmware:Lenovo Vantage not found")
            self.queue.put("PROGRESS:Device Firmware:Opening Lenovo support website...")

            # Open Lenovo support website with MTM (Machine Type Model) pre-filled
            try:
                # Extract MTM from model name
                mtm_match = re.search(r'\b[A-Z0-9]{4}\b', model)
                if mtm_match:
                    mtm = mtm_match.group(0)
                else:
                    # If no MTM found, use the cleaned model name
                    mtm = re.sub(r'[^a-zA-Z0-9\- ]', '', model)
                    mtm = re.sub(r'\s+', '-', mtm)

                support_url = f"https://support.lenovo.com/us/en/products/{mtm}"
                self.queue.put(f"PROGRESS:Device Firmware:Opening: {support_url}")
                webbrowser.open(support_url)
                self.queue.put("PROGRESS:Device Firmware:Please download and install firmware updates manually")
            except Exception as e:
                self.queue.put(f"PROGRESS:Device Firmware:Error opening Lenovo support website: {str(e)}")
                # Fallback to generic Lenovo support page
                try:
                    webbrowser.open("https://support.lenovo.com")
                    self.queue.put("PROGRESS:Device Firmware:Opened generic Lenovo support page")
                except Exception as e2:
                    self.queue.put(f"PROGRESS:Device Firmware:Error opening generic support page: {str(e2)}")

    def repair_system_files(self):
        """Repair Windows system files using SFC and DISM"""
        self.queue.put("PROGRESS:System Repair:Starting Windows system file repair...")
        self.queue.put("PROGRESS:System Repair:This process may take 30 minutes or more. Please be patient.")

        # Step 1: Run SFC (System File Checker)
        self.queue.put("PROGRESS:System Repair:=== Running System File Checker (SFC) ===")
        try:
            self.queue.put("PROGRESS:System Repair:Executing: sfc /scannow")
            self.queue.put("PROGRESS:System Repair:Starting SFC scan...")

            result = subprocess.run(
                ['sfc', '/scannow'],
                capture_output=True,
                text=True,
                timeout=1800,  # 30 minute timeout
                creationflags=CREATE_NO_WINDOW  # Hide console window
            )

            self.queue.put("PROGRESS:System Repair:SFC scan completed")

            if result.stdout.strip():
                self.queue.put("PROGRESS:System Repair:SFC Output:")
                for line in result.stdout.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:System Repair:  {line.strip()}")

            if result.stderr.strip():
                self.queue.put("PROGRESS:System Repair:SFC Errors:")
                for line in result.stderr.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:System Repair:  {line.strip()}")

            # Check return code
            if result.returncode == 0:
                self.queue.put("PROGRESS:System Repair:SFC scan completed successfully")
            elif result.returncode == 1:
                self.queue.put("PROGRESS:System Repair:SFC found and fixed corrupted files")
            elif result.returncode == 2:
                self.queue.put("PROGRESS:System Repair:SFC found corrupted files but couldn't fix some")
            else:
                self.queue.put(f"PROGRESS:System Repair:SFC completed with return code: {result.returncode}")

        except subprocess.TimeoutExpired:
            self.queue.put("PROGRESS:System Repair:SFC scan timed out after 30 minutes")
        except Exception as e:
            self.queue.put(f"PROGRESS:System Repair:Error running SFC: {str(e)}")

        # Step 2: Run DISM (Deployment Image Servicing and Management)
        self.queue.put("PROGRESS:System Repair:=== Running DISM to repair component store ===")
        try:
            self.queue.put("PROGRESS:System Repair:Executing: DISM /Online /Cleanup-Image /RestoreHealth")
            self.queue.put("PROGRESS:System Repair:Starting DISM repair...")

            result = subprocess.run(
                ['DISM', '/Online', '/Cleanup-Image', '/RestoreHealth'],
                capture_output=True,
                text=True,
                timeout=1800,  # 30 minute timeout
                creationflags=CREATE_NO_WINDOW  # Hide console window
            )

            self.queue.put("PROGRESS:System Repair:DISM repair completed")

            if result.stdout.strip():
                self.queue.put("PROGRESS:System Repair:DISM Output:")
                for line in result.stdout.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:System Repair:  {line.strip()}")

            if result.stderr.strip():
                self.queue.put("PROGRESS:System Repair:DISM Errors:")
                for line in result.stderr.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:System Repair:  {line.strip()}")

            # Check return code
            if result.returncode == 0:
                self.queue.put("PROGRESS:System Repair:DISM repair completed successfully")
            else:
                self.queue.put(f"PROGRESS:System Repair:DISM completed with return code: {result.returncode}")

        except subprocess.TimeoutExpired:
            self.queue.put("PROGRESS:System Repair:DISM repair timed out after 30 minutes")
        except Exception as e:
            self.queue.put(f"PROGRESS:System Repair:Error running DISM: {str(e)}")

        # Step 3: Run SFC again after DISM
        self.queue.put("PROGRESS:System Repair:=== Running System File Checker (SFC) again after DISM ===")
        try:
            self.queue.put("PROGRESS:System Repair:Executing: sfc /scannow")
            self.queue.put("PROGRESS:System Repair:Starting second SFC scan...")

            result = subprocess.run(
                ['sfc', '/scannow'],
                capture_output=True,
                text=True,
                timeout=1800,  # 30 minute timeout
                creationflags=CREATE_NO_WINDOW  # Hide console window
            )

            self.queue.put("PROGRESS:System Repair:Second SFC scan completed")

            if result.stdout.strip():
                self.queue.put("PROGRESS:System Repair:SFC Output:")
                for line in result.stdout.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:System Repair:  {line.strip()}")

            if result.stderr.strip():
                self.queue.put("PROGRESS:System Repair:SFC Errors:")
                for line in result.stderr.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:System Repair:  {line.strip()}")

            # Check return code
            if result.returncode == 0:
                self.queue.put("PROGRESS:System Repair:Second SFC scan completed successfully")
            elif result.returncode == 1:
                self.queue.put("PROGRESS:System Repair:SFC found and fixed corrupted files")
            elif result.returncode == 2:
                self.queue.put("PROGRESS:System Repair:SFC found corrupted files but couldn't fix some")
            else:
                self.queue.put(f"PROGRESS:System Repair:SFC completed with return code: {result.returncode}")

        except subprocess.TimeoutExpired:
            self.queue.put("PROGRESS:System Repair:Second SFC scan timed out after 30 minutes")
        except Exception as e:
            self.queue.put(f"PROGRESS:System Repair:Error running second SFC: {str(e)}")

        self.queue.put("PROGRESS:System Repair:System repair process completed!")
        self.queue.put("PROGRESS:System Repair:A restart may be required for all changes to take effect.")

    def run_chk_dsk(self):
        """Schedule CHKDSK to run on next reboot with repair options"""
        self.queue.put("PROGRESS:CHKDSK:Starting CHKDSK on drive C: with repair options...")
        self.queue.put("PROGRESS:CHKDSK:Warning: This operation requires a system reboot to complete.")

        try:
            # First, check if the drive is already marked for checking
            self.queue.put("PROGRESS:CHKDSK:Checking current disk status...")
            result = subprocess.run(
                ['fsutil', 'dirty', 'query', 'C:'],
                capture_output=True,
                text=True,
                check=False,
                timeout=30,
                creationflags=CREATE_NO_WINDOW  # Hide console window
            )

            if "Volume is dirty" in result.stdout:
                self.queue.put("PROGRESS:CHKDSK:Drive C: is already marked for checking")
            else:
                self.queue.put("PROGRESS:CHKDSK:Drive C: is not currently marked for checking")

            # Schedule CHKDSK to run on next reboot with repair options
            self.queue.put("PROGRESS:CHKDSK:Scheduling CHKDSK to run on next reboot...")
            self.queue.put("PROGRESS:CHKDSK:Executing: chkdsk C: /F /R /X")

            result = subprocess.run(
                ['chkdsk', 'C:', '/F', '/R', '/X'],
                capture_output=True,
                text=True,
                check=False,
                timeout=60,
                creationflags=CREATE_NO_WINDOW  # Hide console window
            )

            # Log the output
            if result.stdout.strip():
                self.queue.put("PROGRESS:CHKDSK:CHKDSK Output:")
                for line in result.stdout.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:CHKDSK:  {line.strip()}")

            if result.stderr.strip():
                self.queue.put("PROGRESS:CHKDSK:CHKDSK Errors:")
                for line in result.stderr.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:CHKDSK:  {line.strip()}")

            # Check return code
            if result.returncode == 0:
                self.queue.put("PROGRESS:CHKDSK:CHKDSK successfully scheduled for next reboot")

                # Ask user if they want to reboot now
                self.queue.put("CHKDSK_SCHEDULED")
                self.root.after(100, self.prompt_reboot)
            else:
                self.queue.put(f"PROGRESS:CHKDSK:CHKDSK scheduling completed with return code: {result.returncode}")

        except subprocess.TimeoutExpired:
            self.queue.put("PROGRESS:CHKDSK:CHKDSK command timed out")
        except Exception as e:
            self.queue.put(f"PROGRESS:CHKDSK:Error scheduling CHKDSK: {str(e)}")

    def perform_windows_adjustments(self):
        """Apply various Windows system adjustments for better performance"""
        self.queue.put("PROGRESS:Windows Adjustments:Starting Windows adjustments...")
        self.queue.put(
            "PROGRESS:Windows Adjustments:This will modify focus, network, visual effects, and gaming settings.")

        try:
            # Registry modifications with validation
            adjustments = [
                {
                    "name": "Focus Assist",
                    "path": r"SOFTWARE\Microsoft\Windows\CurrentVersion\Notifications\Settings\QuietHours",
                    "values": [("QuietHoursState", 0)]
                },
                {
                    "name": "Transparency Effects",
                    "path": r"SOFTWARE\Microsoft\Windows\CurrentVersion\Themes\Personalize",
                    "values": [("EnableTransparency", 0)]
                },
                {
                    "name": "Game Bar",
                    "path": r"SOFTWARE\Microsoft\Windows\CurrentVersion\GameDVR",
                    "values": [("AppCaptureEnabled", 0), ("BackgroundRecordingEnabled", 0)]
                },
                {
                    "name": "Game Mode",
                    "path": r"SOFTWARE\Microsoft\GameBar",
                    "values": [("AllowAutoGameMode", 0), ("AutoGameModeEnabled", 0)]
                },
                {
                    "name": "Game DVR",
                    "path": r"SOFTWARE\Microsoft\Windows\CurrentVersion\GameDVR",
                    "values": [("AllowGameDVR", 0)]
                },
                {
                    "name": "Game Capture",
                    "path": r"SOFTWARE\Microsoft\Windows\CurrentVersion\GameDVR",
                    "values": [("GameCaptureEnabled", 0)]
                }
            ]

            for i, adjustment in enumerate(adjustments):
                try:
                    self.queue.put(
                        f"PROGRESS:Windows Adjustments:Processing adjustment {i + 1}/{len(adjustments)}: {adjustment['name']}...")

                    # Validate registry path
                    SecurityUtils.validate_registry_key(adjustment["path"])

                    # Open or create registry key
                    try:
                        key = winreg.OpenKey(
                            winreg.HKEY_CURRENT_USER,
                            adjustment["path"],
                            0,
                            winreg.KEY_WRITE
                        )
                    except WindowsError as e:
                        if e.errno == 2:  # Key not found
                            self.queue.put(f"PROGRESS:Windows Adjustments:Registry key not found, creating it...")
                            key = winreg.CreateKey(
                                winreg.HKEY_CURRENT_USER,
                                adjustment["path"]
                            )
                        else:
                            raise

                    # Set values
                    for j, (value_name, value_data) in enumerate(adjustment["values"]):
                        self.queue.put(
                            f"PROGRESS:Windows Adjustments:Setting registry value {j + 1}/{len(adjustment['values'])}: {value_name} = {value_data}")
                        winreg.SetValueEx(key, value_name, 0, winreg.REG_DWORD, value_data)

                    winreg.CloseKey(key)
                    self.queue.put(f"PROGRESS:Windows Adjustments:{adjustment['name']} disabled")

                except Exception as e:
                    self.queue.put(f"PROGRESS:Windows Adjustments:Error disabling {adjustment['name']}: {str(e)}")

            # Network adjustment using safe PowerShell
            self.queue.put("PROGRESS:Windows Adjustments:Changing network to private...")
            try:
                ps_script = '''
                try {
                    Get-NetConnectionProfile | Set-NetConnectionProfile -NetworkCategory Private
                    Write-Host "Network category set to Private"
                } catch {
                    Write-Host "Error setting network category: $($_.Exception.Message)"
                }
                '''

                self.queue.put("PROGRESS:Windows Adjustments:Executing PowerShell network adjustment script...")
                result = subprocess.run(
                    ['powershell', '-Command', ps_script],
                    capture_output=True,
                    text=True,
                    check=False,
                    timeout=60,
                    creationflags=CREATE_NO_WINDOW  # Hide console window
                )

                if result.stdout.strip():
                    self.queue.put("PROGRESS:Windows Adjustments:Network adjustment output:")
                    for line in result.stdout.strip().split('\n'):
                        if line.strip():
                            self.queue.put(f"PROGRESS:Windows Adjustments:  {line.strip()}")

                if result.stderr.strip():
                    self.queue.put("PROGRESS:Windows Adjustments:Network adjustment errors:")
                    for line in result.stderr.strip().split('\n'):
                        if line.strip():
                            self.queue.put(f"PROGRESS:Windows Adjustments:  {line.strip()}")

            except subprocess.TimeoutExpired:
                self.queue.put("PROGRESS:Windows Adjustments:Network adjustment timed out")
            except Exception as e:
                self.queue.put(f"PROGRESS:Windows Adjustments:Error changing network: {str(e)}")

            self.queue.put("PROGRESS:Windows Adjustments:Windows adjustments completed!")
            self.queue.put("PROGRESS:Windows Adjustments:Some changes may require a restart or logout to take effect.")

        except Exception as e:
            self.queue.put(f"PROGRESS:Windows Adjustments:Error in Windows adjustments: {str(e)}")

    def flush_dns_and_renew_ip(self):
        """Flush DNS and renew IP address"""
        self.queue.put("PROGRESS:Flush DNS and Renew IP:Starting DNS flush and IP renewal...")

        try:
            # Step 1: Release IP
            self.queue.put("PROGRESS:Flush DNS and Renew IP:Step 1: Releasing IP address...")
            try:
                self.queue.put("PROGRESS:Flush DNS and Renew IP:Executing: ipconfig /release")
                result = subprocess.run(
                    ['ipconfig', '/release'],
                    capture_output=True,
                    text=True,
                    check=False,
                    timeout=30,
                    creationflags=CREATE_NO_WINDOW  # Hide console window
                )
                self.queue.put("PROGRESS:Flush DNS and Renew IP:IP address released successfully")
                if result.stdout.strip():
                    self.queue.put(f"PROGRESS:Flush DNS and Renew IP:Output: {result.stdout.strip()}")
                if result.stderr.strip():
                    self.queue.put(f"PROGRESS:Flush DNS and Renew IP:Errors: {result.stderr.strip()}")
            except subprocess.TimeoutExpired:
                self.queue.put("PROGRESS:Flush DNS and Renew IP:IP release command timed out")
            except Exception as e:
                self.queue.put(f"PROGRESS:Flush DNS and Renew IP:Error releasing IP: {str(e)}")

            # Step 2: Renew IP
            self.queue.put("PROGRESS:Flush DNS and Renew IP:Step 2: Renewing IP address...")
            try:
                self.queue.put("PROGRESS:Flush DNS and Renew IP:Executing: ipconfig /renew")
                result = subprocess.run(
                    ['ipconfig', '/renew'],
                    capture_output=True,
                    text=True,
                    check=False,
                    timeout=60,  # May take longer
                    creationflags=CREATE_NO_WINDOW  # Hide console window
                )
                self.queue.put("PROGRESS:Flush DNS and Renew IP:IP address renewed successfully")
                if result.stdout.strip():
                    self.queue.put(f"PROGRESS:Flush DNS and Renew IP:Output: {result.stdout.strip()}")
                if result.stderr.strip():
                    self.queue.put(f"PROGRESS:Flush DNS and Renew IP:Errors: {result.stderr.strip()}")
            except subprocess.TimeoutExpired:
                self.queue.put("PROGRESS:Flush DNS and Renew IP:IP renewal command timed out")
            except Exception as e:
                self.queue.put(f"PROGRESS:Flush DNS and Renew IP:Error renewing IP: {str(e)}")

            # Step 3: Flush DNS
            self.queue.put("PROGRESS:Flush DNS and Renew IP:Step 3: Flushing DNS...")
            try:
                self.queue.put("PROGRESS:Flush DNS and Renew IP:Executing: ipconfig /flushdns")
                result = subprocess.run(
                    ['ipconfig', '/flushdns'],
                    capture_output=True,
                    text=True,
                    check=False,
                    timeout=30,
                    creationflags=CREATE_NO_WINDOW  # Hide console window
                )
                self.queue.put("PROGRESS:Flush DNS and Renew IP:DNS flushed successfully")
                if result.stdout.strip():
                    self.queue.put(f"PROGRESS:Flush DNS and Renew IP:Output: {result.stdout.strip()}")
                if result.stderr.strip():
                    self.queue.put(f"PROGRESS:Flush DNS and Renew IP:Errors: {result.stderr.strip()}")
            except subprocess.TimeoutExpired:
                self.queue.put("PROGRESS:Flush DNS and Renew IP:DNS flush command timed out")
            except Exception as e:
                self.queue.put(f"PROGRESS:Flush DNS and Renew IP:Error flushing DNS: {str(e)}")

            self.queue.put("PROGRESS:Flush DNS and Renew IP:DNS flush and IP renewal completed successfully!")

        except Exception as e:
            self.queue.put(f"PROGRESS:Flush DNS and Renew IP:Error in DNS flush and IP renewal: {str(e)}")

    def display_ip_config(self):
        """Display IP configuration using ipconfig /all"""
        self.queue.put("PROGRESS:Display IP Configuration:Retrieving IP configuration...")

        try:
            self.queue.put("PROGRESS:Display IP Configuration:Executing: ipconfig /all")
            result = subprocess.run(
                ['ipconfig', '/all'],
                capture_output=True,
                text=True,
                check=False,
                timeout=30,
                creationflags=CREATE_NO_WINDOW  # Hide console window
            )

            self.queue.put("PROGRESS:Display IP Configuration:IP configuration retrieved successfully")

            if result.stdout.strip():
                self.queue.put("PROGRESS:Display IP Configuration:=== IP Configuration ===")
                for line in result.stdout.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:Display IP Configuration:{line.strip()}")

            if result.stderr.strip():
                self.queue.put("PROGRESS:Display IP Configuration:Errors:")
                for line in result.stderr.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:Display IP Configuration:  {line.strip()}")

            self.queue.put("PROGRESS:Display IP Configuration:IP configuration display completed!")

        except subprocess.TimeoutExpired:
            self.queue.put("PROGRESS:Display IP Configuration:IP configuration command timed out")
        except Exception as e:
            self.queue.put(f"PROGRESS:Display IP Configuration:Error displaying IP configuration: {str(e)}")

    def change_dns_servers(self):
        """Change DNS servers to 1.1.1.1 and 8.8.8.8"""
        self.queue.put("PROGRESS:Change DNS:Starting DNS server change process...")
        self.queue.put("PROGRESS:Change DNS:This will change the DNS servers for all active network interfaces.")

        try:
            # PowerShell script to change DNS servers for all active interfaces
            ps_script = '''
            try {
                $interfaces = Get-NetAdapter | Where-Object {$_.Status -eq "Up"}
                $changedCount = 0

                foreach ($interface in $interfaces) {
                    try {
                        $interfaceName = $interface.Name
                        Write-Host "Changing DNS for interface: $interfaceName"

                        # Set DNS servers
                        Set-DnsClientServerAddress -InterfaceAlias $interfaceName -ServerAddresses "1.1.1.1","8.8.8.8" -ErrorAction Stop

                        # Verify the change
                        $dnsServers = Get-DnsClientServerAddress -InterfaceAlias $interfaceName -AddressFamily IPv4 -ErrorAction SilentlyContinue
                        if ($dnsServers.ServerAddresses -contains "1.1.1.1" -and $dnsServers.ServerAddresses -contains "8.8.8.8") {
                            Write-Host "DNS successfully changed for $interfaceName"
                            $changedCount++
                        } else {
                            Write-Host "Warning: DNS change may not have been applied correctly for $interfaceName"
                        }
                    } catch {
                        Write-Host "Error changing DNS for $($interface.Name): $($_.Exception.Message)"
                    }
                }

                if ($changedCount -gt 0) {
                    Write-Host "DNS servers changed successfully for $changedCount interface(s)"
                    Write-Host "Primary DNS: 1.1.1.1 (Cloudflare)"
                    Write-Host "Secondary DNS: 8.8.8.8 (Google)"
                } else {
                    Write-Host "No active network interfaces found or DNS could not be changed"
                }
            } catch {
                Write-Error "Error changing DNS servers: $($_.Exception.Message)"
            }
            '''

            self.queue.put("PROGRESS:Change DNS:Executing PowerShell DNS change script...")
            result = subprocess.run(
                ['powershell', '-Command', ps_script],
                capture_output=True,
                text=True,
                check=False,
                timeout=60,
                creationflags=CREATE_NO_WINDOW  # Hide console window
            )

            self.queue.put("PROGRESS:Change DNS:DNS change process completed")

            if result.stdout.strip():
                self.queue.put("PROGRESS:Change DNS:Script output:")
                for line in result.stdout.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:Change DNS:  {line.strip()}")

            if result.stderr.strip():
                self.queue.put("PROGRESS:Change DNS:Script errors:")
                for line in result.stderr.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:Change DNS:  {line.strip()}")

            self.queue.put("PROGRESS:Change DNS:DNS server change process completed!")
            self.queue.put(
                "PROGRESS:Change DNS:Note: You may need to restart your browser or applications for changes to take effect.")

        except subprocess.TimeoutExpired:
            self.queue.put("PROGRESS:Change DNS:DNS change process timed out")
        except Exception as e:
            self.queue.put(f"PROGRESS:Change DNS:Error changing DNS servers: {str(e)}")

    def create_autopilot_csv(self):
        """Create AutoPilot CSV for Windows deployment"""
        self.queue.put("PROGRESS:AutoPilot CSV:Starting AutoPilot CSV creation...")
        self.queue.put("PROGRESS:AutoPilot CSV:This process may take several minutes. Please be patient.")

        try:
            # Step 1: Create PowerShell folder safely
            self.queue.put("PROGRESS:AutoPilot CSV:Step 1: Creating PowerShell folder on C: drive...")

            try:
                powershell_folder = SecurityUtils.sanitize_path("C:\\PowerShell")

                if not os.path.exists(powershell_folder):
                    os.makedirs(powershell_folder)
                    self.queue.put(f"PROGRESS:AutoPilot CSV:Created folder: {powershell_folder}")
                else:
                    self.queue.put(f"PROGRESS:AutoPilot CSV:Folder already exists: {powershell_folder}")

            except Exception as e:
                self.queue.put(f"PROGRESS:AutoPilot CSV:Error creating folder: {str(e)}")
                return

            # Step 2: Create a secure script for autopilot info
            self.queue.put("PROGRESS:AutoPilot CSV:Step 2: Creating AutoPilot script...")
            try:
                script_content = '''
# Secure AutoPilot Info Script
function Get-AutoPilotInfo {
    param(
        [string]$OutputFile = "AutoPilot.csv"
    )

    try {
        # Get device serial number
        $serialNumber = (Get-WmiObject -Class Win32_BIOS).SerialNumber

        # Get hardware hash
        $hardwareHash = ""
        try {
            $devDetail = Get-WmiObject -Namespace root/cimv2/mdm/dmmap -Class MDM_DevDetail_Ext01 -Filter "InstanceID='Ext'"
            if ($devDetail) {
                $hardwareHash = $devDetail.DeviceHardwareData
            }
        } catch {
            Write-Warning "Could not retrieve hardware hash"
        }

        # Create CSV content
        $csvHeader = "Device Serial Number,Windows Product ID,Hardware Hash"
        $csvData = "$serialNumber,,$hardwareHash"

        # Write to file
        $csvContent = $csvHeader + "`r`n" + $csvData
        $csvContent | Out-File -FilePath $OutputFile -Encoding UTF8

        Write-Host "AutoPilot CSV created: $OutputFile"
        Write-Host "Serial Number: $serialNumber"
        Write-Host "Hardware Hash Length: $($hardwareHash.Length)"

    } catch {
        Write-Error "Error creating AutoPilot CSV: $($_.Exception.Message)"
    }
}

# Run the function
Get-AutoPilotInfo -OutputFile "C:\\PowerShell\\AutoPilot.csv"
'''

                script_path = os.path.join(powershell_folder, "Get-AutoPilotInfo.ps1")
                with open(script_path, 'w', encoding='utf-8') as f:
                    f.write(script_content)

                self.queue.put(f"PROGRESS:AutoPilot CSV:Script created at: {script_path}")

                # Step 3: Run the script safely
                self.queue.put("PROGRESS:AutoPilot CSV:Step 3: Running AutoPilot script...")

                result = subprocess.run(
                    ['powershell', '-ExecutionPolicy', 'Bypass', '-File', script_path],
                    capture_output=True,
                    text=True,
                    timeout=300,  # 5 minute timeout
                    creationflags=CREATE_NO_WINDOW  # Hide console window
                )

                if result.stdout.strip():
                    self.queue.put("PROGRESS:AutoPilot CSV:Script output:")
                    for line in result.stdout.strip().split('\n'):
                        if line.strip():
                            self.queue.put(f"PROGRESS:AutoPilot CSV:  {line.strip()}")

                if result.stderr.strip():
                    self.queue.put("PROGRESS:AutoPilot CSV:Script errors:")
                    for line in result.stderr.strip().split('\n'):
                        if line.strip():
                            self.queue.put(f"PROGRESS:AutoPilot CSV:  {line.strip()}")

                # Check if CSV was created
                output_file = os.path.join(powershell_folder, "AutoPilot.csv")
                if os.path.exists(output_file):
                    self.queue.put(f"PROGRESS:AutoPilot CSV:AutoPilot CSV created successfully: {output_file}")

                    # Verify content
                    try:
                        with open(output_file, 'r', encoding='utf-8') as f:
                            content = f.read()
                        if content.strip():
                            self.queue.put("PROGRESS:AutoPilot CSV:CSV file contains data")
                            self.queue.put("PROGRESS:AutoPilot CSV:File size: {len(content)} bytes")
                        else:
                            self.queue.put("PROGRESS:AutoPilot CSV:Warning: CSV file is empty")
                    except Exception as e:
                        self.queue.put(f"PROGRESS:AutoPilot CSV:Error reading CSV: {str(e)}")
                else:
                    self.queue.put("PROGRESS:AutoPilot CSV:Warning: CSV file was not created")

            except subprocess.TimeoutExpired:
                self.queue.put("PROGRESS:AutoPilot CSV:AutoPilot script timed out")
            except Exception as e:
                self.queue.put(f"PROGRESS:AutoPilot CSV:Error running script: {str(e)}")

            self.queue.put("PROGRESS:AutoPilot CSV:AutoPilot CSV creation process completed!")

        except Exception as e:
            self.queue.put(f"PROGRESS:AutoPilot CSV:Error in AutoPilot CSV creation: {str(e)}")

    # ==================== APP SETTINGS METHODS ====================

    def stop_background_apps(self):
        """Stop background applications from running"""
        self.queue.put("PROGRESS:Stop Background Apps:Stopping background apps...")
        try:
            # Safe PowerShell script to disable background apps
            ps_script = '''
            try {
                # Disable background apps globally
                $registryPath = "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\BackgroundAccessApplications"

                # Create registry path if it doesn't exist
                if (-not (Test-Path "HKCU:\\$registryPath")) {
                    New-Item -Path "HKCU:\\$registryPath" -Force | Out-Null
                }

                # Set global disable flag
                Set-ItemProperty -Path "HKCU:\\$registryPath" -Name "GlobalUserDisabled" -Value 1 -Type DWORD -Force

                Write-Host "Background apps disabled successfully"
            } catch {
                Write-Error "Error disabling background apps: $($_.Exception.Message)"
            }
            '''

            self.queue.put("PROGRESS:Stop Background Apps:Executing PowerShell script...")
            result = subprocess.run(
                ['powershell', '-Command', ps_script],
                capture_output=True,
                text=True,
                check=False,
                timeout=60,
                creationflags=CREATE_NO_WINDOW  # Hide console window
            )

            if result.stdout.strip():
                self.queue.put("PROGRESS:Stop Background Apps:Script output:")
                for line in result.stdout.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:Stop Background Apps:  {line.strip()}")

            if result.stderr.strip():
                self.queue.put("PROGRESS:Stop Background Apps:Script errors:")
                for line in result.stderr.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:Stop Background Apps:  {line.strip()}")

        except subprocess.TimeoutExpired:
            self.queue.put("PROGRESS:Stop Background Apps:Background apps operation timed out")
        except Exception as e:
            self.queue.put(f"PROGRESS:Stop Background Apps:Error stopping background apps: {str(e)}")

    def disable_startup_apps(self):
        """Disable startup applications except OneDrive"""
        self.queue.put("PROGRESS:Disable Startup Apps:Disabling startup apps (except OneDrive)...")
        try:
            # Safe PowerShell script to disable startup apps
            ps_script = '''
            try {
                $disabledCount = 0

                # Check registry startup items
                $regPath = "HKCU:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run"

                if (Test-Path $regPath) {
                    $regItems = Get-ItemProperty -Path $regPath

                    foreach ($prop in $regItems.PSObject.Properties) {
                        if ($prop.Name -notlike "PS*" -and $prop.Name -notlike "*OneDrive*") {
                            try {
                                Remove-ItemProperty -Path $regPath -Name $prop.Name -Force
                                Write-Host "Disabled startup item: $($prop.Name)"
                                $disabledCount++
                            } catch {
                                Write-Warning "Could not disable: $($prop.Name)"
                            }
                        } elseif ($prop.Name -like "*OneDrive*") {
                            Write-Host "Skipped OneDrive: $($prop.Name)"
                        }
                    }
                }

                Write-Host "Startup apps disabled successfully"
                Write-Host "Total disabled items: $disabledCount"

            } catch {
                Write-Error "Error disabling startup apps: $($_.Exception.Message)"
            }
            '''

            self.queue.put("PROGRESS:Disable Startup Apps:Executing PowerShell script...")
            result = subprocess.run(
                ['powershell', '-Command', ps_script],
                capture_output=True,
                text=True,
                check=False,
                timeout=60,
                creationflags=CREATE_NO_WINDOW  # Hide console window
            )

            if result.stdout.strip():
                self.queue.put("PROGRESS:Disable Startup Apps:Script output:")
                for line in result.stdout.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:Disable Startup Apps:  {line.strip()}")

            if result.stderr.strip():
                self.queue.put("PROGRESS:Disable Startup Apps:Script errors:")
                for line in result.stderr.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:Disable Startup Apps:  {line.strip()}")

        except subprocess.TimeoutExpired:
            self.queue.put("PROGRESS:Disable Startup Apps:Startup apps operation timed out")
        except Exception as e:
            self.queue.put(f"PROGRESS:Disable Startup Apps:Error disabling startup apps: {str(e)}")

    def update_installed_apps(self):
        """Update installed applications using Windows Package Manager (winget)"""
        self.queue.put("PROGRESS:Update Apps:Starting application update process...")
        try:
            # Check if winget is available
            self.queue.put("PROGRESS:Update Apps:Checking for Windows Package Manager (winget)...")
            try:
                subprocess.run(['winget', '--version'], capture_output=True, check=True, timeout=10,
                               creationflags=CREATE_NO_WINDOW)
                self.queue.put("PROGRESS:Update Apps:Windows Package Manager found")
            except (subprocess.CalledProcessError, FileNotFoundError, subprocess.TimeoutExpired):
                self.queue.put("PROGRESS:Update Apps:Error: Windows Package Manager (winget) not found.")
                self.queue.put("PROGRESS:Update Apps:Please install winget from the Microsoft Store.")
                return

            # First, get list of available updates
            self.queue.put("PROGRESS:Update Apps:Checking for available updates...")
            list_command = ['winget', 'upgrade', '--list']
            result = subprocess.run(
                list_command,
                capture_output=True,
                text=True,
                check=False,
                timeout=60,
                creationflags=CREATE_NO_WINDOW
            )

            updates = []
            if result.returncode == 0:
                lines = result.stdout.strip().split('\n')
                for line in lines:
                    if line.strip() and not line.startswith('-') and not line.startswith('Name'):
                        # Extract app name from the line
                        parts = line.split()
                        if len(parts) >= 2:
                            app_name = parts[0]
                            updates.append(app_name)

                if updates:
                    self.queue.put(f"PROGRESS:Update Apps:Found {len(updates)} updates:")
                    for app in updates:
                        self.queue.put(f"PROGRESS:Update Apps:  - {app}")
                else:
                    self.queue.put("PROGRESS:Update Apps:No updates found.")
                    return
            else:
                self.queue.put("PROGRESS:Update Apps:Could not list updates. Proceeding with upgrade all.")

            # Now run the upgrade command with real-time output
            self.queue.put("PROGRESS:Update Apps:Starting upgrade process...")
            safe_args = ['winget', 'upgrade', '--all', '--silent',
                         '--accept-package-agreements', '--accept-source-agreements']

            # Run the command and capture output in real-time
            process = subprocess.Popen(
                safe_args,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                creationflags=CREATE_NO_WINDOW  # Hide console window
            )

            # Read the output in real-time
            while True:
                output = process.stdout.readline()
                if output == '' and process.poll() is not None:
                    break
                if output:
                    self.queue.put(f"PROGRESS:Update Apps:{output.strip()}")

            # Check for any errors
            stderr = process.stderr.read()
            if stderr:
                self.queue.put(f"PROGRESS:Update Apps:Errors:")
                for line in stderr.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:Update Apps:  {line.strip()}")

            if process.returncode == 0:
                self.queue.put("PROGRESS:Update Apps:App updates completed successfully")
            else:
                self.queue.put(f"PROGRESS:Update Apps:App updates completed with return code: {process.returncode}")

        except subprocess.TimeoutExpired:
            self.queue.put("PROGRESS:Update Apps:App update process timed out after 30 minutes")
        except Exception as e:
            self.queue.put(f"PROGRESS:Update Apps:Error updating apps: {str(e)}")

    # ==================== UTILITY METHODS ====================

    def prompt_reboot_for_updates(self):
        """Prompt user to reboot now to complete Windows updates"""
        response = messagebox.askyesno(
            "Updates Installed",
            "Windows updates have been installed successfully.\n\n"
            "A system reboot is required to complete the installation.\n\n"
            "Would you like to reboot now?"
        )

        if response:
            self.queue.put("PROGRESS:Windows Updates:User initiated system reboot for updates...")
            try:
                # Reboot the system
                subprocess.run(['shutdown', '/r', '/t', '30'], check=True, timeout=10, creationflags=CREATE_NO_WINDOW)
                self.queue.put("PROGRESS:Windows Updates:System will reboot in 30 seconds...")
                self.queue.put("PROGRESS:Windows Updates:Please save all work and close applications.")

                # Show countdown dialog
                messagebox.showinfo(
                    "Reboot Initiated",
                    "System will reboot in 30 seconds.\n\n"
                    "To cancel the reboot, run 'shutdown /a' in command prompt."
                )
            except Exception as e:
                self.queue.put(f"PROGRESS:Windows Updates:Error initiating reboot: {str(e)}")
        else:
            self.queue.put("PROGRESS:Windows Updates:User chose not to reboot now.")
            self.queue.put("PROGRESS:Windows Updates:Updates will be applied on the next manual reboot.")

    def prompt_reboot(self):
        """Prompt user to reboot now to run CHKDSK"""
        response = messagebox.askyesno(
            "CHKDSK Scheduled",
            "CHKDSK has been scheduled to run on the next reboot.\n\n"
            "Would you like to reboot now to start the disk check?\n\n"
            "WARNING: The reboot process may take a long time as CHKDSK runs.\n"
            "Make sure to save all your work before proceeding."
        )

        if response:
            self.queue.put("PROGRESS:CHKDSK:User initiated system reboot...")
            try:
                # Reboot the system with confirmation
                subprocess.run(['shutdown', '/r', '/t', '30'], check=True, timeout=10, creationflags=CREATE_NO_WINDOW)
                self.queue.put("PROGRESS:CHKDSK:System will reboot in 30 seconds...")
                self.queue.put("PROGRESS:CHKDSK:Please save all work and close applications.")

                # Show countdown dialog
                messagebox.showinfo(
                    "Reboot Initiated",
                    "System will reboot in 30 seconds.\n\n"
                    "To cancel the reboot, run 'shutdown /a' in command prompt."
                )
            except Exception as e:
                self.queue.put(f"PROGRESS:CHKDSK:Error initiating reboot: {str(e)}")
        else:
            self.queue.put("PROGRESS:CHKDSK:User chose not to reboot now.")
            self.queue.put("PROGRESS:CHKDSK:CHKDSK will run on the next manual reboot.")


def parse_args():
    """Parse command line arguments"""
    parser = argparse.ArgumentParser(description="Windows System Cleaner")
    parser.add_argument("--clean-temp", type=int, choices=[0, 1], default=0,
                        help="Enable/disable cleaning temporary files (1/0)")
    parser.add_argument("--disk-cleanup", type=int, choices=[0, 1], default=0,
                        help="Enable/disable disk cleanup (1/0)")
    parser.add_argument("--disable-fast-startup", type=int, choices=[0, 1], default=0,
                        help="Enable/disable disabling fast startup (1/0)")
    parser.add_argument("--update-apps", type=int, choices=[0, 1], default=0,
                        help="Enable/disable updating apps (1/0)")
    parser.add_argument("--windows-updates", type=int, choices=[0, 1], default=0,
                        help="Enable/disable Windows updates (1/0)")
    parser.add_argument("--device-firmware", type=int, choices=[0, 1], default=0,
                        help="Enable/disable device firmware updates (1/0)")
    parser.add_argument("--repair-system", type=int, choices=[0, 1], default=0,
                        help="Enable/disable system repair (1/0)")
    parser.add_argument("--chk-dsk", type=int, choices=[0, 1], default=0,
                        help="Enable/disable chkdsk C: /r (1/0)")
    parser.add_argument("--windows-adjustments", type=int, choices=[0, 1], default=0,
                        help="Enable/disable Windows adjustments (1/0)")
    parser.add_argument("--flush-dns", type=int, choices=[0, 1], default=0,
                        help="Enable/disable flush DNS and renew IP (1/0)")
    parser.add_argument("--ipconfig-all", type=int, choices=[0, 1], default=0,
                        help="Enable/disable display IP configuration (1/0)")
    parser.add_argument("--change-dns", type=int, choices=[0, 1], default=0,
                        help="Enable/disable change DNS to 1.1.1.1 and 8.8.8.8 (1/0)")
    parser.add_argument("--autopilot-csv", type=int, choices=[0, 1], default=0,
                        help="Enable/disable AutoPilot CSV creation (1/0)")
    parser.add_argument("--pc-report", type=int, choices=[0, 1], default=0,
                        help="Enable/disable PC Report generation (1/0)")
    parser.add_argument("--chris-titus-utility", type=int, choices=[0, 1], default=0,
                        help="Enable/disable Chris Titus Windows Utility (1/0)")
    parser.add_argument("--stop-background-apps", type=int, choices=[0, 1], default=0,
                        help="Enable/disable stopping background apps (1/0)")
    parser.add_argument("--disable-startup-apps", type=int, choices=[0, 1], default=0,
                        help="Enable/disable disabling startup apps except OneDrive (1/0)")
    return parser.parse_args()


def is_frozen():
    """Check if the application is running as a frozen executable"""
    return getattr(sys, 'frozen', False)


def restart_as_admin():
    """Restart the application with administrator privileges"""
    try:
        # Get the path to the current executable
        executable = sys.executable

        # Build command line arguments
        if is_frozen():
            # Running as a frozen executable
            args = sys.argv[1:]  # Skip the first argument (the executable path)
        else:
            # Running as a script
            args = [os.path.abspath(sys.argv[0])]  # The script path
            if len(sys.argv) > 1:
                args.extend(sys.argv[1:])

        # Sanitize arguments
        safe_args = SecurityUtils.sanitize_command_args(args)

        # Start new process with admin rights
        # Using ShellExecuteW with runas verb to trigger UAC
        result = ctypes.windll.shell32.ShellExecuteW(
            None,  # hwnd
            "runas",  # verb
            executable,  # file to execute
            " ".join(safe_args),  # parameters
            None,  # current directory
            1  # show command (SW_SHOWNORMAL)
        )

        # Check if ShellExecuteW succeeded (returns >32 on success)
        if result <= 32:
            messagebox.showerror("Error", f"Failed to restart as administrator. Error code: {result}")
            return False

        # Exit the current instance
        sys.exit(0)
    except Exception as e:
        messagebox.showerror("Error", f"Failed to restart as administrator: {str(e)}")
        return False


def main():
    try:
        startup_log("Main function started")

        # Check if we're in a relaunch process
        if '--relaunched' in sys.argv:
            startup_log("Application relaunched with pythonw.exe")

        # Check if running as admin, if not restart
        if not ctypes.windll.shell32.IsUserAnAdmin():
            startup_log("Not running as admin, restarting with admin privileges")
            if not restart_as_admin():
                startup_log("Failed to restart as admin, continuing without admin rights")
                # Continue without admin rights but warn user
                messagebox.showwarning(
                    "Administrator Rights Required",
                    "This application requires administrator privileges to function properly.\n"
                    "Some features may not work correctly.\n\n"
                    "Please restart the application as administrator."
                )

        startup_log("Running with admin privileges")

        # Parse command line arguments
        args = parse_args()

        # Load theme preference if it exists
        theme = DARK_THEME  # Default to dark mode
        dark_mode = True
        try:
            if os.path.exists("theme_pref.json"):
                with open("theme_pref.json", "r") as f:
                    pref = json.load(f)
                    dark_mode = pref.get("dark_mode", True)
                    if not dark_mode:
                        theme = LIGHT_THEME
        except:
            pass

        # Load font size preference
        font_size_factor = 1.0
        try:
            if os.path.exists("font_size_pref.json"):
                with open("font_size_pref.json", "r") as f:
                    pref = json.load(f)
                    font_size_factor = pref.get("font_size_factor", 1.0)
        except:
            pass

        # Create the main window
        try:
            root = tk.Tk()
            startup_log("Main window created successfully")
        except Exception as e:
            startup_log(f"Failed to create main window: {str(e)}")
            messagebox.showerror("GUI Error", f"Failed to create GUI window:\n{str(e)}")
            sys.exit(1)

        startup_log("Creating main application")
        app = SystemCleanerGUI(root, theme)
        app.dark_mode_var.set(dark_mode)
        app.font_size_factor = font_size_factor
        startup_log("Main application created successfully")

        # Apply command line arguments if provided
        if args:
            app.clean_temp.set(args.clean_temp)
            app.disk_cleanup.set(args.disk_cleanup)
            app.disable_fast_startup.set(args.disable_fast_startup)
            app.update_apps.set(args.update_apps)
            app.windows_updates.set(args.windows_updates)
            app.device_firmware.set(args.device_firmware)
            app.repair_system.set(args.repair_system)
            app.chk_dsk.set(args.chk_dsk)
            app.windows_adjustments.set(args.windows_adjustments)
            app.flush_dns.set(args.flush_dns)
            app.ipconfig_all.set(args.ipconfig_all)
            app.change_dns.set(args.change_dns)
            app.autopilot_csv.set(args.autopilot_csv)
            app.pc_report.set(args.pc_report)
            app.chris_titus_utility.set(args.chris_titus_utility)
            app.stop_background_apps_var.set(args.stop_background_apps)
            app.disable_startup_apps_var.set(args.disable_startup_apps)

        startup_log("Main application created")

        # Start the main loop
        startup_log("Starting main loop")
        root.mainloop()
        startup_log("Main loop ended")

    except Exception as e:
        startup_log(f"Application error: {str(e)}")
        startup_log(f"Traceback: {traceback.format_exc()}")
        print(f"Error: {str(e)}")
        print(f"Traceback: {traceback.format_exc()}")
        messagebox.showerror("Application Error", f"An error occurred: {str(e)}")
        sys.exit(1)


if __name__ == "__main__":
    main()
