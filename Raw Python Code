import traceback
from datetime import datetime, timedelta
import wmi
import requests
from bs4 import BeautifulSoup
import pythoncom
import ctypes
import winreg
import tkinter as tk
from tkinter import ttk, messagebox, Menu
import threading
import queue
import argparse
import platform
import psutil
import subprocess
import os
import sys
import uuid
import socket
import webbrowser
import json
from pathlib import Path
import re
import time
import hashlib  # Added missing import
import shutil
import math
import customtkinter as ctk
# ==================== INSTALLABLE APPS DATABASE ====================
INSTALLABLE_APPS = {
    # ==================== BROWSERS ====================
    "Brave": {"winget": "Brave.Brave", "category": "Browsers", "description": "Privacy-focused web browser"},
    "Chrome": {"winget": "Google.Chrome", "category": "Browsers", "description": "Google's web browser"},
    "Chromium": {"winget": "Hibbiki.Chromium", "category": "Browsers", "description": "Open-source browser foundation"},
    "Edge": {"winget": "Microsoft.Edge", "category": "Browsers", "description": "Microsoft's modern browser"},
    "Firefox": {"winget": "Mozilla.Firefox", "category": "Browsers", "description": "Mozilla's privacy-focused browser"},
    "Firefox ESR": {"winget": "Mozilla.Firefox.ESR", "category": "Browsers", "description": "Extended Support Release"},
    "Floorp": {"winget": "Ablaze.Floorp", "category": "Browsers", "description": "Firefox-based browser"},
    "LibreWolf": {"winget": "LibreWolf.LibreWolf", "category": "Browsers", "description": "Privacy-focused Firefox fork"},
    "Mullvad Browser": {"winget": "MullvadVPN.MullvadBrowser", "category": "Browsers", "description": "Privacy browser by Mullvad"},
    "Pale Moon": {"winget": "MoonchildProductions.PaleMoon", "category": "Browsers", "description": "Lightweight browser"},
    "Thorium": {"winget": "Alex313031.Thorium.AVX2", "category": "Browsers", "description": "Speed-optimized Chromium"},
    "Tor Browser": {"winget": "TorProject.TorBrowser", "category": "Browsers", "description": "Anonymous browsing"},
    "Ungoogled Chromium": {"winget": "eloston.ungoogled-chromium", "category": "Browsers", "description": "Chromium without Google"},
    "Vivaldi": {"winget": "Vivaldi.Vivaldi", "category": "Browsers", "description": "Customizable browser"},
    "Waterfox": {"winget": "Waterfox.Waterfox", "category": "Browsers", "description": "Privacy-focused Firefox fork"},
    "Zen Browser": {"winget": "Zen-Team.Zen-Browser", "category": "Browsers", "description": "Modern Firefox-based browser"},
    "Falkon": {"winget": "KDE.Falkon", "category": "Browsers", "description": "KDE lightweight browser"},
    
    # ==================== UTILITIES ====================
    "7-Zip": {"winget": "7zip.7zip", "category": "Utilities", "description": "File archiver"},
    "Everything Search": {"winget": "voidtools.Everything", "category": "Utilities", "description": "Fast file search"},
    "CPU-Z": {"winget": "CPUID.CPU-Z", "category": "Utilities", "description": "CPU information"},
    "GPU-Z": {"winget": "TechPowerUp.GPU-Z", "category": "Utilities", "description": "GPU information"},
    "HWiNFO": {"winget": "REALiX.HWiNFO", "category": "Utilities", "description": "Hardware info and monitoring"},
    "HWMonitor": {"winget": "CPUID.HWMonitor", "category": "Utilities", "description": "Hardware monitoring"},
    "Crystal Disk Info": {"winget": "CrystalDewWorld.CrystalDiskInfo", "category": "Utilities", "description": "Disk health monitor"},
    "Crystal Disk Mark": {"winget": "CrystalDewWorld.CrystalDiskMark", "category": "Utilities", "description": "Disk benchmark"},
    "TreeSize Free": {"winget": "JAMSoftware.TreeSize.Free", "category": "Utilities", "description": "Disk space analyzer"},
    "WizTree": {"winget": "AntibodySoftware.WizTree", "category": "Utilities", "description": "Fast disk space analyzer"},
    "SpaceSniffer": {"winget": "UderzoSoftware.SpaceSniffer", "category": "Utilities", "description": "Disk usage visualization"},
    "Revo Uninstaller": {"winget": "RevoUninstaller.RevoUninstaller", "category": "Utilities", "description": "Advanced uninstaller"},
    "Bulk Crap Uninstaller": {"winget": "Klocman.BulkCrapUninstaller", "category": "Utilities", "description": "Batch uninstaller"},
    "Bitwarden": {"winget": "Bitwarden.Bitwarden", "category": "Utilities", "description": "Password manager"},
    "KeePassXC": {"winget": "KeePassXCTeam.KeePassXC", "category": "Utilities", "description": "Offline password manager"},
    "1Password": {"winget": "AgileBits.1Password", "category": "Utilities", "description": "Password manager"},
    "AnyDesk": {"winget": "AnyDesk.AnyDesk", "category": "Utilities", "description": "Remote desktop"},
    "TeamViewer": {"winget": "TeamViewer.TeamViewer", "category": "Utilities", "description": "Remote access"},
    "Parsec": {"winget": "Parsec.Parsec", "category": "Utilities", "description": "Low-latency remote desktop"},
    "Rufus": {"winget": "Rufus.Rufus", "category": "Utilities", "description": "Bootable USB creator"},
    "Raspberry Pi Imager": {"winget": "RaspberryPiFoundation.RaspberryPiImager", "category": "Utilities", "description": "SD card imager"},
    "DDU": {"winget": "Wagnardsoft.DisplayDriverUninstaller", "category": "Utilities", "description": "Display driver uninstaller"},
    "NVCleanstall": {"winget": "TechPowerUp.NVCleanstall", "category": "Utilities", "description": "NVIDIA driver customizer"},
    "MSI Afterburner": {"winget": "Guru3D.Afterburner", "category": "Utilities", "description": "GPU overclocking"},
    "qBittorrent": {"winget": "qBittorrent.qBittorrent", "category": "Utilities", "description": "BitTorrent client"},
    "Transmission": {"winget": "Transmission.Transmission", "category": "Utilities", "description": "Lightweight torrent client"},
    "Deluge": {"winget": "DelugeTeam.Deluge", "category": "Utilities", "description": "BitTorrent client"},
    "Flow Launcher": {"winget": "Flow-Launcher.Flow-Launcher", "category": "Utilities", "description": "Keystroke launcher"},
    "Open Shell": {"winget": "Open-Shell.Open-Shell-Menu", "category": "Utilities", "description": "Start Menu replacement"},
    "F.lux": {"winget": "flux.flux", "category": "Utilities", "description": "Blue light filter"},
    "AutoHotkey": {"winget": "AutoHotkey.AutoHotkey", "category": "Utilities", "description": "Automation scripting"},
    "Barrier": {"winget": "DebaucheeOpenSourceGroup.Barrier", "category": "Utilities", "description": "Software KVM"},
    "CopyQ": {"winget": "hluk.CopyQ", "category": "Utilities", "description": "Clipboard manager"},
    "Ditto": {"winget": "Ditto.Ditto", "category": "Utilities", "description": "Clipboard extension"},
    "TranslucentTB": {"winget": "9PF4KZ2VN4W9", "category": "Utilities", "description": "Taskbar customization"},
    "UniGetUI": {"winget": "MartiCliment.UniGetUI", "category": "Utilities", "description": "Package manager GUI"},
    "Lively Wallpaper": {"winget": "rocksdanister.LivelyWallpaper", "category": "Utilities", "description": "Animated wallpapers"},
    "Rainmeter": {"winget": "Rainmeter.Rainmeter", "category": "Utilities", "description": "Desktop customization"},
    "Quicklook": {"winget": "QL-Win.QuickLook", "category": "Utilities", "description": "macOS-like file preview"},
    "LocalSend": {"winget": "LocalSend.LocalSend", "category": "Utilities", "description": "AirDrop alternative"},
    "Tailscale": {"winget": "tailscale.tailscale", "category": "Utilities", "description": "VPN mesh network"},
    "ZeroTier One": {"winget": "ZeroTier.ZeroTierOne", "category": "Utilities", "description": "Software-defined networking"},
    "Sandboxie Plus": {"winget": "Sandboxie.Plus", "category": "Utilities", "description": "Sandbox isolation"},
    "Oracle VirtualBox": {"winget": "Oracle.VirtualBox", "category": "Utilities", "description": "Virtualization"},
    "Google Drive": {"winget": "Google.GoogleDrive", "category": "Utilities", "description": "Cloud storage sync"},
    "Nextcloud Desktop": {"winget": "Nextcloud.NextcloudDesktop", "category": "Utilities", "description": "Self-hosted cloud sync"},
    "Duplicati": {"winget": "Duplicati.Duplicati", "category": "Utilities", "description": "Backup solution"},
    "Process Lasso": {"winget": "BitSum.ProcessLasso", "category": "Utilities", "description": "Process optimizer"},
    "BleachBit": {"winget": "BleachBit.BleachBit", "category": "Utilities", "description": "System cleaner"},
    "Glary Utilities": {"winget": "Glarysoft.GlaryUtilities", "category": "Utilities", "description": "System optimizer"},
    "DevToys": {"winget": "DevToys-app.DevToys", "category": "Utilities", "description": "Developer utilities"},
    "NanaZip": {"winget": "M2Team.NanaZip", "category": "Utilities", "description": "Modern 7-Zip fork"},
    "PeaZip": {"winget": "Giorgiotani.Peazip", "category": "Utilities", "description": "Archive manager"},
    "WinRAR": {"winget": "RARLab.WinRAR", "category": "Utilities", "description": "Archive manager"},
    "Malwarebytes": {"winget": "Malwarebytes.Malwarebytes", "category": "Utilities", "description": "Anti-malware"},
    "OpenRGB": {"winget": "OpenRGB.OpenRGB", "category": "Utilities", "description": "RGB lighting control"},
    "SignalRGB": {"winget": "WhirlwindFX.SignalRgb", "category": "Utilities", "description": "RGB sync software"},
    "KDE Connect": {"winget": "KDE.KDEConnect", "category": "Utilities", "description": "Phone-PC integration"},
    "Twinkle Tray": {"winget": "xanderfrangos.twinkletray", "category": "Utilities", "description": "Monitor brightness control"},
    "Monitorian": {"winget": "emoacht.Monitorian", "category": "Utilities", "description": "Monitor brightness control"},
    "Snappy Driver Installer Origin": {"winget": "GlennDelahoy.SnappyDriverInstallerOrigin", "category": "Utilities", "description": "Driver updater"},
    "Nilesoft Shell": {"winget": "Nilesoft.Shell", "category": "Utilities", "description": "Context menu extension"},
    "OpenHashTab": {"winget": "namazso.OpenHashTab", "category": "Utilities", "description": "File hash checker"},
    "LockHunter": {"winget": "CrystalRich.LockHunter", "category": "Utilities", "description": "File unlocker"},
    "Total Commander": {"winget": "Ghisler.TotalCommander", "category": "Utilities", "description": "File manager"},
    "Alacritty": {"winget": "Alacritty.Alacritty", "category": "Utilities", "description": "Fast terminal"},
    "Tabby": {"winget": "Eugeny.Tabby", "category": "Utilities", "description": "Modern terminal"},
    "Nushell": {"winget": "Nushell.Nushell", "category": "Utilities", "description": "Modern shell"},
    "Gsudo": {"winget": "gerardog.gsudo", "category": "Utilities", "description": "Windows sudo"},
    "SuperF4": {"winget": "StefanSundin.Superf4", "category": "Utilities", "description": "Force kill apps"},
    "MSEdgeRedirect": {"winget": "rcmaehl.MSEdgeRedirect", "category": "Utilities", "description": "Redirect Edge links"},
    "Windows Firewall Control": {"winget": "BiniSoft.WindowsFirewallControl", "category": "Utilities", "description": "Firewall GUI"},
    "Auto Dark Mode": {"winget": "Armin2208.WindowsAutoNightMode", "category": "Utilities", "description": "Auto light/dark theme"},
    "GlazeWM": {"winget": "glzr-io.glazewm", "category": "Utilities", "description": "Tiling window manager"},
    "FanControl": {"winget": "Rem0o.FanControl", "category": "Utilities", "description": "Fan speed control"},
    "Windhawk": {"winget": "RamenSoftware.Windhawk", "category": "Utilities", "description": "Windows customization"},
    "WinPaletter": {"winget": "Abdelrhman-AK.WinPaletter", "category": "Utilities", "description": "Windows color customizer"},
    "OFGB": {"winget": "xM4ddy.OFGB", "category": "Utilities", "description": "Windows 11 ad remover"},
    "Lenovo Legion Toolkit": {"winget": "BartoszCichecki.LenovoLegionToolkit", "category": "Utilities", "description": "Legion laptop utility"},
    "Dropbox": {"winget": "Dropbox.Dropbox", "category": "Utilities", "description": "Cloud storage"},
    "OrcaSlicer": {"winget": "SoftFever.OrcaSlicer", "category": "Utilities", "description": "3D printer slicer"},
    "PrusaSlicer": {"winget": "Prusa3d.PrusaSlicer", "category": "Utilities", "description": "3D printer slicer"},
    "Windows PC Health Check": {"winget": "Microsoft.WindowsPCHealthCheck", "category": "Utilities", "description": "Win11 compatibility check"},
    "Xtreme Download Manager": {"winget": "subhra74.XtremeDownloadManager", "category": "Utilities", "description": "Download manager"},
    "JDownloader": {"winget": "AppWork.JDownloader", "category": "Utilities", "description": "Download manager"},
    "Motrix": {"winget": "agalwood.Motrix", "category": "Utilities", "description": "Download manager"},
    "SyncTrayzor": {"winget": "GermanCoding.SyncTrayzor", "category": "Utilities", "description": "Syncthing tray app"},
    "Fastfetch": {"winget": "Fastfetch-cli.Fastfetch", "category": "Utilities", "description": "System info display"},
    "Neofetch Win": {"winget": "nepnep.neofetch-win", "category": "Utilities", "description": "System info display"},
    "Link Shell Extension": {"winget": "HermannSchinagl.LinkShellExtension", "category": "Utilities", "description": "Symbolic link creator"},
    "Espanso": {"winget": "Espanso.Espanso", "category": "Utilities", "description": "Text expander"},
    "Carnac": {"winget": "code52.Carnac", "category": "Utilities", "description": "Keystroke visualizer"},
    "Meld": {"winget": "Meld.Meld", "category": "Utilities", "description": "Visual diff tool"},
    "XnView": {"winget": "XnSoft.XnView.Classic", "category": "Utilities", "description": "Image viewer"},
    "JPEG View": {"winget": "sylikc.JPEGView", "category": "Utilities", "description": "Fast image viewer"},
    "Zoxide": {"winget": "ajeetdsouza.zoxide", "category": "Utilities", "description": "Smarter cd command"},
    "Bat": {"winget": "sharkdp.bat", "category": "Utilities", "description": "Cat alternative"},
    "Ripgrep": {"winget": "BurntSushi.ripgrep.MSVC", "category": "Utilities", "description": "Fast grep tool"},
    "Fzf": {"winget": "junegunn.fzf", "category": "Utilities", "description": "Fuzzy finder"},
    "TeraCopy": {"winget": "CodeSector.TeraCopy", "category": "Utilities", "description": "Fast file copy"},
    "WizFile": {"winget": "AntibodySoftware.WizFile", "category": "Utilities", "description": "Fast file search"},
    "SageThumbs": {"winget": "CherubicSoftware.SageThumbs", "category": "Utilities", "description": "Enhanced thumbnails"},
    "Wise Program Uninstaller": {"winget": "WiseCleaner.WiseProgramUninstaller", "category": "Utilities", "description": "Program uninstaller"},
    "WiseToys": {"winget": "WiseCleaner.WiseToys", "category": "Utilities", "description": "Windows utilities collection"},
    "TightVNC": {"winget": "GlavSoft.TightVNC", "category": "Utilities", "description": "VNC server/client"},
    "UltraVNC": {"winget": "uvncbvba.UltraVnc", "category": "Utilities", "description": "VNC remote desktop"},
    "Dual Monitor Tools": {"winget": "GNE.DualMonitorTools", "category": "Utilities", "description": "Multi-monitor utilities"},
    "Borderless Gaming": {"winget": "Codeusa.BorderlessGaming", "category": "Utilities", "description": "Window borderless mode"},
    "Compact GUI": {"winget": "IridiumIO.CompactGUI", "category": "Utilities", "description": "Folder compression"},
    "ExifCleaner": {"winget": "szTheory.exifcleaner", "category": "Utilities", "description": "Metadata remover"},
    "CapFrameX": {"winget": "CXWorld.CapFrameX", "category": "Utilities", "description": "Frame time analysis"},
    "Intel PresentMon": {"winget": "Intel.PresentMon.Beta", "category": "Utilities", "description": "Gaming performance overlay"},
    "Ente Auth": {"winget": "ente-io.auth-desktop", "category": "Utilities", "description": "2FA authenticator"},
    "Proton Authenticator": {"winget": "Proton.ProtonAuthenticator", "category": "Utilities", "description": "Proton 2FA app"},
    "Wazuh": {"winget": "Wazuh.WazuhAgent", "category": "Utilities", "description": "Security monitoring"},
    "File Converter": {"winget": "AdrienAllard.FileConverter", "category": "Utilities", "description": "Context menu converter"},
    "OPAutoClicker": {"winget": "OPAutoClicker.OPAutoClicker", "category": "Utilities", "description": "Auto clicker"},
    "VistaSwitcher": {"winget": "ntwind.VistaSwitcher", "category": "Utilities", "description": "Alt-Tab replacement"},
    "Ambie White Noise": {"winget": "9P07XNM5CHP0", "category": "Utilities", "description": "White noise app"},
    "Magic Wormhole": {"winget": "magic-wormhole.magic-wormhole", "category": "Utilities", "description": "Secure file transfer"},
    "croc": {"winget": "schollz.croc", "category": "Utilities", "description": "Secure file transfer"},
    "JoyToKey": {"winget": "JTKsoftware.JoyToKey", "category": "Utilities", "description": "Controller to keyboard"},
    "ForceAutoHDR": {"winget": "ForceAutoHDR.7gxycn08", "category": "Utilities", "description": "Force Auto HDR"},
    "Syncthingtray": {"winget": "Martchus.syncthingtray", "category": "Utilities", "description": "Syncthing tray app"},
    "Spacedrive": {"winget": "spacedrive.Spacedrive", "category": "Utilities", "description": "Cross-platform file manager"},
    "HxD Hex Editor": {"winget": "MHNexus.HxD", "category": "Utilities", "description": "Hex editor"},
    "Bulk Rename Utility": {"winget": "TGRMNSoftware.BulkRenameUtility", "category": "Utilities", "description": "Batch rename files"},
    "Advanced Renamer": {"winget": "HulubuluSoftware.AdvancedRenamer", "category": "Utilities", "description": "Batch rename files"},
    
    # ==================== DEVELOPMENT ====================
    "VS Code": {"winget": "Microsoft.VisualStudioCode", "category": "Development", "description": "Code editor"},
    "VS Codium": {"winget": "VSCodium.VSCodium", "category": "Development", "description": "Open-source VS Code"},
    "Visual Studio 2022": {"winget": "Microsoft.VisualStudio.2022.Community", "category": "Development", "description": "Full IDE"},
    "Sublime Text": {"winget": "SublimeHQ.SublimeText.4", "category": "Development", "description": "Text editor"},
    "Sublime Merge": {"winget": "SublimeHQ.SublimeMerge", "category": "Development", "description": "Git client"},
    "Neovim": {"winget": "Neovim.Neovim", "category": "Development", "description": "Modern Vim"},
    "Helix": {"winget": "Helix.Helix", "category": "Development", "description": "Post-modern text editor"},
    "Zed": {"winget": "Zed.Zed", "category": "Development", "description": "High-performance editor"},
    "Pulsar": {"winget": "Pulsar-Edit.Pulsar", "category": "Development", "description": "Community-led text editor"},
    "Git": {"winget": "Git.Git", "category": "Development", "description": "Version control"},
    "GitHub Desktop": {"winget": "GitHub.GitHubDesktop", "category": "Development", "description": "GitHub GUI client"},
    "GitHub CLI": {"winget": "GitHub.cli", "category": "Development", "description": "GitHub CLI"},
    "GitKraken": {"winget": "Axosoft.GitKraken", "category": "Development", "description": "Git GUI"},
    "Git Extensions": {"winget": "GitExtensionsTeam.GitExtensions", "category": "Development", "description": "Git GUI"},
    "Git Butler": {"winget": "GitButler.GitButler", "category": "Development", "description": "Modern Git client"},
    "Fork": {"winget": "Fork.Fork", "category": "Development", "description": "Fast Git client"},
    "Gitify": {"winget": "Gitify.Gitify", "category": "Development", "description": "GitHub notifications"},
    "Lazygit": {"winget": "JesseDuffield.lazygit", "category": "Development", "description": "Terminal Git UI"},
    "Docker Desktop": {"winget": "Docker.DockerDesktop", "category": "Development", "description": "Container platform"},
    "Python3": {"winget": "Python.Python.3.14", "category": "Development", "description": "Python language"},
    "Anaconda": {"winget": "Anaconda.Anaconda3", "category": "Development", "description": "Python distribution"},
    "Miniconda": {"winget": "Anaconda.Miniconda3", "category": "Development", "description": "Minimal conda"},
    "Pixi": {"winget": "prefix-dev.pixi", "category": "Development", "description": "Fast package manager"},
    "NodeJS": {"winget": "OpenJS.NodeJS", "category": "Development", "description": "JavaScript runtime"},
    "NodeJS LTS": {"winget": "OpenJS.NodeJS.LTS", "category": "Development", "description": "LTS Node version"},
    "NVM for Windows": {"winget": "CoreyButler.NVMforWindows", "category": "Development", "description": "Node version manager"},
    "Fast Node Manager": {"winget": "Schniz.fnm", "category": "Development", "description": "Fast Node manager"},
    "Yarn": {"winget": "Yarn.Yarn", "category": "Development", "description": "JS package manager"},
    "Rust": {"winget": "Rustlang.Rust.MSVC", "category": "Development", "description": "Rust language"},
    "Go": {"winget": "GoLang.Go", "category": "Development", "description": "Go language"},
    "Swift": {"winget": "Swift.Toolchain", "category": "Development", "description": "Swift language"},
    "CMake": {"winget": "Kitware.CMake", "category": "Development", "description": "Build system"},
    "Clink": {"winget": "chrisant996.Clink", "category": "Development", "description": "CMD enhancement"},
    "Corretto 8": {"winget": "Amazon.Corretto.8.JDK", "category": "Development", "description": "Java 8 JDK"},
    "Corretto 11": {"winget": "Amazon.Corretto.11.JDK", "category": "Development", "description": "Java 11 JDK"},
    "Corretto 17": {"winget": "Amazon.Corretto.17.JDK", "category": "Development", "description": "Java 17 JDK"},
    "Corretto 21": {"winget": "Amazon.Corretto.21.JDK", "category": "Development", "description": "Java 21 JDK"},
    "Eclipse Temurin": {"winget": "EclipseAdoptium.Temurin.21.JDK", "category": "Development", "description": "OpenJDK distribution"},
    "JetBrains Toolbox": {"winget": "JetBrains.Toolbox", "category": "Development", "description": "JetBrains tool manager"},
    "Postman": {"winget": "Postman.Postman", "category": "Development", "description": "API development"},
    "Oh My Posh": {"winget": "JanDeDobbeleer.OhMyPosh", "category": "Development", "description": "Shell prompt"},
    "Starship": {"winget": "starship", "category": "Development", "description": "Cross-shell prompt"},
    "Wezterm": {"winget": "wez.wezterm", "category": "Development", "description": "GPU terminal"},
    "Godot Engine": {"winget": "GodotEngine.GodotEngine", "category": "Development", "description": "Game engine"},
    "Unity Hub": {"winget": "Unity.UnityHub", "category": "Development", "description": "Unity game engine"},
    "Vagrant": {"winget": "Hashicorp.Vagrant", "category": "Development", "description": "Virtual environments"},
    "DaxStudio": {"winget": "DaxStudio.DaxStudio", "category": "Development", "description": "DAX query tool"},
    "Thonny": {"winget": "AivarAnnamaa.Thonny", "category": "Development", "description": "Python IDE for beginners"},
    "Mu Editor": {"winget": "Mu.Mu", "category": "Development", "description": "Python editor"},
    "Aegisub": {"winget": "Aegisub.Aegisub", "category": "Development", "description": "Subtitle editor"},
    
    # ==================== MULTIMEDIA TOOLS ====================
    "VLC": {"winget": "VideoLAN.VLC", "category": "Multimedia Tools", "description": "Media player"},
    "Media Player Classic": {"winget": "clsid2.mpc-hc", "category": "Multimedia Tools", "description": "Classic media player"},
    "OBS Studio": {"winget": "OBSProject.OBSStudio", "category": "Multimedia Tools", "description": "Streaming/recording"},
    "HandBrake": {"winget": "HandBrake.HandBrake", "category": "Multimedia Tools", "description": "Video transcoder"},
    "GIMP": {"winget": "GIMP.GIMP.3", "category": "Multimedia Tools", "description": "Image editor"},
    "Inkscape": {"winget": "Inkscape.Inkscape", "category": "Multimedia Tools", "description": "Vector graphics"},
    "Krita": {"winget": "KDE.Krita", "category": "Multimedia Tools", "description": "Digital painting"},
    "Paint.NET": {"winget": "dotPDN.PaintDotNet", "category": "Multimedia Tools", "description": "Image editor"},
    "Blender": {"winget": "BlenderFoundation.Blender", "category": "Multimedia Tools", "description": "3D creation suite"},
    "FreeCAD": {"winget": "FreeCAD.FreeCAD", "category": "Multimedia Tools", "description": "3D CAD modeler"},
    "OpenSCAD": {"winget": "OpenSCAD.OpenSCAD", "category": "Multimedia Tools", "description": "Script-based 3D CAD"},
    "Audacity": {"winget": "Audacity.Audacity", "category": "Multimedia Tools", "description": "Audio editor"},
    "Kdenlive": {"winget": "KDE.Kdenlive", "category": "Multimedia Tools", "description": "Video editor"},
    "Shotcut": {"winget": "Meltytech.Shotcut", "category": "Multimedia Tools", "description": "Video editor"},
    "ShareX": {"winget": "ShareX.ShareX", "category": "Multimedia Tools", "description": "Screenshot tool"},
    "Flameshot": {"winget": "Flameshot.Flameshot", "category": "Multimedia Tools", "description": "Screenshot tool"},
    "Greenshot": {"winget": "Greenshot.Greenshot", "category": "Multimedia Tools", "description": "Screenshot tool"},
    "Lightshot": {"winget": "Skillbrains.Lightshot", "category": "Multimedia Tools", "description": "Screenshot tool"},
    "ImageGlass": {"winget": "DuongDieuPhap.ImageGlass", "category": "Multimedia Tools", "description": "Image viewer"},
    "darktable": {"winget": "darktable.darktable", "category": "Multimedia Tools", "description": "Photo editor"},
    "digiKam": {"winget": "KDE.digikam", "category": "Multimedia Tools", "description": "Photo manager"},
    "Fire Alpaca": {"winget": "FireAlpaca.FireAlpaca", "category": "Multimedia Tools", "description": "Digital painting"},
    "FFmpeg": {"winget": "Gyan.FFmpeg", "category": "Multimedia Tools", "description": "Multimedia framework"},
    "Plex Media Server": {"winget": "Plex.PlexMediaServer", "category": "Multimedia Tools", "description": "Media server"},
    "Plex Desktop": {"winget": "Plex.Plex", "category": "Multimedia Tools", "description": "Plex client"},
    "Jellyfin Server": {"winget": "Jellyfin.Server", "category": "Multimedia Tools", "description": "Open-source media server"},
    "Jellyfin Media Player": {"winget": "Jellyfin.JellyfinMediaPlayer", "category": "Multimedia Tools", "description": "Jellyfin client"},
    "Kodi": {"winget": "XBMCFoundation.Kodi", "category": "Multimedia Tools", "description": "Media center"},
    "Stremio": {"winget": "Stremio.Stremio", "category": "Multimedia Tools", "description": "Stream organizer"},
    "AIMP": {"winget": "AIMP.AIMP", "category": "Multimedia Tools", "description": "Music player"},
    "foobar2000": {"winget": "PeterPawlowski.foobar2000", "category": "Multimedia Tools", "description": "Music player"},
    "MusicBee": {"winget": "MusicBee.MusicBee", "category": "Multimedia Tools", "description": "Music player"},
    "Clementine": {"winget": "Clementine.Clementine", "category": "Multimedia Tools", "description": "Music player"},
    "Strawberry": {"winget": "StrawberryMusicPlayer.Strawberry", "category": "Multimedia Tools", "description": "Music player"},
    "Harmonoid": {"winget": "Harmonoid.Harmonoid", "category": "Multimedia Tools", "description": "Music player"},
    "iTunes": {"winget": "Apple.iTunes", "category": "Multimedia Tools", "description": "Apple media player"},
    "EarTrumpet": {"winget": "File-New-Project.EarTrumpet", "category": "Multimedia Tools", "description": "Audio control"},
    "Voicemeeter": {"winget": "VB-Audio.Voicemeeter", "category": "Multimedia Tools", "description": "Virtual audio mixer"},
    "Voicemeeter Potato": {"winget": "VB-Audio.Voicemeeter.Potato", "category": "Multimedia Tools", "description": "Advanced audio mixer"},
    "FxSound": {"winget": "FxSound.FxSound", "category": "Multimedia Tools", "description": "Audio enhancer"},
    "K-Lite Codec Pack": {"winget": "CodecGuide.K-LiteCodecPack.Standard", "category": "Multimedia Tools", "description": "Media codecs"},
    "ImgBurn": {"winget": "LIGHTNINGUK.ImgBurn", "category": "Multimedia Tools", "description": "Disc burning"},
    "MuseScore": {"winget": "Musescore.Musescore", "category": "Multimedia Tools", "description": "Music notation"},
    "Mp3tag": {"winget": "Mp3tag.Mp3tag", "category": "Multimedia Tools", "description": "Audio metadata editor"},
    "TagScanner": {"winget": "SergeySerkov.TagScanner", "category": "Multimedia Tools", "description": "Audio tag editor"},
    "nomacs": {"winget": "nomacs.nomacs", "category": "Multimedia Tools", "description": "Image viewer"},
    "nGlide": {"winget": "ZeusSoftware.nGlide", "category": "Multimedia Tools", "description": "3Dfx Glide wrapper"},
    "Modern Flyouts": {"winget": "ModernFlyouts.ModernFlyouts", "category": "Multimedia Tools", "description": "Modern volume flyout"},
    "Tidal": {"winget": "9NNCB5BS59PH", "category": "Multimedia Tools", "description": "Hi-Fi streaming"},
    "Videomass": {"winget": "GianlucaPernigotto.Videomass", "category": "Multimedia Tools", "description": "FFmpeg GUI"},
    "Yt-dlp": {"winget": "yt-dlp.yt-dlp", "category": "Multimedia Tools", "description": "Video downloader"},
    "QGIS": {"winget": "OSGeo.QGIS", "category": "Multimedia Tools", "description": "GIS software"},
    "SMPlayer": {"winget": "SMPlayer.SMPlayer", "category": "Multimedia Tools", "description": "Media player"},
    "NDI Tools": {"winget": "NDI.NDITools", "category": "Multimedia Tools", "description": "Video over IP"},
    "KiCad": {"winget": "KiCad.KiCad", "category": "Multimedia Tools", "description": "EDA software"},
    "Subtitle Edit": {"winget": "Nikse.SubtitleEdit", "category": "Multimedia Tools", "description": "Subtitle editor"},
    
    # ==================== COMMUNICATIONS ====================
    "Discord": {"winget": "Discord.Discord", "category": "Communications", "description": "Chat platform"},
    "Vesktop": {"winget": "Vencord.Vesktop", "category": "Communications", "description": "Enhanced Discord"},
    "Slack": {"winget": "SlackTechnologies.Slack", "category": "Communications", "description": "Team collaboration"},
    "Teams": {"winget": "Microsoft.Teams", "category": "Communications", "description": "Microsoft Teams"},
    "Zoom": {"winget": "Zoom.Zoom", "category": "Communications", "description": "Video conferencing"},
    "Telegram": {"winget": "Telegram.TelegramDesktop", "category": "Communications", "description": "Messaging app"},
    "Unigram": {"winget": "Telegram.Unigram", "category": "Communications", "description": "Telegram for Windows"},
    "Signal": {"winget": "OpenWhisperSystems.Signal", "category": "Communications", "description": "Secure messaging"},
    "Element": {"winget": "Element.Element", "category": "Communications", "description": "Matrix client"},
    "Session": {"winget": "Session.Session", "category": "Communications", "description": "Private messaging"},
    "Revolt": {"winget": "Revolt.RevoltDesktop", "category": "Communications", "description": "Discord alternative"},
    "Beeper": {"winget": "Beeper.Beeper", "category": "Communications", "description": "Universal chat app"},
    "Ferdium": {"winget": "Ferdium.Ferdium", "category": "Communications", "description": "Multi-messenger"},
    "Thunderbird": {"winget": "Mozilla.Thunderbird", "category": "Communications", "description": "Email client"},
    "Betterbird": {"winget": "Betterbird.Betterbird", "category": "Communications", "description": "Thunderbird fork"},
    "Viber": {"winget": "Rakuten.Viber", "category": "Communications", "description": "Messaging app"},
    "Hexchat": {"winget": "HexChat.HexChat", "category": "Communications", "description": "IRC client"},
    "Jami": {"winget": "SFLinux.Jami", "category": "Communications", "description": "VoIP service"},
    "Linphone": {"winget": "BelledonneCommunications.Linphone", "category": "Communications", "description": "VoIP app"},
    "QTox": {"winget": "Tox.qTox", "category": "Communications", "description": "P2P messaging"},
    "Chatterino": {"winget": "ChatterinoTeam.Chatterino", "category": "Communications", "description": "Twitch chat client"},
    "Zulip": {"winget": "Zulip.Zulip", "category": "Communications", "description": "Team chat"},
    
    # ==================== GAMES ====================
    "Steam": {"winget": "Valve.Steam", "category": "Games", "description": "Gaming platform"},
    "Epic Games Launcher": {"winget": "EpicGames.EpicGamesLauncher", "category": "Games", "description": "Epic Games store"},
    "GOG Galaxy": {"winget": "GOG.Galaxy", "category": "Games", "description": "GOG game client"},
    "EA App": {"winget": "ElectronicArts.EADesktop", "category": "Games", "description": "EA gaming platform"},
    "Ubisoft Connect": {"winget": "Ubisoft.Connect", "category": "Games", "description": "Ubisoft launcher"},
    "Heroic Games Launcher": {"winget": "HeroicGamesLauncher.HeroicGamesLauncher", "category": "Games", "description": "Epic Games alternative"},
    "Itch.io": {"winget": "ItchIo.Itch", "category": "Games", "description": "Indie game platform"},
    "Playnite": {"winget": "Playnite.Playnite", "category": "Games", "description": "Game library manager"},
    "Prism Launcher": {"winget": "PrismLauncher.PrismLauncher", "category": "Games", "description": "Minecraft launcher"},
    "GeForce NOW": {"winget": "Nvidia.GeForceNow", "category": "Games", "description": "Cloud gaming"},
    "Moonlight": {"winget": "MoonlightGameStreamingProject.Moonlight", "category": "Games", "description": "Game streaming client"},
    "Sunshine": {"winget": "LizardByte.Sunshine", "category": "Games", "description": "Game streaming server"},
    "PS Remote Play": {"winget": "PlayStation.PSRemotePlay", "category": "Games", "description": "PlayStation streaming"},
    "Virtual Desktop Streamer": {"winget": "VirtualDesktop.Streamer", "category": "Games", "description": "VR streaming"},
    "SideQuestVR": {"winget": "SideQuestVR.SideQuest", "category": "Games", "description": "VR app sideloader"},
    "TCNO Account Switcher": {"winget": "TechNobo.TcNoAccountSwitcher", "category": "Games", "description": "Game account switcher"},
    "Clone Hero": {"winget": "CloneHeroTeam.CloneHero", "category": "Games", "description": "Guitar Hero clone"},
    "Cemu": {"winget": "Cemu.Cemu", "category": "Games", "description": "Wii U emulator"},
    "XEMU": {"winget": "xemu-project.xemu", "category": "Games", "description": "Xbox emulator"},
    "Emulation Station": {"winget": "Emulationstation.Emulationstation", "category": "Games", "description": "Emulator frontend"},
    
    # ==================== MICROSOFT TOOLS ====================
    ".NET Runtime 3.1": {"winget": "Microsoft.DotNet.DesktopRuntime.3_1", "category": "Microsoft Tools", "description": ".NET 3.1 runtime"},
    ".NET Runtime 5": {"winget": "Microsoft.DotNet.DesktopRuntime.5", "category": "Microsoft Tools", "description": ".NET 5 runtime"},
    ".NET Runtime 6": {"winget": "Microsoft.DotNet.DesktopRuntime.6", "category": "Microsoft Tools", "description": ".NET 6 runtime"},
    ".NET Runtime 7": {"winget": "Microsoft.DotNet.DesktopRuntime.7", "category": "Microsoft Tools", "description": ".NET 7 runtime"},
    ".NET Runtime 8": {"winget": "Microsoft.DotNet.DesktopRuntime.8", "category": "Microsoft Tools", "description": ".NET 8 runtime"},
    ".NET Runtime 9": {"winget": "Microsoft.DotNet.DesktopRuntime.9", "category": "Microsoft Tools", "description": ".NET 9 runtime"},
    "VC++ 2015-2022 x86": {"winget": "Microsoft.VCRedist.2015+.x86", "category": "Microsoft Tools", "description": "Visual C++ runtime"},
    "VC++ 2015-2022 x64": {"winget": "Microsoft.VCRedist.2015+.x64", "category": "Microsoft Tools", "description": "Visual C++ runtime"},
    "PowerShell 7": {"winget": "Microsoft.PowerShell", "category": "Microsoft Tools", "description": "Modern PowerShell"},
    "PowerToys": {"winget": "Microsoft.PowerToys", "category": "Microsoft Tools", "description": "Power user utilities"},
    "Windows Terminal": {"winget": "Microsoft.WindowsTerminal", "category": "Microsoft Tools", "description": "Modern terminal"},
    "OneDrive": {"winget": "Microsoft.OneDrive", "category": "Microsoft Tools", "description": "Cloud storage"},
    "Azure Data Studio": {"winget": "Microsoft.AzureDataStudio", "category": "Microsoft Tools", "description": "Data management"},
    "SQL Server Management Studio": {"winget": "Microsoft.SQLServerManagementStudio", "category": "Microsoft Tools", "description": "SQL database management"},
    "Power Automate Desktop": {"winget": "Microsoft.PowerAutomateDesktop", "category": "Microsoft Tools", "description": "Desktop automation"},
    "Power BI": {"winget": "Microsoft.PowerBI", "category": "Microsoft Tools", "description": "Data visualization"},
    "NuGet": {"winget": "Microsoft.NuGet", "category": "Microsoft Tools", "description": ".NET package manager"},
    "Autoruns": {"winget": "Microsoft.Sysinternals.Autoruns", "category": "Microsoft Tools", "description": "Startup manager"},
    "Process Monitor": {"winget": "Microsoft.Sysinternals.ProcessMonitor", "category": "Microsoft Tools", "description": "Process monitor"},
    "TCPView": {"winget": "Microsoft.Sysinternals.TCPView", "category": "Microsoft Tools", "description": "Network monitoring"},
    "ZoomIt": {"winget": "Microsoft.Sysinternals.ZoomIt", "category": "Microsoft Tools", "description": "Screen zoom tool"},
    "RDCMan": {"winget": "Microsoft.Sysinternals.RDCMan", "category": "Microsoft Tools", "description": "Remote Desktop manager"},
    "DISMTools": {"winget": "CodingWondersSoftware.DISMTools.Stable", "category": "Microsoft Tools", "description": "DISM GUI"},
    "NTLite": {"winget": "Nlitesoft.NTLite", "category": "Microsoft Tools", "description": "Windows customizer"},
    
    # ==================== PRO TOOLS ====================
    "PuTTY": {"winget": "PuTTY.PuTTY", "category": "Pro Tools", "description": "SSH/Telnet client"},
    "WinSCP": {"winget": "WinSCP.WinSCP", "category": "Pro Tools", "description": "SFTP/FTP client"},
    "mRemoteNG": {"winget": "mRemoteNG.mRemoteNG", "category": "Pro Tools", "description": "Remote connections manager"},
    "RustDesk": {"winget": "RustDesk.RustDesk", "category": "Pro Tools", "description": "Remote desktop"},
    "Advanced IP Scanner": {"winget": "Famatech.AdvancedIPScanner", "category": "Pro Tools", "description": "Network scanner"},
    "Angry IP Scanner": {"winget": "angryziber.AngryIPScanner", "category": "Pro Tools", "description": "Network scanner"},
    "Nmap": {"winget": "Insecure.Nmap", "category": "Pro Tools", "description": "Network scanner"},
    "Wireshark": {"winget": "WiresharkFoundation.Wireshark", "category": "Pro Tools", "description": "Network analyzer"},
    "HeidiSQL": {"winget": "HeidiSQL.HeidiSQL", "category": "Pro Tools", "description": "Database client"},
    "Simplewall": {"winget": "Henry++.simplewall", "category": "Pro Tools", "description": "Firewall"},
    "Portmaster": {"winget": "Safing.Portmaster", "category": "Pro Tools", "description": "Application firewall"},
    "WireGuard": {"winget": "WireGuard.WireGuard", "category": "Pro Tools", "description": "VPN protocol"},
    "OpenVPN Connect": {"winget": "OpenVPNTechnologies.OpenVPNConnect", "category": "Pro Tools", "description": "VPN client"},
    "Mullvad VPN": {"winget": "MullvadVPN.MullvadVPN", "category": "Pro Tools", "description": "VPN service"},
    "NetBird": {"winget": "netbird", "category": "Pro Tools", "description": "VPN mesh network"},
    "Ventoy": {"winget": "Ventoy.Ventoy", "category": "Pro Tools", "description": "Multi-boot USB creator"},
    "EFI Boot Editor": {"winget": "EFIBootEditor.EFIBootEditor", "category": "Pro Tools", "description": "EFI boot manager"},
    "XPipe": {"winget": "xpipe-io.xpipe", "category": "Pro Tools", "description": "Container orchestration"},
    
    # ==================== DOCUMENT ====================
    "LibreOffice": {"winget": "TheDocumentFoundation.LibreOffice", "category": "Document", "description": "Office suite"},
    "ONLYOffice": {"winget": "ONLYOFFICE.DesktopEditors", "category": "Document", "description": "Office suite"},
    "Notepad++": {"winget": "Notepad++.Notepad++", "category": "Document", "description": "Code editor"},
    "Obsidian": {"winget": "Obsidian.Obsidian", "category": "Document", "description": "Knowledge base"},
    "Joplin": {"winget": "Joplin.Joplin", "category": "Document", "description": "Note-taking app"},
    "Logseq": {"winget": "Logseq.Logseq", "category": "Document", "description": "Outliner notes"},
    "Simplenote": {"winget": "Automattic.Simplenote", "category": "Document", "description": "Simple notes"},
    "massCode": {"winget": "antonreshetov.massCode", "category": "Document", "description": "Snippet manager"},
    "Anki": {"winget": "Anki.Anki", "category": "Document", "description": "Flashcard app"},
    "Calibre": {"winget": "calibre.calibre", "category": "Document", "description": "E-book manager"},
    "AFFiNE": {"winget": "ToEverything.AFFiNE", "category": "Document", "description": "Notion alternative"},
    "Adobe Acrobat Reader": {"winget": "Adobe.Acrobat.Reader.64-bit", "category": "Document", "description": "PDF reader"},
    "Foxit PDF Reader": {"winget": "Foxit.FoxitReader", "category": "Document", "description": "PDF reader"},
    "Foxit PDF Editor": {"winget": "Foxit.PhantomPDF", "category": "Document", "description": "PDF editor"},
    "Sumatra PDF": {"winget": "SumatraPDF.SumatraPDF", "category": "Document", "description": "Lightweight PDF reader"},
    "PDFgear": {"winget": "PDFgear.PDFgear", "category": "Document", "description": "PDF tool"},
    "PDF24 Creator": {"winget": "geeksoftwareGmbH.PDF24Creator", "category": "Document", "description": "PDF tools"},
    "PDFsam Basic": {"winget": "PDFsam.PDFsam", "category": "Document", "description": "PDF split/merge"},
    "Okular": {"winget": "KDE.Okular", "category": "Document", "description": "Document viewer"},
    "NAPS2": {"winget": "Cyanfish.NAPS2", "category": "Document", "description": "Document scanner"},
    "WinMerge": {"winget": "WinMerge.WinMerge", "category": "Document", "description": "Diff/merge tool"},
    "Zim Desktop Wiki": {"winget": "Zimwiki.Zim", "category": "Document", "description": "Desktop wiki"},
    "Znote": {"winget": "alagrede.znote", "category": "Document", "description": "Note-taking"},
    "Xournal++": {"winget": "Xournal++.Xournal++", "category": "Document", "description": "Handwriting notes"},
    "Zotero": {"winget": "DigitalScholar.Zotero", "category": "Document", "description": "Research manager"},
}

# Helper functions for the app database
def get_apps_by_category():
    """Returns a dictionary of apps organized by category"""
    categories = {}
    for app_name, app_data in INSTALLABLE_APPS.items():
        category = app_data["category"]
        if category not in categories:
            categories[category] = []
        categories[category].append({
            "name": app_name,
            "winget": app_data["winget"],
            "description": app_data["description"]
        })
    for category in categories:
        categories[category].sort(key=lambda x: x["name"])
    return categories

def get_categories():
    """Returns a sorted list of all categories"""
    categories = set()
    for app_data in INSTALLABLE_APPS.values():
        categories.add(app_data["category"])
    return sorted(categories)


# Constants for hiding console windows
CREATE_NO_WINDOW = 0x08000000

# ==================== STORAGESENSE MODULE ====================
# This module provides an advanced disk scanner UI, merged for single-EXE deployment.

# --- StorageSense Styling and Constants ---
SS_COLOR_LARGE = "#E74C3C"  # Red for very large
SS_COLOR_MEDIUM = "#F39C12" # Orange for medium-large
SS_COLOR_CORE = "#3498DB"   # Blue for Windows core files
SS_THRESHOLD_GB = 1.0
SS_THRESHOLD_MB = 100.0

# --- StorageSense File Hints Database ---
SS_HINTS = {
    "pagefile.sys": "Windows Virtual Memory - Crucial for system stability.",
    "hiberfil.sys": "Hibernate Data - Saves state when sleeping.",
    "swapfile.sys": "Universal App Swap Space - Similar to pagefile.",
    "ntuser.dat": "User Settings Hive - Critical system registry file.",
    "dll": "System Library - Contains code used by multiple programs.",
    "sys": "System Driver - Hardware or software driver file.",
    "cab": "Windows Cabinet File - Used for updates and installations.",
    "log": "Log File - Recording of program activity. Often safe to delete.",
    "dmp": "Crash Dump - Data from a system crash. Safe to delete.",
    "vmdk": "Virtual Machine Drive - Contains a whole virtual computer.",
    "vhdx": "Virtual Machine Drive - Windows native virtual disk format.",
    "vhd": "Virtual Hard Disk - Older virtual machine drive format.",
    "iso": "Disk Image - Often an installer or backup of a physical disk.",
    "img": "Disk Image - Raw data from a disk or partition.",
    "pak": "Game Data Archive - Contains models, textures, and sounds.",
    "bundle": "Unity Data Bundle - Asset package for game engines.",
    "obb": "Android Expansion File - Large game data for mobile ports.",
    "unity3d": "Unity Engine Asset - 3D assets and game logic.",
    "rpf": "Rockstar Game File - Massive game asset container (GTA/RDR).",
    "workshop": "Steam Workshop - Downloaded mod or custom content.",
    "mp4": "Video File - High definition video data.",
    "mkv": "Video File - High quality video container.",
    "mov": "QuickTime Video - Apple media format.",
    "wav": "Uncompressed Audio - Large, high-quality sound file.",
    "flac": "Lossless Audio - High quality sound with some compression.",
    "tmp": "Temporary File - Usually safe to delete if not in use.",
    "node_modules": "Javascript Dependencies - Can be massive; safe to delete if you can 'npm install'.",
    ".git": "Version Control - Contains the history of a software project.",
    "py": "Python Script - Source code file.",
    "js": "Javascript File - Web or application logic.",
    "json": "Data File - Structured information used by apps.",
    "cpp": "C++ Source - Compiled programming code.",
    "target": "Build Output - Often found in Rust/Java projects. Safe to clean.",
    "msi": "Windows Installer - Can often be deleted after installation.",
    "exe": "Executable Program - The actual application file.",
    "zip": "Compressed Archive - Multiple files packed together.",
    "rar": "WinRAR Archive - Third-party compression format.",
    "7z": "7-Zip Archive - High efficiency compressed file.",
}

def ss_get_file_hint(path):
    name = os.path.basename(path).lower()
    ext = name.split(".")[-1] if "." in name else ""
    if name in SS_HINTS: return SS_HINTS[name]
    if ext in SS_HINTS: return SS_HINTS[ext]
    if "program files" in path.lower(): return "Installed Application data."
    if "users" in path.lower() and "appdata" not in path.lower(): return "User data (Documents, Downloads, etc)."
    return ""

def ss_format_size(size_bytes):
    if size_bytes == 0: return "0B"
    size_name = ("B", "KB", "MB", "GB", "TB")
    i = int(math.floor(math.log(size_bytes, 1024)))
    p = math.pow(1024, i)
    s = round(size_bytes / p, 2)
    return "%s %s" % (s, size_name[i])

def ss_get_drive_health_info(path):
    if os.name != 'nt': return {"status": "N/A", "raw": "Non-Windows"}
    try:
        drive_letter = os.path.splitdrive(path)[0].replace(":", "")
        if not drive_letter: return {"status": "Unknown", "raw": "No Drive Letter"}
        ps_cmd = (
            f"Get-Volume -DriveLetter {drive_letter} | Get-Partition | Get-Disk | Get-PhysicalDisk | "
            "Select-Object HealthStatus, PredictFailure, MediaType, BusType, OperationalStatus, "
            "Size, AllocatedSize, FriendlyName, Usage, Manufacturer, Model, FirmwareRevision, SerialNumber | ConvertTo-Json"
        )
        process = subprocess.run(["powershell", "-Command", ps_cmd], capture_output=True, text=True, shell=True, timeout=10, creationflags=CREATE_NO_WINDOW)
        if not process.stdout.strip(): return {"status": "Unknown", "raw": "No Output"}
        data = json.loads(process.stdout)
        if isinstance(data, list): data = data[0]
        health = data.get("HealthStatus", "Unknown")
        predict_fail = data.get("PredictFailure", False)
        status = health
        if predict_fail or health.upper() != "HEALTHY":
            status = f"WARNING ({health})"
        return {"status": status, "data": data}
    except Exception as e:
        return {"status": "Unknown", "raw": str(e)}

def ss_get_drive_details(path, serial=None):
    """Get comprehensive drive reliability and performance stats."""
    if os.name != 'nt': return {}
    details = {}
    try:
        drive_letter = os.path.splitdrive(path)[0].replace(":", "")
        
        # Method 1: Get StorageReliabilityCounter (most detailed)
        ps_cmd = (
            f"Get-Volume -DriveLetter {drive_letter} | Get-Partition | Get-Disk | Get-PhysicalDisk | "
            "Get-StorageReliabilityCounter | Select-Object PowerOnHours, Temperature, ReadErrorsTotal, WriteErrorsTotal, "
            "ReadErrorsCorrected, ReadErrorsUncorrected, WriteErrorsCorrected, WriteErrorsUncorrected, "
            "Wearout, LoadUnloadCycleCount, StartStopCycleCount, RealizedCapacity, FlushErrorsTotal, FatalErrorsTotal, "
            "ReadLatencyMax, WriteLatencyMax, ReadIOPS, WriteIOPS | ConvertTo-Json"
        )
        process = subprocess.run(["powershell", "-Command", ps_cmd], capture_output=True, text=True, shell=True, timeout=15, creationflags=CREATE_NO_WINDOW)
        if process.returncode == 0 and process.stdout.strip():
            details = json.loads(process.stdout)
            if isinstance(details, list): details = details[0]
        
        # Method 2: Get additional physical disk info (manufacturer, speed, etc.)
        ps_phys = (
            f"Get-Volume -DriveLetter {drive_letter} | Get-Partition | Get-Disk | Get-PhysicalDisk | "
            "Select-Object Manufacturer, Model, FirmwareRevision, SerialNumber, MediaType, BusType, "
            "SpindleSpeed, Size, AllocatedSize, LogicalSectorSize, PhysicalSectorSize | ConvertTo-Json"
        )
        phys_proc = subprocess.run(["powershell", "-Command", ps_phys], capture_output=True, text=True, shell=True, timeout=10, creationflags=CREATE_NO_WINDOW)
        if phys_proc.returncode == 0 and phys_proc.stdout.strip():
            phys_data = json.loads(phys_proc.stdout)
            if isinstance(phys_data, list): phys_data = phys_data[0]
            details.update(phys_data)
        
        # Method 3: Get disk performance counters
        ps_perf = (
            f"Get-Counter '\\PhysicalDisk(*)\\Disk Reads/sec', '\\PhysicalDisk(*)\\Disk Writes/sec', "
            f"'\\PhysicalDisk(*)\\Avg. Disk sec/Read', '\\PhysicalDisk(*)\\Avg. Disk sec/Write' -ErrorAction SilentlyContinue | "
            "Select-Object -ExpandProperty CounterSamples | Where-Object {{$_.InstanceName -like '*{drive_letter}*'}} | "
            "Select-Object Path, CookedValue | ConvertTo-Json"
        )
        try:
            perf_proc = subprocess.run(["powershell", "-Command", ps_perf], capture_output=True, text=True, shell=True, timeout=5, creationflags=CREATE_NO_WINDOW)
            if perf_proc.returncode == 0 and perf_proc.stdout.strip():
                perf_data = json.loads(perf_proc.stdout)
                if isinstance(perf_data, dict): perf_data = [perf_data]
                for counter in perf_data:
                    path_name = counter.get("Path", "")
                    value = counter.get("CookedValue", 0)
                    if "Reads/sec" in path_name: details["CurrentReadIOPS"] = round(value, 2)
                    elif "Writes/sec" in path_name: details["CurrentWriteIOPS"] = round(value, 2)
                    elif "sec/Read" in path_name: details["AvgReadLatencyMs"] = round(value * 1000, 2)
                    elif "sec/Write" in path_name: details["AvgWriteLatencyMs"] = round(value * 1000, 2)
        except: pass
        
        return details
    except:
        return {}


class SSScanner:
    def __init__(self, root_path, min_size_mb, update_callback, q):
        self.root_path = os.path.normpath(root_path)
        self.min_size_bytes = min_size_mb * 1024 * 1024
        self.update_callback = update_callback
        self.is_running = True
        self.queue = q
        self.total_size = 0
        self.total_files = 0
        self.total_folders = 0
        self.total_errors = 0
        self.entries_scanned = 0
        self.excluded_dirs = {'System Volume Information', '$Recycle.Bin', 'Containers'}

    def stop(self):
        self.is_running = False

    def scan(self):
        start_time = time.time()
        size, files, folders = self._scan_and_sum(self.root_path)
        self.total_size = size
        duration = time.time() - start_time
        self.update_callback(self.root_path, {
            "size": size, "is_dir": True, "files": files, "folders": folders,
            "mtime": os.path.getmtime(self.root_path) if os.path.exists(self.root_path) else 0,
            "complete": True, "duration": duration
        })

    def _scan_and_sum(self, path):
        if not self.is_running: return 0, 0, 0
        if self.queue.qsize() > 1500: time.sleep(0.05)
        base_name = os.path.basename(path).lower()
        if base_name in [ex.lower() for ex in self.excluded_dirs]: return 0, 0, 0
        dir_size, dir_files, dir_folders = 0, 0, 0
        try:
            with os.scandir(path) as it:
                for entry in it:
                    if not self.is_running: return 0, 0, 0
                    self.entries_scanned += 1
                    if entry.is_symlink(): continue
                    try:
                        if entry.is_file(follow_symlinks=False):
                            size = entry.stat().st_size
                            dir_size += size
                            dir_files += 1
                            self.total_files += 1
                            if size >= self.min_size_bytes:
                                self.update_callback(entry.path, {"size": size, "is_dir": False, "files": 0, "folders": 0, "mtime": entry.stat().st_mtime})
                        elif entry.is_dir(follow_symlinks=False):
                            self.total_folders += 1
                            s_size, s_files, s_folders = self._scan_and_sum(entry.path)
                            dir_size += s_size
                            dir_files += s_files
                            dir_folders += (1 + s_folders)
                            self.update_callback(entry.path, {"size": s_size, "is_dir": True, "files": s_files, "folders": 1 + s_folders, "mtime": os.path.getmtime(entry.path) if os.path.exists(entry.path) else 0})
                    except (OSError, PermissionError):
                        self.total_errors += 1
            if self.entries_scanned % 1000 == 0: time.sleep(0.01)
        except (OSError, PermissionError):
            self.total_errors += 1
        return dir_size, dir_files, dir_folders

class SSHealthDetailsWindow(ctk.CTkToplevel):
    def __init__(self, parent, health_info, details):
        super().__init__(parent)
        self.title("Drive Health Details")
        self.geometry("550x700")
        self.attributes("-topmost", True)
        frame = ctk.CTkFrame(self)
        frame.pack(fill="both", expand=True, padx=20, pady=20)
        ctk.CTkLabel(frame, text="Detailed Drive Information", font=ctk.CTkFont(size=18, weight="bold")).pack(pady=(0, 20))
        scroll = ctk.CTkScrollableFrame(frame, width=490, height=550)
        scroll.pack(fill="both", expand=True)
        
        def add_stat(label, value, val_color=None):
            row = ctk.CTkFrame(scroll, fg_color="transparent")
            row.pack(fill="x", pady=2)
            ctk.CTkLabel(row, text=f"{label}:", font=ctk.CTkFont(weight="bold"), width=180, anchor="w").pack(side="left")
            val_lbl = ctk.CTkLabel(row, text=str(value), anchor="w")
            if val_color: val_lbl.configure(text_color=val_color)
            val_lbl.pack(side="left", fill="x", expand=True)
        
        def add_section(title):
            ctk.CTkLabel(scroll, text=title, font=ctk.CTkFont(size=14, weight="bold", underline=True)).pack(anchor="w", pady=(15, 5))
        
        data = health_info.get("data", {})
        
        # Hardware Info
        add_section("Hardware")
        add_stat("Manufacturer", details.get("Manufacturer") or data.get("Manufacturer", "N/A"))
        add_stat("Model", details.get("Model") or data.get("Model", "N/A"))
        add_stat("Serial Number", details.get("SerialNumber") or data.get("SerialNumber", "N/A"))
        add_stat("Firmware", details.get("FirmwareRevision") or data.get("FirmwareRevision", "N/A"))
        add_stat("Bus Type", details.get("BusType") or data.get("BusType", "N/A"))
        add_stat("Media Type", details.get("MediaType") or data.get("MediaType", "N/A"))
        if details.get("SpindleSpeed"): add_stat("Spindle Speed", f"{details.get('SpindleSpeed')} RPM")
        if details.get("Size"): add_stat("Total Capacity", ss_format_size(int(details.get("Size", 0))))
        if details.get("LogicalSectorSize"): add_stat("Sector Size", f"{details.get('LogicalSectorSize')} bytes")
        
        # Health & Reliability
        add_section("Health & Reliability")
        add_stat("Health Status", data.get("HealthStatus", "Unknown"), 
                 "#2ECC71" if data.get("HealthStatus", "").upper() == "HEALTHY" else "#E74C3C")
        add_stat("Operational Status", data.get("OperationalStatus", "N/A"))
        poh = details.get("PowerOnHours")
        if poh: 
            days = int(poh) // 24
            add_stat("Power On Hours", f"{poh} hours ({days} days)")
        else:
            add_stat("Power On Hours", "N/A")
        temp = details.get("Temperature")
        if temp:
            temp_color = "#2ECC71" if int(temp) < 50 else "#F39C12" if int(temp) < 60 else "#E74C3C"
            add_stat("Temperature", f"{temp} C", temp_color)
        else:
            add_stat("Temperature", "N/A")
        add_stat("Power Cycles", details.get("StartStopCycleCount") or details.get("LoadUnloadCycleCount", "N/A"))
        wearout = details.get("Wearout")
        if wearout is not None:
            wear_color = "#2ECC71" if int(wearout) < 50 else "#F39C12" if int(wearout) < 80 else "#E74C3C"
            add_stat("Wearout Level", f"{wearout}%", wear_color)
        
        # Error Statistics
        add_section("Error Statistics")
        read_err = details.get("ReadErrorsTotal", 0) or 0
        write_err = details.get("WriteErrorsTotal", 0) or 0
        add_stat("Read Errors (Total)", read_err, "#E74C3C" if int(read_err) > 0 else None)
        add_stat("Write Errors (Total)", write_err, "#E74C3C" if int(write_err) > 0 else None)
        if details.get("ReadErrorsCorrected"): add_stat("Read Errors (Corrected)", details.get("ReadErrorsCorrected"))
        if details.get("WriteErrorsCorrected"): add_stat("Write Errors (Corrected)", details.get("WriteErrorsCorrected"))
        if details.get("FlushErrorsTotal"): add_stat("Flush Errors", details.get("FlushErrorsTotal"))
        fatal = details.get("FatalErrorsTotal", 0) or 0
        add_stat("Fatal Errors", fatal, "#E74C3C" if int(fatal) > 0 else "#2ECC71")
        
        # Performance (if available)
        if any(details.get(k) for k in ["CurrentReadIOPS", "CurrentWriteIOPS", "ReadLatencyMax", "WriteLatencyMax"]):
            add_section("Performance")
            if details.get("CurrentReadIOPS"): add_stat("Current Read IOPS", details.get("CurrentReadIOPS"))
            if details.get("CurrentWriteIOPS"): add_stat("Current Write IOPS", details.get("CurrentWriteIOPS"))
            if details.get("AvgReadLatencyMs"): add_stat("Avg Read Latency", f"{details.get('AvgReadLatencyMs')} ms")
            if details.get("AvgWriteLatencyMs"): add_stat("Avg Write Latency", f"{details.get('AvgWriteLatencyMs')} ms")
            if details.get("ReadLatencyMax"): add_stat("Max Read Latency", f"{details.get('ReadLatencyMax')} s")
            if details.get("WriteLatencyMax"): add_stat("Max Write Latency", f"{details.get('WriteLatencyMax')} s")
        
        ctk.CTkButton(frame, text="Close", command=self.destroy).pack(pady=(10, 0))


class StorageSenseApp(ctk.CTkToplevel):
    """StorageSense Disk Analyzer - Opens as a child window of the main app."""
    def __init__(self, parent):
        super().__init__(parent)
        self.title("Windows System Cleaner - Professional Disk Analyzer")
        self.geometry("1500x850")
        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(0, weight=1)
        # Main Paned Window (Split View)
        self.paned = tk.PanedWindow(self, orient="horizontal", bd=0, bg="#1e1e1e", sashwidth=4)
        self.paned.grid(row=0, column=0, sticky="nsew", padx=10, pady=10)
        # Left: Directory Tree Frame
        self.left_frame = ctk.CTkFrame(self.paned, corner_radius=0, fg_color="#1e1e1e")
        self.paned.add(self.left_frame, width=350)
        self.left_frame.grid_rowconfigure(1, weight=1)
        self.left_frame.grid_columnconfigure(0, weight=1)
        ctk.CTkLabel(self.left_frame, text="Directory Tree", font=ctk.CTkFont(size=16, weight="bold")).grid(row=0, column=0, pady=5, padx=10, sticky="w")
        # Right: Details Table Frame
        self.right_frame = ctk.CTkFrame(self.paned, corner_radius=0, fg_color="#1e1e1e")
        self.paned.add(self.right_frame)
        self.right_frame.grid_rowconfigure(1, weight=1)
        self.right_frame.grid_columnconfigure(0, weight=1)
        # Toolbar
        self.toolbar = ctk.CTkFrame(self.right_frame, height=40, corner_radius=0, fg_color="transparent")
        self.toolbar.grid(row=0, column=0, sticky="ew", padx=10, pady=5)
        self.select_button = ctk.CTkButton(self.toolbar, text="Select Drive", command=self.select_folder, text_color="black", font=ctk.CTkFont(weight="bold"), width=100)
        self.select_button.pack(side="left", padx=5)
        self.scan_button = ctk.CTkButton(self.toolbar, text="Start Scan", command=self.start_scan, fg_color="#2ECC71", hover_color="#27AE60", text_color="black", font=ctk.CTkFont(weight="bold"), width=100)
        self.scan_button.pack(side="left", padx=5)
        self.stop_button = ctk.CTkButton(self.toolbar, text="Stop", command=self.stop_scan, fg_color="#E74C3C", hover_color="#C0392B", text_color="black", font=ctk.CTkFont(weight="bold"), state="disabled", width=80)
        self.stop_button.pack(side="left", padx=5)
        self.size_entry = ctk.CTkEntry(self.toolbar, width=60)
        self.size_entry.insert(0, "100")
        self.size_entry.pack(side="right", padx=5)
        ctk.CTkLabel(self.toolbar, text="Min (MB):").pack(side="right", padx=5)
        # Bottom Frame (Stats)
        self.bottom_frame = ctk.CTkFrame(self, height=40, corner_radius=0)
        self.bottom_frame.grid(row=1, column=0, sticky="ew")
        self.drive_summary_label = ctk.CTkLabel(self.bottom_frame, text="Drive: -- | Total: -- | Free: --", font=ctk.CTkFont(size=12, weight="bold"))
        self.drive_summary_label.pack(side="left", padx=20)
        self.health_btn = ctk.CTkButton(self.bottom_frame, text="Drive Health: --", font=ctk.CTkFont(size=12, weight="bold"), fg_color="transparent", hover_color="#333333", text_color="#2ECC71", command=self.show_health_details, width=120)
        self.health_btn.pack(side="left", padx=20)
        self.current_health_info = {}
        self.current_health_details = {}
        self.stats_label = ctk.CTkLabel(self.bottom_frame, text="Ready", font=ctk.CTkFont(size=12))
        self.stats_label.pack(side="left", expand=True)
        self.global_stats_label = ctk.CTkLabel(self.bottom_frame, text="Files: 0 | Folders: 0 | Errors: 0", font=ctk.CTkFont(size=12))
        self.global_stats_label.pack(side="right", padx=20)
        # Trees
        self.setup_trees()
        self.scanner = None
        self.selected_path = "C:\\" if os.name == 'nt' else "/"
        self.tree_map_left = {}
        self.tree_map_right = {}
        self.update_queue = queue.Queue()
        self.dirty_nodes = set()
        self.last_status_update = 0
        self.is_scanning = False
        self.after(100, self.process_buffered_updates)

    def setup_trees(self):
        style = ttk.Style()
        style.theme_use("default")
        style.configure("Treeview", background="#2b2b2b", foreground="white", fieldbackground="#2b2b2b", rowheight=28, borderwidth=0)
        style.map("Treeview", background=[('selected', '#3498DB')])
        style.configure("Treeview.Heading", background="#1e1e1e", foreground="white", borderwidth=0, font=("Segoe UI", 10, "bold"))
        self.tree_left = ttk.Treeview(self.left_frame, columns=("Size", "RawSize"), selectmode="browse")
        self.tree_left.heading("#0", text="Folder", anchor="w")
        self.tree_left.heading("Size", text="Size", anchor="w")
        self.tree_left.column("#0", width=220)
        self.tree_left.column("Size", width=80)
        self.tree_left.column("RawSize", width=0, stretch=False)
        self.tree_left["displaycolumns"] = ("Size")
        self.tree_left.grid(row=1, column=0, sticky="nsew", padx=5, pady=5)
        self.tree_left.bind("<<TreeviewSelect>>", self.on_left_tree_select)
        cols = ("Size", "Allocated", "Files", "Folders", "%", "Modified", "Hint", "Path", "RawSize")
        self.tree_right = ttk.Treeview(self.right_frame, columns=cols, selectmode="extended")
        self.tree_right.heading("#0", text="Name", anchor="w")
        for col in cols:
            self.tree_right.heading(col, text=col if col != "%" else "% of Parent", anchor="w")
        self.tree_right.column("#0", width=200)
        self.tree_right.column("Size", width=90)
        self.tree_right.column("Allocated", width=90)
        self.tree_right.column("Files", width=70, anchor="center")
        self.tree_right.column("Folders", width=70, anchor="center")
        self.tree_right.column("%", width=60, anchor="center")
        self.tree_right.column("Modified", width=130)
        self.tree_right.column("Hint", width=150)
        self.tree_right.column("Path", width=0, stretch=False)
        self.tree_right.column("RawSize", width=0, stretch=False)
        self.tree_right["displaycolumns"] = ("Size", "Allocated", "Files", "Folders", "%", "Modified", "Hint")
        self.tree_right.grid(row=1, column=0, sticky="nsew", padx=5, pady=5)
        sb_left = ctk.CTkScrollbar(self.left_frame, command=self.tree_left.yview)
        sb_left.grid(row=1, column=1, sticky="ns")
        self.tree_left.configure(yscrollcommand=sb_left.set)
        sb_right = ctk.CTkScrollbar(self.right_frame, command=self.tree_right.yview)
        sb_right.grid(row=1, column=1, sticky="ns")
        self.tree_right.configure(yscrollcommand=sb_right.set)
        for tree in [self.tree_left, self.tree_right]:
            tree.tag_configure("large", foreground=SS_COLOR_LARGE, font=ctk.CTkFont(weight="bold"))
            tree.tag_configure("medium", foreground=SS_COLOR_MEDIUM, font=ctk.CTkFont(weight="bold"))
            tree.tag_configure("core", foreground=SS_COLOR_CORE, font=ctk.CTkFont(weight="bold"))
        self.context_menu = tk.Menu(self, tearoff=0, background="#1e1e1e", foreground="white")
        self.context_menu.add_command(label="Open in Explorer", command=self.open_selected)
        self.context_menu.add_command(label="Delete", command=self.delete_selected)
        self.tree_right.bind("<Button-3>", self.show_context_menu)
        # Bind tree expand/collapse to sync both trees
        self.tree_left.bind("<<TreeviewOpen>>", self.on_left_tree_toggle)
        self.tree_left.bind("<<TreeviewClose>>", self.on_left_tree_toggle)
        self.tree_right.bind("<<TreeviewOpen>>", self.on_right_tree_toggle)
        self.tree_right.bind("<<TreeviewClose>>", self.on_right_tree_toggle)

    def show_context_menu(self, event):
        item = self.tree_right.identify_row(event.y)
        if item:
            self.tree_right.selection_set(item)
            self.context_menu.post(event.x_root, event.y_root)

    def on_left_tree_select(self, event):
        selected_left = self.tree_left.selection()
        if not selected_left: return
        path = next((p for p, lid in self.tree_map_left.items() if lid == selected_left[0]), None)
        if not path: return
        if path in self.tree_map_right:
            rid = self.tree_map_right[path]
            self.tree_right.selection_set(rid)
            self.tree_right.see(rid)
            self.tree_right.focus(rid)
            self.tree_right.item(rid, open=True)

    def on_left_tree_toggle(self, event):
        """Sync expand/collapse from left tree to right tree."""
        selected_left = self.tree_left.focus()
        if not selected_left: return
        path = next((p for p, lid in self.tree_map_left.items() if lid == selected_left), None)
        if path and path in self.tree_map_right:
            rid = self.tree_map_right[path]
            is_open = self.tree_left.item(selected_left, "open")
            self.tree_right.item(rid, open=is_open)

    def on_right_tree_toggle(self, event):
        """Sync expand/collapse from right tree to left tree."""
        selected_right = self.tree_right.focus()
        if not selected_right: return
        try:
            item = self.tree_right.item(selected_right)
            path = item['values'][7] if len(item['values']) > 7 else None
            if path and path in self.tree_map_left:
                lid = self.tree_map_left[path]
                is_open = self.tree_right.item(selected_right, "open")
                self.tree_left.item(lid, open=is_open)
        except: pass

    def select_folder(self):
        from tkinter import filedialog
        folder = filedialog.askdirectory()
        if folder:
            self.selected_path = os.path.normpath(folder)
            self.stats_label.configure(text=f"Selected: {self.selected_path}")

    def stop_scan(self):
        if self.scanner:
            self.scanner.stop()
            self.is_scanning = False
            self.stats_label.configure(text="Scan stopped.")
            self.stop_button.configure(state="disabled")
            self.scan_button.configure(state="normal")

    def start_scan(self):
        if not self.selected_path:
            messagebox.showwarning("Warning", "Please select a folder first!")
            return
        try:
            min_size = int(self.size_entry.get())
        except ValueError:
            messagebox.showerror("Error", "Invalid size. Please enter a number.")
            return
        self.is_scanning = True
        self.scan_button.configure(state="disabled")
        self.stop_button.configure(state="normal")
        self.stats_label.configure(text="Scanning...")
        for tree in [self.tree_left, self.tree_right]:
            for item in tree.get_children():
                tree.delete(item)
        self.tree_map_left = {}
        self.tree_map_right = {}
        root_name = os.path.basename(self.selected_path) or self.selected_path
        rid_left = self.tree_left.insert("", "end", text=root_name, values=("..."), open=True)
        rid_right = self.tree_right.insert("", "end", text=root_name, values=("...", "...", "0", "0", "100%", "...", "", self.selected_path, 0), open=True)
        self.tree_map_left[self.selected_path] = rid_left
        self.tree_map_right[self.selected_path] = rid_right
        self.update_drive_info()
        self.scanner = SSScanner(self.selected_path, min_size, self.queue_ui_update, self.update_queue)
        threading.Thread(target=self.scanner.scan, daemon=True).start()

    def update_drive_info(self):
        try:
            usage = shutil.disk_usage(self.selected_path)
            total_str = ss_format_size(usage.total)
            free_str = ss_format_size(usage.free)
            drive_name = os.path.splitdrive(self.selected_path)[0] or self.selected_path
            self.drive_summary_label.configure(text=f"Drive: {drive_name} | Total: {total_str} | Free: {free_str}")
            self.health_btn.configure(text="Drive Health: Checking...", text_color="#F39C12")
            def run_health_check():
                try:
                    path = self.selected_path
                    info = ss_get_drive_health_info(path)
                    serial = info.get("data", {}).get("SerialNumber")
                    details = ss_get_drive_details(path, serial)
                    self.after(0, lambda: self._finalize_health_update(info, details))
                except:
                    self.after(0, lambda: self.health_btn.configure(text="Drive Health: Error", text_color="#E74C3C"))
            threading.Thread(target=run_health_check, daemon=True).start()
        except:
            self.drive_summary_label.configure(text="Drive Info: Error")

    def _finalize_health_update(self, info, details):
        self.current_health_info = info
        self.current_health_details = details
        status_text = f"Drive Health: {info.get('status', 'Unknown')}"
        self.health_btn.configure(text=status_text)
        if "WARNING" in info.get('status', '').upper():
            self.health_btn.configure(text_color="#E74C3C")
        elif "UNKNOWN" in info.get('status', '').upper():
            self.health_btn.configure(text_color="#F39C12")
        else:
            self.health_btn.configure(text_color="#2ECC71")

    def show_health_details(self):
        if not self.current_health_info:
            messagebox.showinfo("Wait", "Health info not loaded yet.")
            return
        SSHealthDetailsWindow(self, self.current_health_info, self.current_health_details)

    def queue_ui_update(self, path, metadata):
        self.update_queue.put((path, metadata))

    def process_buffered_updates(self):
        batch_limit = 150
        count = 0
        while count < batch_limit:
            try:
                path, metadata = self.update_queue.get_nowait()
                if metadata.get("complete"):
                    duration = metadata.get("duration", 0)
                    self.is_scanning = False
                    self.stats_label.configure(text=f"Scan Finished in {round(duration, 1)}s")
                    self.scan_button.configure(state="normal")
                    self.stop_button.configure(state="disabled")
                self._apply_single_update(path, metadata)
                count += 1
            except queue.Empty:
                break
        # Sort dirty nodes by size (largest first)
        if self.dirty_nodes:
            for parent_id, tree_type in list(self.dirty_nodes)[:20]:
                try:
                    tree = self.tree_right if tree_type == "right" else self.tree_left
                    self._sort_children_by_size(tree, parent_id)
                    self.dirty_nodes.discard((parent_id, tree_type))
                except: pass
        if self.scanner:
            self.global_stats_label.configure(text=f"Files: {self.scanner.total_files:,} | Folders: {self.scanner.total_folders:,} | Errors: {self.scanner.total_errors:,}")
        self.after(40 if count > 0 else 100, self.process_buffered_updates)
    
    def _sort_children_by_size(self, tree, parent_id):
        """Sort children of a tree node by size, largest first."""
        try:
            children = list(tree.get_children(parent_id))
            if not children: return
            
            def sort_key(item_id):
                try:
                    # Get raw size value (last column)
                    values = tree.item(item_id, "values")
                    if values:
                        raw_size = values[-1] if len(values) > 0 else 0
                        return int(raw_size) if raw_size and str(raw_size).isdigit() else 0
                except: pass
                return 0
            
            sorted_children = sorted(children, key=sort_key, reverse=True)
            for i, child_id in enumerate(sorted_children):
                tree.move(child_id, parent_id, i)
        except: pass

    def _apply_single_update(self, path, metadata):
        if not self.scanner: return
        size = metadata['size']
        is_dir = metadata['is_dir']
        files_cnt = metadata.get('files', 0)
        folders_cnt = metadata.get('folders', 1 if is_dir else 0)
        mtime_raw = metadata.get('mtime', 0)
        mod_date = time.strftime('%Y-%m-%d %H:%M', time.localtime(mtime_raw)) if mtime_raw else "..."
        parent_path = os.path.dirname(path)
        name = os.path.basename(path) or path
        size_str = ss_format_size(size)
        hint = ss_get_file_hint(path)
        if parent_path not in self.tree_map_right and path != self.selected_path:
            self._ensure_parent_exists(parent_path)
        parent_id_right = self.tree_map_right.get(parent_path, "")
        parent_id_left = self.tree_map_left.get(parent_path, "")
        percent_str = ""
        if parent_id_right:
            try:
                p_size = int(self.tree_right.set(parent_id_right, "RawSize") or 0)
                if p_size > 0: percent_str = f"{round((size/p_size)*100, 1)}%"
            except: pass
        tag = ""
        lpath = path.lower()
        if ":\\windows" in lpath or any(sysfile in name.lower() for sysfile in ["pagefile.sys", "hiberfil.sys", "swapfile.sys"]):
            tag = "core"
            hint = f"Windows Core File - {hint}" if hint else "Windows Core File"
        if not tag:
            if size > SS_THRESHOLD_GB * 1024**3: tag = "large"
            elif size > SS_THRESHOLD_MB * 1024**2: tag = "medium"
        values = (size_str, size_str, f"{files_cnt:,}", f"{folders_cnt:,}", percent_str, mod_date, hint, path, size)
        if path in self.tree_map_right:
            self.tree_right.item(self.tree_map_right[path], values=values, tags=(tag,))
        else:
            new_id = self.tree_right.insert(parent_id_right, "end", text=name, values=values, tags=(tag,))
            self.tree_map_right[path] = new_id
        # Mark parent as dirty for sorting
        if parent_id_right:
            self.dirty_nodes.add((parent_id_right, "right"))
        if is_dir:
            rel_path = os.path.relpath(path, self.selected_path)
            parts = [p for p in rel_path.split(os.sep) if p]
            is_root = (path == self.selected_path)
            is_main_parent = (len(parts) == 1)
            excluded = {"$recycle.bin", "system volume information", "found.000"}
            if name.lower() in excluded: is_main_parent = False
            if is_root or (is_main_parent and size > 10 * 1024**2):
                if path in self.tree_map_left:
                    self.tree_left.item(self.tree_map_left[path], values=(size_str, size), tags=(tag,))
                else:
                    new_id_l = self.tree_left.insert(parent_id_left, "end", text=name, values=(size_str, size), tags=(tag,))
                    self.tree_map_left[path] = new_id_l
                # Mark parent as dirty for sorting
                if parent_id_left:
                    self.dirty_nodes.add((parent_id_left, "left"))
        if self.is_scanning and time.time() - self.last_status_update > 0.3:
            self.stats_label.configure(text=f"Scanning: {name[:50]}")
            self.last_status_update = time.time()

    def _ensure_parent_exists(self, path):
        if path == self.selected_path or len(path) < 3: return
        p_path = os.path.dirname(path)
        self._ensure_parent_exists(p_path)
        if path not in self.tree_map_right:
            pid_r = self.tree_map_right.get(p_path, "")
            pid_l = self.tree_map_left.get(p_path, "")
            rid_p = self.tree_right.insert(pid_r, "end", text=os.path.basename(path), values=("...", "...", "0", "0", "...", "...", "", path, 0))
            self.tree_map_right[path] = rid_p
            lid_p = self.tree_left.insert(pid_l, "end", text=os.path.basename(path), values=("..."))
            self.tree_map_left[path] = lid_p

    def open_selected(self):
        selected = self.tree_right.selection()
        if not selected: return
        item = self.tree_right.item(selected[0])
        path = item['values'][7]
        if os.name == 'nt':
            subprocess.run(['explorer', '/select,', os.path.normpath(path)])
        else:
            subprocess.run(['open', os.path.dirname(path)])

    def delete_selected(self):
        selected = self.tree_right.selection()
        if not selected: return
        item = self.tree_right.item(selected[0])
        path = item['values'][7]
        if messagebox.askyesno("Confirm Delete", f"Are you sure you want to permanently delete:\n{path}?"):
            try:
                if os.path.isdir(path):
                    shutil.rmtree(path)
                else: os.remove(path)
                self.tree_right.delete(selected[0])
                if path in self.tree_map_left: self.tree_left.delete(self.tree_map_left[path])
                messagebox.showinfo("Deleted", "Item deleted successfully.")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to delete: {e}")

# ==================== END STORAGESENSE MODULE ====================


# Define modern professional themes
LIGHT_THEME = {
    'bg': '#F8FAFC',           # Slate 50
    'fg': '#0F172A',           # Slate 900
    'surface': '#FFFFFF',       # White
    'surface_alt': '#F1F5F9',   # Slate 100
    'primary': '#6366F1',       # Indigo 500
    'select_bg': '#E2E8F0',     # Slate 200
    'select_fg': '#0F172A',
    'button_bg': '#6366F1',     # Indigo Primary
    'button_fg': '#FFFFFF',
    'button_secondary_bg': '#94A3B8', # Slate 400
    'button_secondary_fg': '#FFFFFF',
    'entry_bg': '#FFFFFF',
    'entry_fg': '#0F172A',
    'text_bg': '#FFFFFF',
    'text_fg': '#0F172A',
    'log_text_fg': '#059669',   # Emerald 600
    'frame_bg': '#FFFFFF',
    'label_bg': '#F8FAFC',
    'label_fg': '#0F172A',
    'header_bg': '#F1F5F9',     # Slate 100
    'header_fg': '#0F172A',
    'progress_bg': '#6366F1',
    'admin_fg': '#059669',
    'admin_error_fg': '#DC2626',
    'menu_bg': '#FFFFFF',
    'menu_fg': '#0F172A',
    'task_bg': '#FFFFFF',
    'task_fg': '#334155',       # Slate 700
    'task_border': '#CBD5E1',   # Slate 300
    'tooltip_bg': '#1E293B',
    'tooltip_fg': '#FFFFFF',
    'admin_indicator': '#059669',
    'user_indicator': '#D97706',  # Amber 600
    'card_bg': '#FFFFFF',
    'card_border': '#E2E8F0',
    'surface_alt': '#F1F5F9',
    'label_fg_dim': '#64748B'
}

DARK_THEME = {
    'bg': '#020617',           # Slate 950
    'fg': '#F8FAFC',           # Slate 50
    'surface': '#0F172A',       # Slate 900
    'surface_alt': '#1E293B',   # Slate 800
    'primary': '#818CF8',       # Indigo 400
    'select_bg': '#334155',     # Slate 700
    'select_fg': '#F8FAFC',
    'button_bg': '#6366F1',     # Indigo 500
    'button_fg': '#FFFFFF',
    'button_secondary_bg': '#334155', # Slate 700
    'button_secondary_fg': '#F8FAFC',
    'entry_bg': '#0F172A',
    'entry_fg': '#F8FAFC',
    'text_bg': '#0F172A',
    'text_fg': '#F8FAFC',
    'log_text_fg': '#34D399',   # Emerald 400
    'frame_bg': '#0F172A',
    'label_bg': '#020617',
    'label_fg': '#F8FAFC',
    'header_bg': '#0F172A',
    'header_fg': '#F8FAFC',
    'progress_bg': '#818CF8',
    'admin_fg': '#34D399',
    'admin_error_fg': '#F87171',
    'menu_bg': '#0F172A',
    'menu_fg': '#F8FAFC',
    'task_bg': '#1E293B',       # Slate 800
    'task_fg': '#CBD5E1',       # Slate 300
    'task_border': '#334155',   # Slate 700
    'tooltip_bg': '#F8FAFC',
    'tooltip_fg': '#0F172A',
    'admin_indicator': '#34D399',
    'user_indicator': '#FBBF24',  # Amber 400
    'card_bg': '#0F172A',
    'card_border': '#1E293B',
    'surface_alt': '#1E293B',
    'label_fg_dim': '#94A3B8'
}

# Fun Theme: Cyberpunk - Neon pink and cyan on dark
CYBERPUNK_THEME = {
    'bg': '#0D0221',           # Deep purple-black
    'fg': '#00FFFF',           # Cyan
    'surface': '#1A0533',       # Dark purple
    'surface_alt': '#2D0845',   # Purple
    'primary': '#FF00FF',       # Magenta
    'select_bg': '#3D1A5C',
    'select_fg': '#00FFFF',
    'button_bg': '#FF00FF',     # Magenta
    'button_fg': '#0D0221',
    'button_secondary_bg': '#00FFFF',
    'button_secondary_fg': '#0D0221',
    'entry_bg': '#1A0533',
    'entry_fg': '#00FFFF',
    'text_bg': '#1A0533',
    'text_fg': '#00FFFF',
    'log_text_fg': '#39FF14',   # Neon green
    'frame_bg': '#1A0533',
    'label_bg': '#0D0221',
    'label_fg': '#FF00FF',
    'header_bg': '#1A0533',
    'header_fg': '#00FFFF',
    'progress_bg': '#FF00FF',
    'admin_fg': '#39FF14',
    'admin_error_fg': '#FF3131',
    'menu_bg': '#1A0533',
    'menu_fg': '#00FFFF',
    'task_bg': '#2D0845',
    'task_fg': '#FF69B4',       # Hot pink
    'task_border': '#FF00FF',
    'tooltip_bg': '#00FFFF',
    'tooltip_fg': '#0D0221',
    'admin_indicator': '#39FF14',
    'user_indicator': '#FFD700',
    'card_bg': '#1A0533',
    'card_border': '#FF00FF',
    'label_fg_dim': '#8B5CF6'
}

# Fun Theme: Ocean - Blues and teals
OCEAN_THEME = {
    'bg': '#0A1628',           # Deep ocean
    'fg': '#E0F7FA',           # Light cyan
    'surface': '#0D2B45',       # Ocean depth
    'surface_alt': '#124A6B',   # Mid ocean
    'primary': '#00ACC1',       # Cyan
    'select_bg': '#1A6B8A',
    'select_fg': '#E0F7FA',
    'button_bg': '#00ACC1',
    'button_fg': '#FFFFFF',
    'button_secondary_bg': '#26C6DA',
    'button_secondary_fg': '#0A1628',
    'entry_bg': '#0D2B45',
    'entry_fg': '#E0F7FA',
    'text_bg': '#0D2B45',
    'text_fg': '#E0F7FA',
    'log_text_fg': '#4DD0E1',   # Light teal
    'frame_bg': '#0D2B45',
    'label_bg': '#0A1628',
    'label_fg': '#80DEEA',
    'header_bg': '#0D2B45',
    'header_fg': '#E0F7FA',
    'progress_bg': '#00ACC1',
    'admin_fg': '#00E676',
    'admin_error_fg': '#FF5252',
    'menu_bg': '#0D2B45',
    'menu_fg': '#E0F7FA',
    'task_bg': '#124A6B',
    'task_fg': '#B2EBF2',
    'task_border': '#00ACC1',
    'tooltip_bg': '#E0F7FA',
    'tooltip_fg': '#0A1628',
    'admin_indicator': '#00E676',
    'user_indicator': '#FFAB40',
    'card_bg': '#0D2B45',
    'card_border': '#00ACC1',
    'label_fg_dim': '#4DD0E1'
}

# Fun Theme: Sunset - Warm oranges and purples
SUNSET_THEME = {
    'bg': '#1A0A2E',           # Deep purple night
    'fg': '#FFECD2',           # Warm cream
    'surface': '#2D1B4E',       # Purple dusk
    'surface_alt': '#4A2C6A',   # Twilight
    'primary': '#FF6B35',       # Sunset orange
    'select_bg': '#5C3D7A',
    'select_fg': '#FFECD2',
    'button_bg': '#FF6B35',
    'button_fg': '#1A0A2E',
    'button_secondary_bg': '#FFB347',
    'button_secondary_fg': '#1A0A2E',
    'entry_bg': '#2D1B4E',
    'entry_fg': '#FFECD2',
    'text_bg': '#2D1B4E',
    'text_fg': '#FFECD2',
    'log_text_fg': '#FFD700',   # Golden
    'frame_bg': '#2D1B4E',
    'label_bg': '#1A0A2E',
    'label_fg': '#FF9A56',
    'header_bg': '#2D1B4E',
    'header_fg': '#FFECD2',
    'progress_bg': '#FF6B35',
    'admin_fg': '#7CFC00',
    'admin_error_fg': '#FF4757',
    'menu_bg': '#2D1B4E',
    'menu_fg': '#FFECD2',
    'task_bg': '#4A2C6A',
    'task_fg': '#FFB8A1',
    'task_border': '#FF6B35',
    'tooltip_bg': '#FFECD2',
    'tooltip_fg': '#1A0A2E',
    'admin_indicator': '#7CFC00',
    'user_indicator': '#FFD700',
    'card_bg': '#2D1B4E',
    'card_border': '#FF6B35',
    'label_fg_dim': '#A78BFA'
}

# Fun Theme: Forest - Greens and earth tones
FOREST_THEME = {
    'bg': '#0D1F0D',           # Deep forest
    'fg': '#E8F5E9',           # Light green
    'surface': '#1B3B1B',       # Forest floor
    'surface_alt': '#2E5A2E',   # Fern green
    'primary': '#4CAF50',       # Green
    'select_bg': '#3E7A3E',
    'select_fg': '#E8F5E9',
    'button_bg': '#4CAF50',
    'button_fg': '#FFFFFF',
    'button_secondary_bg': '#8BC34A',
    'button_secondary_fg': '#0D1F0D',
    'entry_bg': '#1B3B1B',
    'entry_fg': '#E8F5E9',
    'text_bg': '#1B3B1B',
    'text_fg': '#E8F5E9',
    'log_text_fg': '#76FF03',   # Lime
    'frame_bg': '#1B3B1B',
    'label_bg': '#0D1F0D',
    'label_fg': '#A5D6A7',
    'header_bg': '#1B3B1B',
    'header_fg': '#E8F5E9',
    'progress_bg': '#4CAF50',
    'admin_fg': '#76FF03',
    'admin_error_fg': '#FF6B6B',
    'menu_bg': '#1B3B1B',
    'menu_fg': '#E8F5E9',
    'task_bg': '#2E5A2E',
    'task_fg': '#C8E6C9',
    'task_border': '#4CAF50',
    'tooltip_bg': '#E8F5E9',
    'tooltip_fg': '#0D1F0D',
    'admin_indicator': '#76FF03',
    'user_indicator': '#FFB74D',
    'card_bg': '#1B3B1B',
    'card_border': '#4CAF50',
    'label_fg_dim': '#81C784'
}


# Enhanced startup logging

def startup_log(message):
    """Log startup messages to both console and file"""
    timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
    log_message = f"{timestamp} - {message}"
    print(log_message)  # Print to console
    try:
        with open("system_cleaner_startup.log", "a") as f:
            f.write(log_message + "\n")
    except:
        pass  # If we can't write to file, at least we printed to console


startup_log("Application starting")

# Clear previous startup logs
if os.path.exists("system_cleaner_startup.log"):
    try:
        os.remove("system_cleaner_startup.log")
    except:
        pass

# Skip relaunch with pythonw.exe for now to troubleshoot
skip_relaunch = True
if '--no-relaunch' not in sys.argv:
    # Only relaunch if we're running from a console and not already using pythonw.exe
    if not getattr(sys, 'frozen', False) and sys.stdout is not None and 'pythonw' not in sys.executable.lower():
        startup_log("Attempting to relaunch with pythonw.exe")
        try:
            pythonw_path = os.path.join(os.path.dirname(sys.executable), 'pythonw.exe')
            if os.path.exists(pythonw_path):
                startup_log(f"Found pythonw.exe at: {pythonw_path}")
                startup_log("Skipping automatic relaunch for debugging")
                skip_relaunch = True
            else:
                startup_log("pythonw.exe not found, continuing in console mode")
        except Exception as e:
            startup_log(f"Error during relaunch attempt: {str(e)}")
            startup_log("Continuing in console mode")

# Check if running on Windows
if os.name != 'nt':
    print("This application is designed to run on Windows only.")
    startup_log("Not running on Windows, exiting")
    sys.exit(1)


# Check dependencies first
def check_dependencies():
    startup_log("Checking dependencies")
    required_modules = [
        'tkinter', 'ctypes', 'subprocess', 'winreg', 'threading',
        'queue', 'time', 'argparse', 'json', 'hashlib', 're', 'pathlib',
        'wmi', 'webbrowser', 'pythoncom'
    ]

    missing_modules = []
    for module in required_modules:
        try:
            __import__(module)
            startup_log(f"Module OK: {module}")
        except ImportError as e:
            missing_modules.append(f"{module}: {str(e)}")
            startup_log(f"Module missing: {module} - {str(e)}")

    if missing_modules:
        print("Missing required modules:")
        startup_log("Missing modules detected:")
        for module in missing_modules:
            print(f"  - {module}")
            startup_log(f"  - {module}")
        print("\nPlease install them using: pip install <module_name>")
        startup_log("Dependency check failed, exiting")
        return False
    startup_log("All dependencies OK")
    return True


if not check_dependencies():
    print("Dependencies check failed. Exiting.")
    sys.exit(1)


class SecurityUtils:
    """Security utilities for safe operations"""

    @staticmethod
    def sanitize_path(path_str):
        """Sanitize file paths to prevent path traversal attacks"""
        try:
            # Convert to Path object and resolve
            path = Path(path_str).resolve()

            # Check if path is within allowed directories
            allowed_roots = [
                Path(os.environ.get('TEMP', 'C:\\Temp')),
                Path(os.environ.get('SystemRoot', 'C:\\Windows')),
                Path('C:\\PowerShell'),
                Path(os.environ.get('APPDATA', 'C:\\Users\\Default\\AppData\\Roaming'))
            ]

            for root in allowed_roots:
                try:
                    path.relative_to(root.resolve())
                    return str(path)
                except ValueError:
                    continue

            # If not in allowed directories, reject
            raise ValueError(f"Path not in allowed directories: {path}")

        except Exception as e:
            raise ValueError(f"Invalid path: {path_str}")

    @staticmethod
    def sanitize_command_args(args):
        """Sanitize command line arguments to prevent injection"""
        safe_args = []
        for arg in args:
            # Remove potentially dangerous characters
            safe_arg = re.sub(r'[;&|`$(){}[\]<>]', '', str(arg))
            # Limit length
            if len(safe_arg) > 1000:
                raise ValueError("Argument too long")
            safe_args.append(safe_arg)
        return safe_args

    @staticmethod
    def validate_registry_key(key_path):
        """Validate registry key paths"""
        allowed_patterns = [
            r'^SOFTWARE\\Microsoft\\Windows\\',
            r'^SOFTWARE\\Policies\\Microsoft\\Windows\\',
            r'^SYSTEM\\CurrentControlSet\\Control\\',
            r'^SOFTWARE\\Microsoft\\GameBar',
            r'^SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\VolumeCaches'
        ]

        for pattern in allowed_patterns:
            if re.match(pattern, key_path, re.IGNORECASE):
                return True

        raise ValueError(f"Registry key not allowed: {key_path}")


class Tooltip:
    """Create a tooltip for a given widget"""

    def __init__(self, widget, text='widget info', theme=DARK_THEME):
        self.widget = widget
        self.text = text
        self.theme = theme
        self.tooltip = None
        self.widget.bind("<Enter>", self.enter)
        self.widget.bind("<Leave>", self.leave)

    def enter(self, event=None):
        if self.tooltip or not self.text:
            return

        x = self.widget.winfo_rootx() + 25
        y = self.widget.winfo_rooty() + 25

        try:
            self.tooltip = tk.Toplevel(self.widget)
            self.tooltip.wm_overrideredirect(True)
            self.tooltip.wm_geometry(f"+{x}+{y}")
            self.tooltip.attributes("-topmost", True)

            label = tk.Label(
                self.tooltip,
                text=self.text,
                justify=tk.LEFT,
                background=self.theme.get('tooltip_bg', '#F8FAFC'),
                foreground=self.theme.get('tooltip_fg', '#0F172A'),
                relief=tk.FLAT,
                padx=10,
                pady=5,
                font=('Segoe UI', 9)
            )
            label.pack()

            # Add a subtle border
            self.tooltip.config(bg=self.theme.get('tooltip_fg', '#0F172A')) # Outer color as border
        except Exception as e:
            print(f"DEBUG: Tooltip creation failed: {e}")
            if self.tooltip:
                self.tooltip.destroy()
                self.tooltip = None

    def leave(self, event=None):
        if self.tooltip:
            try:
                self.tooltip.destroy()
            except:
                pass
            self.tooltip = None


# PC Reporter class moved outside of SystemCleanerGUI
class PCReporter:
    def __init__(self):
        self.report_data = {
            "system_info": {},
            "hardware": {},
            "software": {},
            "network": {},
            "security": {},
            "users": {},
            "environment": {},
            "processes": [],
            "services": [],
            "devices": [],
            "performance": {},
            "updates": {},
            "vulnerabilities": {},
            "startup_items": {}  # Added for startup items
        }
        self.report_file = "PC_Report.html"

    def collect_system_info(self):
        """Collect basic system information"""
        boot_time = datetime.fromtimestamp(psutil.boot_time())
        uptime = datetime.now() - boot_time

        self.report_data["system_info"] = {
            "Computer Name": socket.gethostname(),
            "Operating System": platform.system(),
            "OS Version": platform.version(),
            "OS Release": platform.release(),
            "Architecture": platform.machine(),
            "Processor": platform.processor(),
            "System UUID": str(uuid.getnode()),
            "Python Version": platform.python_version(),
            "Boot Time": boot_time.strftime("%Y-%m-%d %H:%M:%S"),
            "System Uptime": f"{uptime.days} days, {uptime.seconds // 3600} hours, {(uptime.seconds % 3600) // 60} minutes",
            "Report Generated": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        }

    def collect_hardware_info(self):
        """Collect detailed hardware information"""
        # CPU Information
        cpu_freq = psutil.cpu_freq()
        cpu_info = {
            "Physical Cores": psutil.cpu_count(logical=False),
            "Total Cores": psutil.cpu_count(logical=True),
            "Max Frequency": f"{cpu_freq.max:.2f} MHz" if cpu_freq else "N/A",
            "Current Frequency": f"{cpu_freq.current:.2f} MHz" if cpu_freq else "N/A",
            "Min Frequency": f"{cpu_freq.min:.2f} MHz" if cpu_freq else "N/A",
            "CPU Usage": f"{psutil.cpu_percent(interval=1)}%",
            "CPU Usage Per Core": dict(enumerate(psutil.cpu_percent(interval=1, percpu=True)))
        }

        # Memory Information
        mem = psutil.virtual_memory()
        swap = psutil.swap_memory()
        memory_info = {
            "Total Memory": f"{mem.total / (1024 ** 3):.2f} GB",
            "Available Memory": f"{mem.available / (1024 ** 3):.2f} GB",
            "Used Memory": f"{mem.used / (1024 ** 3):.2f} GB",
            "Memory Percentage": f"{mem.percent}%",
            "Total Swap": f"{swap.total / (1024 ** 3):.2f} GB",
            "Used Swap": f"{swap.used / (1024 ** 3):.2f} GB",
            "Free Swap": f"{swap.free / (1024 ** 3):.2f} GB",
            "Swap Percentage": f"{swap.percent}%",
            "Memory Speed": self._get_memory_speed()
        }

        # Disk Information
        disk_info = {}
        disk_io = psutil.disk_io_counters()
        for partition in psutil.disk_partitions():
            try:
                partition_usage = psutil.disk_usage(partition.mountpoint)
                disk_info[f"Drive {partition.device}"] = {
                    "Mount Point": partition.mountpoint,
                    "File System": partition.fstype,
                    "Total Size": f"{partition_usage.total / (1024 ** 3):.2f} GB",
                    "Used": f"{partition_usage.used / (1024 ** 3):.2f} GB",
                    "Free": f"{partition_usage.free / (1024 ** 3):.2f} GB",
                    "Percentage": f"{partition_usage.percent}%",
                    "Drive Type": self._get_drive_type(partition.device)
                }
            except PermissionError:
                continue

        # Add disk I/O statistics
        if disk_io:
            disk_info["Disk I/O Statistics"] = {
                "Read Count": f"{disk_io.read_count:,}",
                "Write Count": f"{disk_io.write_count:,}",
                "Read Bytes": f"{disk_io.read_bytes / (1024 ** 3):.2f} GB",
                "Write Bytes": f"{disk_io.write_bytes / (1024 ** 3):.2f} GB",
                "Read Time": f"{disk_io.read_time} ms",
                "Write Time": f"{disk_io.write_time} ms"
            }

        # GPU Information
        gpu_info = self._get_gpu_info()

        # Motherboard Information
        motherboard_info = self._get_motherboard_info()

        # Battery Information (for laptops)
        battery_info = self._get_battery_info()

        # Temperature Information
        temp_info = self._get_temperature_info()

        self.report_data["hardware"] = {
            "CPU": cpu_info,
            "Memory": memory_info,
            "Storage": disk_info,
            "Graphics": gpu_info,
            "Motherboard": motherboard_info
        }

        if battery_info:
            self.report_data["hardware"]["Battery"] = battery_info

        if temp_info:
            self.report_data["hardware"]["Temperature"] = temp_info

    def _get_memory_speed(self):
        """Get memory speed information"""
        try:
            if platform.system() == "Windows":
                # Try multiple methods to get memory speed
                commands = [
                    ["wmic", "memorychip", "get", "speed", "/format:list"],
                    ["wmic", "MEMORYCHIP", "get", "Speed", "/value"]
                ]

                for cmd in commands:
                    try:
                        result = subprocess.run(cmd, capture_output=True, text=True, timeout=10,
                                                creationflags=CREATE_NO_WINDOW)
                        if result.returncode == 0:
                            speeds = re.findall(r"Speed=(\d+)", result.stdout)
                            if speeds:
                                return f"{speeds[0]} MHz"
                    except (subprocess.TimeoutExpired, subprocess.SubprocessError):
                        continue

                return "Information not available"
        except Exception:
            return "Information not available"

    def _get_drive_type(self, device):
        """Get drive type (HDD/SSD)"""
        try:
            if platform.system() == "Windows":
                # Clean device name for WMIC query
                clean_device = device.replace('\\', '').replace(':', '')
                commands = [
                    ["wmic", "diskdrive", "where", f"DeviceID='\\\\.\\{clean_device}'", "get", "MediaType",
                     "/format:list"],
                    ["wmic", "diskdrive", "get", "Model,MediaType,Size", "/format:list"],
                    ["powershell", "Get-PhysicalDisk | Select-Object MediaType,DeviceId | Format-List"]
                ]

                for cmd in commands:
                    try:
                        result = subprocess.run(cmd, capture_output=True, text=True, timeout=10,
                                                creationflags=CREATE_NO_WINDOW)
                        if result.returncode == 0:
                            if "SSD" in result.stdout.upper():
                                return "SSD"
                            elif "HDD" in result.stdout.upper() or "FIXED" in result.stdout.upper():
                                return "HDD"
                    except (subprocess.TimeoutExpired, subprocess.SubprocessError):
                        continue

                return "Unknown"
        except Exception:
            return "Unknown"

    def _get_gpu_info(self):
        """Get detailed GPU information"""
        gpu_info = {}
        try:
            if platform.system() == "Windows":
                commands = [
                    ["wmic", "path", "win32_VideoController", "get", "name,adapterram,driverversion,driverdate",
                     "/format:list"],
                    ["wmic", "path", "win32_VideoController", "get", "name", "/value"],
                    ["powershell",
                     "Get-WmiObject -Class Win32_VideoController | Select-Object Name,AdapterRAM,DriverVersion | Format-List"]
                ]

                for cmd in commands:
                    try:
                        result = subprocess.run(cmd, capture_output=True, text=True, timeout=10,
                                                creationflags=CREATE_NO_WINDOW)
                        if result.returncode == 0:
                            gpu_data = {}
                            for line in result.stdout.split('\n'):
                                if '=' in line:
                                    key, value = line.split('=', 1)
                                    gpu_data[key.strip()] = value.strip()
                                elif ':' in line and not line.strip().startswith('-'):
                                    parts = line.split(':', 1)
                                    if len(parts) == 2:
                                        gpu_data[parts[0].strip()] = parts[1].strip()

                            if gpu_data.get("Name"):
                                gpu_info["GPU Name"] = gpu_data["Name"]
                                if gpu_data.get("AdapterRAM"):
                                    try:
                                        ram_mb = int(gpu_data["AdapterRAM"]) // (1024 * 1024)
                                        gpu_info["GPU Memory"] = f"{ram_mb} MB"
                                    except:
                                        pass
                                if gpu_data.get("DriverVersion"):
                                    gpu_info["Driver Version"] = gpu_data["DriverVersion"]
                                if gpu_data.get("DriverDate"):
                                    gpu_info["Driver Date"] = gpu_data["DriverDate"]
                                break
                    except (subprocess.TimeoutExpired, subprocess.SubprocessError):
                        continue
            else:
                # For Linux/Mac
                commands = [
                    ["lspci", "-v"],
                    ["lspci"],
                    ["systeminfo"]  # On some systems
                ]

                for cmd in commands:
                    try:
                        result = subprocess.run(cmd, capture_output=True, text=True, timeout=10,
                                                creationflags=CREATE_NO_WINDOW)
                        if result.returncode == 0:
                            for line in result.stdout.split('\n'):
                                if 'VGA' in line or '3D' in line or 'Display' in line:
                                    gpu_info["GPU"] = line.split(':')[1].strip() if ':' in line else line.strip()
                                    break
                            if gpu_info:
                                break
                    except (subprocess.TimeoutExpired, subprocess.SubprocessError, FileNotFoundError):
                        continue
        except Exception:
            pass

        if not gpu_info:
            gpu_info["GPU"] = "Information not available"

        return gpu_info

    def _get_motherboard_info(self):
        """Get motherboard information with multiple fallback methods"""
        motherboard_info = {}

        try:
            if platform.system() == "Windows":
                # Method 1: Try to get system information using systeminfo command
                try:
                    result = subprocess.run(
                        ["systeminfo"],
                        capture_output=True, text=True, timeout=30,
                        creationflags=CREATE_NO_WINDOW
                    )
                    if result.returncode == 0:
                        lines = result.stdout.split('\n')
                        for line in lines:
                            if "System Model:" in line:
                                motherboard_info["System Model"] = line.split(":", 1)[1].strip()
                            elif "System Manufacturer:" in line:
                                motherboard_info["System Manufacturer"] = line.split(":", 1)[1].strip()
                            elif "System Type:" in line:
                                motherboard_info["System Type"] = line.split(":", 1)[1].strip()
                            elif "BIOS Version:" in line:
                                motherboard_info["BIOS Version"] = line.split(":", 1)[1].strip()
                            elif "BIOS Mode:" in line:
                                motherboard_info["BIOS Mode"] = line.split(":", 1)[1].strip()
                except Exception:
                    pass

                # Method 2: Try WMIC commands if systeminfo didn't work
                if not motherboard_info or len(motherboard_info) < 3:
                    commands = [
                        ("wmic baseboard get manufacturer /format:list", "Manufacturer"),
                        ("wmic baseboard get product /format:list", "Product"),
                        ("wmic baseboard get version /format:list", "Version"),
                        ("wmic bios get serialnumber /format:list", "Serial Number"),
                        ("wmic bios get version /format:list", "BIOS Version"),
                        ("wmic csproduct get name,vendor,identifyingnumber /format:list", "System Info")
                    ]

                    for cmd, key in commands:
                        try:
                            result = subprocess.run(cmd.split(), capture_output=True, text=True, timeout=10,
                                                    creationflags=CREATE_NO_WINDOW)
                            if result.returncode == 0:
                                if "System Info" in key:
                                    # Parse system info
                                    for line in result.stdout.split('\n'):
                                        if '=' in line:
                                            k, v = line.split('=', 1)
                                            if k.strip() == "Name":
                                                motherboard_info["System Model"] = v.strip()
                                            elif k.strip() == "Vendor":
                                                motherboard_info["System Manufacturer"] = v.strip()
                                            elif k.strip() == "IdentifyingNumber":
                                                motherboard_info["System Serial"] = v.strip()
                                else:
                                    match = re.search(rf"{key}=(.+)", result.stdout)
                                    if match:
                                        motherboard_info[key] = match.group(1).strip()
                        except (subprocess.TimeoutExpired, subprocess.SubprocessError):
                            continue

                # Method 3: Try PowerShell commands as fallback
                if not motherboard_info or len(motherboard_info) < 3:
                    try:
                        ps_commands = [
                            "Get-ComputerInfo | Select-Object BiosManufacturer,BiosSerialNumber,BiosVersion | Format-List",
                            "Get-WmiObject -Class Win32_BaseBoard | Select-Object Manufacturer,Product,Version,SerialNumber | Format-List",
                            "Get-WmiObject -Class Win32_ComputerSystemProduct | Select-Object Name,Vendor,UUID | Format-List"
                        ]

                        for ps_cmd in ps_commands:
                            try:
                                result = subprocess.run(
                                    ["powershell", "-Command", ps_cmd],
                                    capture_output=True, text=True, timeout=15,
                                    creationflags=CREATE_NO_WINDOW
                                )
                                if result.returncode == 0:
                                    for line in result.stdout.split('\n'):
                                        if ':' in line and not line.strip().startswith('-'):
                                            parts = line.split(':', 1)
                                            if len(parts) == 2:
                                                k = parts[0].strip()
                                                v = parts[1].strip()
                                                if "Manufacturer" in k and "Bios" in k:
                                                    motherboard_info["BIOS Manufacturer"] = v
                                                elif "SerialNumber" in k:
                                                    motherboard_info["BIOS Serial"] = v
                                                elif "Version" in k and "Bios" in k:
                                                    motherboard_info["BIOS Version"] = v
                                                elif "Manufacturer" in k and "Bios" not in k:
                                                    motherboard_info["System Manufacturer"] = v
                                                elif "Product" in k:
                                                    motherboard_info["System Model"] = v
                                                elif "Name" in k:
                                                    motherboard_info["System Model"] = v
                                                elif "Vendor" in k:
                                                    motherboard_info["System Manufacturer"] = v
                                                elif "UUID" in k:
                                                    motherboard_info["System UUID"] = v
                                        if len(motherboard_info) >= 3:
                                            break
                            except Exception:
                                continue
                    except Exception:
                        pass

        except Exception:
            pass

        # If we still don't have enough information, try to get at least basic info
        if not motherboard_info or len(motherboard_info) < 2:
            try:
                # Try to get system manufacturer from registry
                try:
                    result = subprocess.run(
                        ["reg", "query", "HKEY_LOCAL_MACHINE\\HARDWARE\\DESCRIPTION\\System\\BIOS", "/v",
                         "SystemManufacturer"],
                        capture_output=True, text=True, timeout=5,
                        creationflags=CREATE_NO_WINDOW
                    )
                    if result.returncode == 0:
                        match = re.search(r"SystemManufacturer\s+REG_SZ\s+(.+)", result.stdout)
                        if match:
                            motherboard_info["System Manufacturer"] = match.group(1).strip()
                except Exception:
                    pass

                # Try to get system product name from registry
                try:
                    result = subprocess.run(
                        ["reg", "query", "HKEY_LOCAL_MACHINE\\HARDWARE\\DESCRIPTION\\System\\BIOS", "/v",
                         "SystemProductName"],
                        capture_output=True, text=True, timeout=5,
                        creationflags=CREATE_NO_WINDOW
                    )
                    if result.returncode == 0:
                        match = re.search(r"SystemProductName\s+REG_SZ\s+(.+)", result.stdout)
                        if match:
                            motherboard_info["System Model"] = match.group(1).strip()
                except Exception:
                    pass
            except Exception:
                pass

        if not motherboard_info:
            motherboard_info["Error"] = "Information not available"

        return motherboard_info

    def _get_battery_info(self):
        """Get battery information"""
        try:
            battery = psutil.sensors_battery()
            if battery:
                return {
                    "Battery Percentage": f"{battery.percent}%",
                    "Power Plugged": "Yes" if battery.power_plugged else "No",
                    "Time Left": f"{battery.secsleft // 3600}h {(battery.secsleft % 3600) // 60}m" if battery.secsleft != psutil.POWER_TIME_UNLIMITED else "Unlimited"
                }
        except Exception:
            pass
        return None

    def _get_temperature_info(self):
        """Get temperature sensor information"""
        try:
            temps = psutil.sensors_temperatures()
            if temps:
                temp_info = {}
                for name, entries in temps.items():
                    temp_info[name] = {}
                    for entry in entries:
                        temp_info[name][entry.label or "Sensor"] = f"{entry.current:.1f}C"
                        if entry.high:
                            temp_info[name][f"{entry.label or 'Sensor'} High"] = f"{entry.high:.1f}C"
                        if entry.critical:
                            temp_info[name][f"{entry.label or 'Sensor'} Critical"] = f"{entry.critical:.1f}C"
                return temp_info
        except Exception:
            pass
        return None

    def collect_software_info(self):
        """Collect installed software information"""
        software_info = {}

        try:
            if platform.system() == "Windows":
                # Try multiple methods to get installed software
                # Method 1: Try registry-based approach first (more reliable)
                try:
                    # Get software from HKLM
                    registry_paths = [
                        r"SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall",
                        r"SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
                    ]

                    for registry_path in registry_paths:
                        try:
                            with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, registry_path) as key:
                                for i in range(winreg.QueryInfoKey(key)[0]):
                                    try:
                                        subkey_name = winreg.EnumKey(key, i)
                                        with winreg.OpenKey(key, subkey_name) as subkey:
                                            try:
                                                name = winreg.QueryValueEx(subkey, "DisplayName")[0]
                                                version = winreg.QueryValueEx(subkey, "DisplayVersion")[
                                                    0] if "DisplayVersion" in [item[0] for item in winreg.QueryInfoKey(
                                                    subkey)] else "Unknown"
                                                publisher = winreg.QueryValueEx(subkey, "Publisher")[
                                                    0] if "Publisher" in [item[0] for item in
                                                                          winreg.QueryInfoKey(subkey)] else "Unknown"
                                                install_date = winreg.QueryValueEx(subkey, "InstallDate")[
                                                    0] if "InstallDate" in [item[0] for item in
                                                                            winreg.QueryInfoKey(subkey)] else ""

                                                if install_date and len(install_date) == 8:
                                                    install_date = f"{install_date[:4]}-{install_date[4:6]}-{install_date[6:8]}"

                                                software_info[name] = {
                                                    "Version": version,
                                                    "Vendor": publisher,
                                                    "Install Date": install_date
                                                }
                                            except (WindowsError, KeyError):
                                                continue
                                    except (WindowsError, KeyError):
                                        continue
                        except (WindowsError, KeyError):
                            continue

                    # Get software from HKCU
                    try:
                        with winreg.OpenKey(winreg.HKEY_CURRENT_USER,
                                            r"SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall") as key:
                            for i in range(winreg.QueryInfoKey(key)[0]):
                                try:
                                    subkey_name = winreg.EnumKey(key, i)
                                    with winreg.OpenKey(key, subkey_name) as subkey:
                                        try:
                                            name = winreg.QueryValueEx(subkey, "DisplayName")[0]
                                            version = winreg.QueryValueEx(subkey, "DisplayVersion")[
                                                0] if "DisplayVersion" in [item[0] for item in
                                                                           winreg.QueryInfoKey(subkey)] else "Unknown"
                                            publisher = winreg.QueryValueEx(subkey, "Publisher")[0] if "Publisher" in [
                                                item[0] for item in winreg.QueryInfoKey(subkey)] else "Unknown"
                                            install_date = winreg.QueryValueEx(subkey, "InstallDate")[
                                                0] if "InstallDate" in [item[0] for item in
                                                                        winreg.QueryInfoKey(subkey)] else ""

                                            if install_date and len(install_date) == 8:
                                                install_date = f"{install_date[:4]}-{install_date[4:6]}-{install_date[6:8]}"

                                            software_info[name] = {
                                                "Version": version,
                                                "Vendor": publisher,
                                                "Install Date": install_date
                                            }
                                        except (WindowsError, KeyError):
                                            continue
                                except (WindowsError, KeyError):
                                    continue
                    except (WindowsError, KeyError):
                        pass

                    if software_info:
                        self.report_data["software"] = software_info
                        return
                except Exception as e:
                    pass

                # Method 2: Try PowerShell as fallback
                try:
                    ps_script = '''
                    $software = @()
                    $paths = @(
                        "HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*",
                        "HKLM:\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*",
                        "HKCU:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*"
                    )

                    foreach ($path in $paths) {
                        try {
                            Get-ItemProperty $path -ErrorAction SilentlyContinue | Where-Object { $_.DisplayName } | ForEach-Object {
                                $software += [PSCustomObject]@{
                                    Name = $_.DisplayName
                                    Version = $_.DisplayVersion
                                    Publisher = $_.Publisher
                                    InstallDate = $_.InstallDate
                                }
                            }
                        } catch {
                            # Ignore errors
                        }
                    }

                    $software | ConvertTo-Json
                    '''

                    result = subprocess.run(
                        ["powershell", "-Command", ps_script],
                        capture_output=True, text=True, timeout=30,
                        creationflags=CREATE_NO_WINDOW
                    )

                    if result.returncode == 0 and result.stdout.strip():
                        try:
                            software_data = json.loads(result.stdout)
                            for item in software_data:
                                name = item.get("Name", "")
                                if name:
                                    version = item.get("Version", "Unknown")
                                    publisher = item.get("Publisher", "Unknown")
                                    install_date = item.get("InstallDate", "")

                                    if install_date and len(install_date) == 8:
                                        install_date = f"{install_date[:4]}-{install_date[4:6]}-{install_date[6:8]}"

                                    software_info[name] = {
                                        "Version": version,
                                        "Vendor": publisher,
                                        "Install Date": install_date
                                    }
                        except json.JSONDecodeError:
                            pass

                        if software_info:
                            self.report_data["software"] = software_info
                            return
                except Exception:
                    pass

                # Method 3: Try WMIC as last resort
                try:
                    result = subprocess.run(
                        ["wmic", "product", "get", "name,version,vendor,installdate", "/format:csv"],
                        capture_output=True, text=True, timeout=30,
                        creationflags=CREATE_NO_WINDOW
                    )

                    if result.returncode == 0:
                        lines = result.stdout.split('\n')
                        for line in lines[1:]:  # Skip header
                            if line.strip():
                                parts = line.split(',')
                                if len(parts) >= 4 and parts[1].strip():
                                    install_date = parts[4].strip() if len(parts) > 4 else ""
                                    if install_date and len(install_date) == 8:
                                        install_date = f"{install_date[:4]}-{install_date[4:6]}-{install_date[6:8]}"

                                    software_info[parts[1].strip()] = {
                                        "Version": parts[2].strip(),
                                        "Vendor": parts[3].strip(),
                                        "Install Date": install_date
                                    }

                        if software_info:
                            self.report_data["software"] = software_info
                            return
                except Exception:
                    pass

                # If all methods fail, add error message
                software_info["Error"] = "Could not retrieve software information using multiple methods"
            else:
                # For Linux/Mac, try to get installed packages
                if platform.system() == "Linux":
                    # Try dpkg (Debian/Ubuntu)
                    try:
                        result = subprocess.run(
                            ["dpkg-query", "-W", "-f=${Package}\t${Version}\t${Maintainer}\n"],
                            capture_output=True, text=True,
                            creationflags=CREATE_NO_WINDOW
                        )
                        if result.returncode == 0:
                            for line in result.stdout.split('\n'):
                                if line.strip():
                                    parts = line.split('\t')
                                    if len(parts) >= 2:
                                        software_info[parts[0]] = {
                                            "Version": parts[1],
                                            "Vendor": parts[2] if len(parts) > 2 else "Unknown"
                                        }
                    except FileNotFoundError:
                        # Try rpm (RedHat/CentOS)
                        try:
                            result = subprocess.run(
                                ["rpm", "-qa", "--queryformat", "%{NAME}\t%{VERSION}\t%{VENDOR}\n"],
                                capture_output=True, text=True,
                                creationflags=CREATE_NO_WINDOW
                            )
                            if result.returncode == 0:
                                for line in result.stdout.split('\n'):
                                    if line.strip():
                                        parts = line.split('\t')
                                        if len(parts) >= 2:
                                            software_info[parts[0]] = {
                                                "Version": parts[1],
                                                "Vendor": parts[2] if len(parts) > 2 else "Unknown"
                                            }
                        except FileNotFoundError:
                            pass
        except Exception as e:
            software_info["Error"] = f"Could not retrieve software information: {str(e)}"

        self.report_data["software"] = software_info

    def collect_startup_info(self):
        """Collect startup items information"""
        startup_info = {
            "Registry": {},
            "Startup Folders": {}
        }

        try:
            if platform.system() == "Windows":
                # Collect registry startup items
                registry_paths = [
                    (winreg.HKEY_CURRENT_USER, r"SOFTWARE\Microsoft\Windows\CurrentVersion\Run"),
                    (winreg.HKEY_CURRENT_USER, r"SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce"),
                    (winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Windows\CurrentVersion\Run"),
                    (winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce"),
                    (winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Run"),
                    (winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\RunOnce")
                ]

                for root, path in registry_paths:
                    try:
                        with winreg.OpenKey(root, path) as key:
                            key_name = f"HK{'CU' if root == winreg.HKEY_CURRENT_USER else 'LM'}\\{path}"
                            startup_info["Registry"][key_name] = {}

                            for i in range(winreg.QueryInfoKey(key)[0]):
                                try:
                                    name, value, _ = winreg.EnumValue(key, i)
                                    startup_info["Registry"][key_name][name] = {
                                        "Value": value,
                                        "Status": "Enabled"
                                    }
                                except (WindowsError, KeyError):
                                    continue
                    except (WindowsError, KeyError):
                        continue

                # Collect startup folder items
                startup_folders = [
                    os.path.join(os.environ.get('APPDATA', ''), "Microsoft", "Windows", "Start Menu", "Programs", "Startup"),
                    os.path.join(os.environ.get('ProgramData', ''), "Microsoft", "Windows", "Start Menu", "Programs", "Startup")
                ]

                for folder_path in startup_folders:
                    try:
                        if os.path.exists(folder_path):
                            folder_name = os.path.basename(folder_path)
                            startup_info["Startup Folders"][folder_name] = {}

                            for item in os.listdir(folder_path):
                                item_path = os.path.join(folder_path, item)
                                if os.path.isfile(item_path):
                                    startup_info["Startup Folders"][folder_name][item] = {
                                        "Path": item_path,
                                        "Status": "Enabled"
                                    }
                    except Exception:
                        continue

        except Exception as e:
            startup_info["Error"] = f"Could not retrieve startup information: {str(e)}"

        self.report_data["startup_items"] = startup_info

    def _collect_windows_updates(self):
        """Collect Windows update information"""
        try:
            commands = [
                ["wmic", "qfe", "get", "hotfixid,installedon,installedby", "/format:csv"],
                ["wmic", "qfe", "list", "brief"],
                ["powershell", "Get-HotFix | Select-Object HotFixID,InstalledOn | Format-Table"]
            ]

            for cmd in commands:
                try:
                    result = subprocess.run(cmd, capture_output=True, text=True, timeout=30,
                                            creationflags=CREATE_NO_WINDOW)
                    if result.returncode == 0:
                        updates = []
                        lines = result.stdout.split('\n')
                        for line in lines[1:]:  # Skip header
                            if line.strip():
                                parts = line.split(',')
                                if len(parts) >= 4:
                                    updates.append({
                                        "Hotfix ID": parts[1].strip(),
                                        "Installed On": parts[2].strip(),
                                        "Installed By": parts[3].strip()
                                    })
                        if updates:
                            self.report_data["updates"] = updates[:20]  # Last 20 updates
                            break
                except (subprocess.TimeoutExpired, subprocess.SubprocessError):
                    continue
        except Exception:
            self.report_data["updates"] = {"Error": "Could not retrieve update information"}

    def collect_vulnerability_info(self):
        """Collect vulnerability and security update information"""
        vulnerability_info = {}

        try:
            if platform.system() == "Windows":
                # Get Windows Update status
                try:
                    result = subprocess.run(
                        ["powershell", "(Get-WmiObject -Class Win32_QuickFixEngineering).Count"],
                        capture_output=True, text=True, timeout=15,
                        creationflags=CREATE_NO_WINDOW
                    )
                    if result.returncode == 0:
                        try:
                            update_count = int(result.stdout.strip())
                            vulnerability_info["Installed Updates Count"] = str(update_count)
                        except ValueError:
                            pass
                except Exception:
                    pass

                # Check for pending updates
                try:
                    result = subprocess.run(
                        ["powershell",
                         "(New-Object -ComObject Microsoft.Update.Session).CreateUpdateSearcher().Search(\"IsInstalled=0\").Updates.Count"],
                        capture_output=True, text=True, timeout=30,
                        creationflags=CREATE_NO_WINDOW
                    )
                    if result.returncode == 0:
                        try:
                            pending_count = int(result.stdout.strip())
                            if pending_count > 0:
                                vulnerability_info["Pending Updates"] = f"{pending_count} updates available"
                                vulnerability_info["Status"] = "Updates Available"
                            else:
                                vulnerability_info["Pending Updates"] = "No pending updates"
                                vulnerability_info["Status"] = "Up to Date"
                        except ValueError:
                            pass
                except Exception:
                    pass

                # Get last scan date
                try:
                    result = subprocess.run(
                        ["powershell",
                         "(Get-WmiObject -Class Win32_QuickFixEngineering | Sort-Object -Property InstalledOn -Descending | Select-Object -First 1).InstalledOn"],
                        capture_output=True, text=True, timeout=15,
                        creationflags=CREATE_NO_WINDOW
                    )
                    if result.returncode == 0 and result.stdout.strip():
                        vulnerability_info["Last Update Scan"] = result.stdout.strip()
                except Exception:
                    pass

                # Check for Windows Defender status
                try:
                    result = subprocess.run(
                        ["powershell",
                         "Get-MpComputerStatus | Select-Object AntispywareEnabled, AntivirusEnabled, NISEnabled, RealTimeProtectionEnabled | Format-List"],
                        capture_output=True, text=True, timeout=15,
                        creationflags=CREATE_NO_WINDOW
                    )
                    if result.returncode == 0:
                        defender_status = {}
                        for line in result.stdout.split('\n'):
                            if ':' in line and not line.strip().startswith('-'):
                                parts = line.split(':', 1)
                                if len(parts) == 2:
                                    key = parts[0].strip()
                                    value = parts[1].strip()
                                    if value:
                                        defender_status[key] = value
                        if defender_status:
                            vulnerability_info["Windows Defender"] = defender_status
                except Exception:
                    pass

                # Check for Windows version and end of life status
                try:
                    result = subprocess.run(
                        ["powershell",
                         "Get-ComputerInfo | Select-Object WindowsProductName, WindowsVersion, OsVersion | Format-List"],
                        capture_output=True, text=True, timeout=15,
                        creationflags=CREATE_NO_WINDOW
                    )
                    if result.returncode == 0:
                        version_info = {}
                        for line in result.stdout.split('\n'):
                            if ':' in line and not line.strip().startswith('-'):
                                parts = line.split(':', 1)
                                if len(parts) == 2:
                                    key = parts[0].strip()
                                    value = parts[1].strip()
                                    if value:
                                        version_info[key] = value

                        if version_info.get("WindowsProductName"):
                            product_name = version_info["WindowsProductName"]
                            # Check if it's a supported version
                            if "Windows 10" in product_name or "Windows 11" in product_name:
                                vulnerability_info["Windows Support Status"] = "Supported"
                            elif "Windows 7" in product_name or "Windows 8" in product_name or "Windows Server 2012" in product_name:
                                vulnerability_info["Windows Support Status"] = "End of Life - Security Risk"
                            else:
                                vulnerability_info["Windows Support Status"] = "Unknown"
                except Exception:
                    pass

                # Check for firewall status
                try:
                    result = subprocess.run(
                        ["netsh", "advfirewall", "show", "allprofiles"],
                        capture_output=True, text=True, timeout=10,
                        creationflags=CREATE_NO_WINDOW
                    )
                    if result.returncode == 0:
                        firewall_profiles = {}
                        for line in result.stdout.split('\n'):
                            if 'State' in line:
                                parts = line.strip().split()
                                if len(parts) >= 3:
                                    profile = parts[0]
                                    state = parts[2]
                                    firewall_profiles[profile] = state
                        if firewall_profiles:
                            vulnerability_info["Windows Firewall"] = firewall_profiles
                except Exception:
                    pass
        except Exception:
            pass

        self.report_data["vulnerabilities"] = vulnerability_info

    def collect_network_info(self):
        """Collect network information"""
        network_info = {}

        # Get network interfaces
        interfaces = {}
        for interface, addrs in psutil.net_if_addrs().items():
            interface_info = {"IP Addresses": []}
            for addr in addrs:
                if addr.family == socket.AF_INET:
                    interface_info["IP Addresses"].append({
                        "Address": addr.address,
                        "Netmask": addr.netmask,
                        "Broadcast": addr.broadcast
                    })
                elif addr.family == socket.AF_INET6:
                    interface_info["IPv6"] = addr.address
                elif addr.family == psutil.AF_LINK:
                    interface_info["MAC Address"] = addr.address
            interfaces[interface] = interface_info

        # Get network statistics
        net_io = psutil.net_io_counters()
        network_stats = {
            "Bytes Sent": f"{net_io.bytes_sent / (1024 ** 3):.2f} GB",
            "Bytes Received": f"{net_io.bytes_recv / (1024 ** 3):.2f} GB",
            "Packets Sent": f"{net_io.packets_sent:,}",
            "Packets Received": f"{net_io.packets_recv:,}",
            "Errin": f"{net_io.errin}",
            "Errout": f"{net_io.errout}",
            "Dropin": f"{net_io.dropin}",
            "Dropout": f"{net_io.dropout}"
        }

        # Get active connections
        connections = []
        try:
            for conn in psutil.net_connections():
                if conn.status == 'ESTABLISHED':
                    connections.append({
                        "Local Address": f"{conn.laddr.ip}:{conn.laddr.port}" if conn.laddr else "N/A",
                        "Remote Address": f"{conn.raddr.ip}:{conn.raddr.port}" if conn.raddr else "N/A",
                        "Status": conn.status,
                        "PID": conn.pid
                    })
        except Exception:
            pass

        # Get DNS servers
        dns_servers = self._get_dns_servers()

        network_info = {
            "Interfaces": interfaces,
            "Statistics": network_stats,
            "Active Connections": connections[:20],  # Top 20 connections
            "DNS Servers": dns_servers
        }

        self.report_data["network"] = network_info

    def _get_dns_servers(self):
        """Get DNS server information"""
        try:
            if platform.system() == "Windows":
                commands = [
                    ["nslookup", "localhost"],
                    ["ipconfig", "/all"],
                    ["powershell", "Get-DnsClientServerAddress | Select-Object ServerAddresses | Format-List"]
                ]

                for cmd in commands:
                    try:
                        result = subprocess.run(cmd, capture_output=True, text=True, timeout=10,
                                                creationflags=CREATE_NO_WINDOW)
                        if result.returncode == 0:
                            if "nslookup" in cmd[0]:
                                servers = re.findall(r"Server:\s*(.+)", result.stdout)
                                if servers:
                                    return servers
                            else:
                                # Parse DNS servers from ipconfig
                                dns_servers = re.findall(r"DNS Servers[\.:\s]+(.+)", result.stdout)
                                if dns_servers:
                                    return [dns.strip() for dns in dns_servers if dns.strip()]
                    except (subprocess.TimeoutExpired, subprocess.SubprocessError):
                        continue
            else:
                with open("/etc/resolv.conf", "r") as f:
                    content = f.read()
                    servers = re.findall(r"nameserver\s+(.+)", content)
                    return servers if servers else ["Could not determine"]
        except Exception:
            pass
        return ["Could not determine"]

    def collect_security_info(self):
        """Collect security-related information"""
        security_info = {}

        try:
            if platform.system() == "Windows":
                # Get Windows Defender status
                try:
                    commands = [
                        ["powershell",
                         "Get-MpComputerStatus | Select-Object AMServiceEnabled, AntispywareEnabled, AntivirusEnabled, NISEnabled, RealTimeProtectionEnabled, QuickScanAge, FullScanAge"],
                        ["powershell", "Get-MpPreference | Select-Object DisableRealtimeMonitoring"],
                        ["wmic", "/namespace:\\\\root\\securitycenter2", "path", "antivirusproduct", "get",
                         "displayName", "/format:list"]
                    ]

                    for cmd in commands:
                        try:
                            result = subprocess.run(cmd, capture_output=True, text=True, timeout=10,
                                                    creationflags=CREATE_NO_WINDOW)
                            if result.returncode == 0:
                                defender_status = {}
                                for line in result.stdout.split('\n'):
                                    if ':' in line and not line.startswith('-'):
                                        parts = line.split(':', 1)
                                        if len(parts) == 2:
                                            key = parts[0].strip()
                                            value = parts[1].strip()
                                            if value:
                                                defender_status[key] = value
                                if defender_status:
                                    security_info["Windows Defender"] = defender_status
                                    break
                        except (subprocess.TimeoutExpired, subprocess.SubprocessError):
                            continue
                except Exception:
                    security_info["Windows Defender"] = "Status not available"

                # Get Windows Firewall status
                try:
                    result = subprocess.run(
                        ["netsh", "advfirewall", "show", "allprofiles"],
                        capture_output=True, text=True, timeout=10,
                        creationflags=CREATE_NO_WINDOW
                    )
                    if result.returncode == 0:
                        firewall_status = {}
                        for line in result.stdout.split('\n'):
                            if 'State' in line:
                                parts = line.strip().split()
                                if len(parts) >= 3:
                                    profile = parts[0]
                                    state = parts[2]
                                    firewall_status[profile] = state
                        security_info["Windows Firewall"] = firewall_status
                except Exception:
                    security_info["Windows Firewall"] = "Status not available"

                # Get UAC status
                try:
                    result = subprocess.run(
                        ["reg", "query", "HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System", "/v",
                         "EnableLUA"],
                        capture_output=True, text=True, timeout=10,
                        creationflags=CREATE_NO_WINDOW
                    )
                    if result.returncode == 0:
                        uac_enabled = "0x1" in result.stdout
                        security_info["User Account Control"] = "Enabled" if uac_enabled else "Disabled"
                except Exception:
                    security_info["User Account Control"] = "Status not available"
            else:
                security_info["Note"] = "Security software detection not implemented for this OS"
        except Exception as e:
            security_info["Error"] = f"Could not retrieve security information: {str(e)}"

        self.report_data["security"] = security_info

    def collect_user_info(self):
        """Collect user account information"""
        user_info = {}

        try:
            if platform.system() == "Windows":
                # Get user accounts
                try:
                    result = subprocess.run(
                        ["net", "user"],
                        capture_output=True, text=True, timeout=10,
                        creationflags=CREATE_NO_WINDOW
                    )
                    if result.returncode == 0:
                        users = []
                        lines = result.stdout.split('\n')
                        for line in lines:
                            if line.strip() and not line.startswith('-') and not line.startswith('The command'):
                                users.append(line.strip())
                        user_info["User Accounts"] = users
                except Exception:
                    pass

                # Get current user details
                current_user = os.environ.get("USERNAME", "Unknown")
                user_info["Current User"] = current_user

                # Get user groups
                try:
                    result = subprocess.run(
                        ["net", "user", current_user],
                        capture_output=True, text=True, timeout=10,
                        creationflags=CREATE_NO_WINDOW
                    )
                    if result.returncode == 0:
                        groups = []
                        for line in result.stdout.split('\n'):
                            if "Local Group Memberships" in line:
                                groups_line = line.split('*', 1)[1].strip()
                                groups = [g.strip() for g in groups_line.split() if g.strip()]
                                break
                        user_info["User Groups"] = groups
                except Exception:
                    pass
            else:
                # For Linux/Mac, get users from /etc/passwd
                if os.path.exists("/etc/passwd"):
                    users = []
                    with open("/etc/passwd", "r") as f:
                        for line in f:
                            if not line.startswith("#"):
                                parts = line.split(":")
                                if len(parts) >= 1:
                                    users.append(parts[0])
                    user_info["User Accounts"] = users

                user_info["Current User"] = os.environ.get("USER", "Unknown")
        except Exception as e:
            user_info["Error"] = f"Could not retrieve user information: {str(e)}"

        self.report_data["users"] = user_info

    def collect_environment_info(self):
        """Collect environment variables"""
        self.report_data["environment"] = dict(os.environ)

    def collect_process_info(self):
        """Collect running processes"""
        processes = []

        try:
            for proc in psutil.process_iter(
                    ['pid', 'name', 'username', 'cpu_percent', 'memory_percent', 'memory_info', 'create_time']):
                try:
                    create_time = datetime.fromtimestamp(proc.info['create_time']).strftime(
                        "%Y-%m-%d %H:%M:%S")
                    memory_mb = proc.info['memory_info'].rss / (1024 * 1024) if proc.info['memory_info'] else 0

                    processes.append({
                        "PID": proc.info['pid'],
                        "Name": proc.info['name'],
                        "User": proc.info['username'],
                        "CPU %": f"{proc.info['cpu_percent']:.1f}%",
                        "Memory %": f"{proc.info['memory_percent']:.1f}%",
                        "Memory (MB)": f"{memory_mb:.1f}",
                        "Started": create_time
                    })
                except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
                    pass
        except Exception:
            pass

        # Sort by memory usage
        processes.sort(key=lambda x: float(x["Memory %"].rstrip('%')), reverse=True)
        self.report_data["processes"] = processes[:30]  # Top 30 processes

    def collect_service_info(self):
        """Collect system services"""
        services = []

        try:
            if platform.system() == "Windows":
                # Get Windows services
                commands = [
                    ["sc", "query", "type=", "service", "state=", "all"],
                    ["powershell", "Get-Service | Select-Object Name,Status,StartType | Format-Table"]
                ]

                for cmd in commands:
                    try:
                        result = subprocess.run(cmd, capture_output=True, text=True, timeout=30,
                                                creationflags=CREATE_NO_WINDOW)
                        if result.returncode == 0:
                            lines = result.stdout.split('\n')
                            current_service = {}
                            for line in lines:
                                if line.strip():
                                    if "SERVICE_NAME:" in line:
                                        if current_service:
                                            services.append(current_service)
                                        current_service = {"Name": line.split(":", 1)[1].strip()}
                                    elif "DISPLAY_NAME:" in line:
                                        current_service["Display Name"] = line.split(":", 1)[1].strip()
                                    elif "TYPE" in line:
                                        current_service["Type"] = line.split(":", 1)[1].strip()
                                    elif "STATE" in line:
                                        current_service["State"] = line.split(":", 1)[1].strip()
                                    elif "START_TYPE" in line:
                                        current_service["Start Type"] = line.split(":", 1)[1].strip()
                            if current_service:
                                services.append(current_service)
                            if services:
                                break
                    except (subprocess.TimeoutExpired, subprocess.SubprocessError):
                        continue
            else:
                # For Linux/Mac, try to get systemd services
                if platform.system() == "Linux":
                    try:
                        result = subprocess.run(
                            ["systemctl", "list-units", "--type=service", "--no-pager"],
                            capture_output=True, text=True, timeout=30,
                            creationflags=CREATE_NO_WINDOW
                        )
                        if result.returncode == 0:
                            lines = result.stdout.split('\n')
                            for line in lines[1:]:  # Skip header
                                if line.strip() and not line.startswith('UNIT'):
                                    parts = line.split()
                                    if len(parts) >= 4:
                                        services.append({
                                            "Name": parts[0],
                                            "Load": parts[1],
                                            "Active": parts[2],
                                            "State": parts[3],
                                            "Description": " ".join(parts[4:]) if len(parts) > 4 else ""
                                        })
                    except (subprocess.TimeoutExpired, subprocess.SubprocessError, FileNotFoundError):
                        pass
        except Exception as e:
            services.append({"Error": f"Could not retrieve service information: {str(e)}"})

        self.report_data["services"] = services[:50]  # Top 50 services

    def collect_device_info(self):
        """Collect hardware devices with improved Windows support"""
        devices = []

        try:
            if platform.system() == "Windows":
                # Try multiple methods to get device information
                commands = [
                    ["wmic", "path", "win32_PnPEntity", "get", "name,deviceid,description,manufacturer",
                     "/format:csv"],
                    ["wmic", "path", "win32_PnPEntity", "get", "name,description", "/format:list"],
                    ["powershell", "Get-PnpDevice | Select-Object FriendlyName,DeviceID,Status | Format-Table"],
                    ["powershell",
                     "Get-WmiObject -Class Win32_PnPEntity | Select-Object Name,DeviceID,Description,Manufacturer | Format-Table"],
                    ["devcon", "list"]  # If devcon is available
                ]

                for cmd in commands:
                    try:
                        result = subprocess.run(cmd, capture_output=True, text=True, timeout=30,
                                                creationflags=CREATE_NO_WINDOW)
                        if result.returncode == 0:
                            lines = result.stdout.split('\n')
                            for line in lines[1:]:  # Skip header
                                if line.strip():
                                    parts = line.split(',')
                                    if len(parts) >= 5 and parts[1].strip():
                                        devices.append({
                                            "Name": parts[1].strip(),
                                            "Description": parts[2].strip(),
                                            "Manufacturer": parts[3].strip(),
                                            "Device ID": parts[4].strip()
                                        })
                                    elif len(parts) >= 3 and parts[0].strip():
                                        # Alternative format
                                        devices.append({
                                            "Name": parts[0].strip(),
                                            "Description": parts[1].strip() if len(parts) > 1 else "",
                                            "Manufacturer": parts[2].strip() if len(parts) > 2 else "",
                                            "Device ID": "N/A"
                                        })
                                if devices:
                                    break
                    except (subprocess.TimeoutExpired, subprocess.SubprocessError, FileNotFoundError):
                        continue

                # If still no devices, try to get basic device categories
                if not devices:
                    try:
                        device_classes = [
                            "win32_Processor",
                            "win32_VideoController",
                            "win32_SoundDevice",
                            "win32_NetworkAdapter",
                            "win32_DiskDrive",
                            "win32_BaseBoard"
                        ]

                        for device_class in device_classes:
                            try:
                                result = subprocess.run(
                                    ["wmic", "path", device_class, "get", "name,manufacturer", "/format:list"],
                                    capture_output=True, text=True, timeout=10,
                                    creationflags=CREATE_NO_WINDOW
                                )
                                if result.returncode == 0:
                                    device_data = {}
                                    for line in result.stdout.split('\n'):
                                        if '=' in line:
                                            key, value = line.split('=', 1)
                                            device_data[key.strip()] = value.strip()

                                    if device_data.get("Name"):
                                        devices.append({
                                            "Name": device_data["Name"],
                                            "Description": device_class.split('_')[1],
                                            "Manufacturer": device_data.get("Manufacturer", "Unknown"),
                                            "Device ID": "N/A"
                                        })
                            except Exception:
                                continue
                    except Exception:
                        pass

            else:
                # For Linux/Mac, try to get devices from lspci
                commands = [
                    ["lspci", "-v"],
                    ["lspci"],
                    ["lsusb"]  # USB devices
                ]

                for cmd in commands:
                    try:
                        result = subprocess.run(cmd, capture_output=True, text=True, timeout=10,
                                                creationflags=CREATE_NO_WINDOW)
                        if result.returncode == 0:
                            current_device = {}
                            for line in result.stdout.split('\n'):
                                if line.strip() and not line.startswith('\t'):
                                    if current_device:
                                        devices.append(current_device)
                                    parts = line.split(':', 1)
                                    if len(parts) >= 2:
                                        current_device = {
                                            "ID": parts[0].strip(),
                                            "Name": parts[1].strip(),
                                            "Description": cmd[0].upper()
                                        }
                                elif line.strip().startswith('\t') and current_device:
                                    if "Subsystem:" in line:
                                        current_device["Subsystem"] = line.split(':', 1)[1].strip()
                            if current_device:
                                devices.append(current_device)
                            if devices:
                                break
                    except (subprocess.TimeoutExpired, subprocess.SubprocessError, FileNotFoundError):
                        continue
        except Exception as e:
            devices.append({"Error": f"Could not retrieve device information: {str(e)}"})

        self.report_data["devices"] = devices[:100]  # Top 100 devices

    def collect_performance_metrics(self):
        """Collect performance metrics"""
        perf_data = {}

        # CPU load average (Linux/Mac) or CPU usage history
        if hasattr(psutil, 'getloadavg'):
            perf_data["Load Average"] = psutil.getloadavg()

        # Memory pressure
        mem = psutil.virtual_memory()
        perf_data["Memory Pressure"] = {
            "Available": f"{mem.available / (1024 ** 3):.2f} GB",
            "Percent Used": f"{mem.percent}%"
        }

        # Disk usage summary
        disk_usage = {}
        for partition in psutil.disk_partitions():
            try:
                usage = psutil.disk_usage(partition.mountpoint)
                disk_usage[partition.device] = {
                    "Used": f"{usage.percent}%",
                    "Free": f"{usage.free / (1024 ** 3):.2f} GB"
                }
            except:
                continue
        perf_data["Disk Usage"] = disk_usage

        self.report_data["performance"] = perf_data

    def generate_html_report(self):
        """Generate HTML report from collected data"""
        html_content = """<!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>PC System Report</title>
            <style>
                * {
                    margin: 0;
                    padding: 0;
                    box-sizing: border-box;
                }

                body {
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
                    line-height: 1.6;
                    color: #2c3e50;
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    min-height: 100vh;
                    padding: 20px;
                }

                .container {
                    max-width: 1400px;
                    margin: 0 auto;
                    background: white;
                    border-radius: 20px;
                    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
                    overflow: hidden;
                }

                header {
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    padding: 40px;
                    text-align: center;
                }

                h1 {
                    font-size: 2.5rem;
                    font-weight: 700;
                    margin-bottom: 10px;
                    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
                }

                .subtitle {
                    font-size: 1.1rem;
                    opacity: 0.9;
                }

                .summary-cards {
                    display: grid;
                    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
                    gap: 20px;
                    padding: 30px;
                    background: #f8f9fa;
                }

                .card {
                    background: white;
                    border-radius: 15px;
                    padding: 25px;
                    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
                    transition: transform 0.3s ease, box-shadow 0.3s ease;
                }

                .card:hover {
                    transform: translateY(-5px);
                    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
                }

                .card h3 {
                    color: #667eea;
                    font-size: 1.1rem;
                    margin-bottom: 15px;
                    display: flex;
                    align-items: center;
                }

                .card h3::before {
                    content: '';
                    width: 4px;
                    height: 20px;
                    background: #667eea;
                    margin-right: 10px;
                    border-radius: 2px;
                }

                .card-value {
                    font-size: 1.8rem;
                    font-weight: 700;
                    color: #2c3e50;
                    margin-bottom: 5px;
                }

                .card-label {
                    color: #7f8c8d;
                    font-size: 0.9rem;
                }

                .content {
                    padding: 30px;
                }

                .section {
                    margin-bottom: 40px;
                }

                h2 {
                    color: #2c3e50;
                    font-size: 1.8rem;
                    margin-bottom: 20px;
                    padding-bottom: 10px;
                    border-bottom: 3px solid #667eea;
                    display: flex;
                    align-items: center;
                }

                h2::before {
                    content: '';
                    width: 8px;
                    height: 30px;
                    background: #667eea;
                    margin-right: 15px;
                    border-radius: 4px;
                }

                h3 {
                    color: #34495e;
                    font-size: 1.3rem;
                    margin-top: 25px;
                    margin-bottom: 15px;
                    padding-left: 15px;
                    border-left: 3px solid #667eea;
                }

                table {
                    width: 100%;
                    border-collapse: collapse;
                    margin-bottom: 20px;
                    background: white;
                    border-radius: 10px;
                    overflow: hidden;
                    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
                }

                th, td {
                    padding: 15px;
                    text-align: left;
                    border-bottom: 1px solid #ecf0f1;
                }

                th {
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    font-weight: 600;
                    text-transform: uppercase;
                    font-size: 0.85rem;
                    letter-spacing: 0.5px;
                }

                tr:nth-child(even) {
                    background: #f8f9fa;
                }

                tr:hover {
                    background: #e8f4fd;
                    transition: background 0.3s ease;
                }

                .key {
                    font-weight: 600;
                    color: #2c3e50;
                    width: 35%;
                }

                .value {
                    color: #34495e;
                    word-break: break-word;
                }

                .nested-table {
                    margin-left: 20px;
                    width: calc(100% - 20px);
                    margin-top: 10px;
                }

                .collapsible {
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    cursor: pointer;
                    padding: 18px 25px;
                    width: 100%;
                    border: none;
                    text-align: left;
                    outline: none;
                    font-size: 1rem;
                    font-weight: 600;
                    border-radius: 10px;
                    margin-bottom: 10px;
                    transition: all 0.3s ease;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                }

                .collapsible:hover {
                    transform: translateY(-2px);
                    box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
                }

                .collapsible::after {
                    content: '+';
                    font-size: 1.5rem;
                    transition: transform 0.3s ease;
                }

                .collapsible.active::after {
                    transform: rotate(45deg);
                }

                .content-collapsible {
                    padding: 0;
                    display: none;
                    overflow: hidden;
                    background: white;
                    margin-bottom: 20px;
                    border-radius: 10px;
                    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
                }

                .progress-bar {
                    width: 100%;
                    background-color: #ecf0f1;
                    border-radius: 10px;
                    height: 25px;
                    margin-top: 8px;
                    overflow: hidden;
                }

                .progress {
                    height: 100%;
                    background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
                    border-radius: 10px;
                    text-align: center;
                    color: white;
                    line-height: 25px;
                    font-weight: 600;
                    font-size: 0.9rem;
                    transition: width 0.5s ease;
                }

                .badge {
                    display: inline-block;
                    padding: 4px 12px;
                    background: #667eea;
                    color: white;
                    border-radius: 20px;
                    font-size: 0.85rem;
                    font-weight: 600;
                    margin-left: 10px;
                }

                .badge.success {
                    background: #27ae60;
                }

                .badge.warning {
                    background: #f39c12;
                }

                .badge.danger {
                    background: #e74c3c;
                }

                .alert {
                    padding: 15px;
                    margin-bottom: 20px;
                    border-radius: 10px;
                    display: flex;
                    align-items: center;
                }

                .alert.danger {
                    background-color: #fdecea;
                    border-left: 5px solid #e74c3c;
                    color: #e74c3c;
                }

                .alert.warning {
                    background-color: #fef9e7;
                    border-left: 5px solid #f39c12;
                    color: #f39c12;
                }

                .alert.success {
                    background-color: #eafaf1;
                    border-left: 5px solid #27ae60;
                    color: #27ae60;
                }

                .alert-icon {
                    margin-right: 15px;
                    font-size: 1.5rem;
                }

                footer {
                    background: #2c3e50;
                    color: white;
                    text-align: center;
                    padding: 30px;
                    font-size: 0.9rem;
                }

                .highlight {
                    background: linear-gradient(120deg, #a8edea 0%, #fed6e3 100%);
                    padding: 2px 6px;
                    border-radius: 4px;
                    font-weight: 600;
                }

                .startup-enabled {
                    color: #27ae60;
                    font-weight: 600;
                }

                .startup-disabled {
                    color: #e74c3c;
                    font-weight: 600;
                }

                @media (max-width: 768px) {
                    .container {
                        border-radius: 0;
                    }

                    h1 {
                        font-size: 2rem;
                    }

                    .summary-cards {
                        grid-template-columns: 1fr;
                        padding: 20px;
                    }

                    .content {
                        padding: 20px;
                    }

                    table {
                        font-size: 0.9rem;
                    }

                    th, td {
                        padding: 10px;
                    }
                }
            </style>
        </head>
        <body>
            <div class="container">
                <header>
                    <h1>PC System Report</h1>
                    <p class="subtitle">Generated on """ + self.report_data["system_info"]["Report Generated"] + """</p>
                </header>

                <div class="summary-cards">
                    <div class="card">
                        <h3>System</h3>
                        <div class="card-value">""" + self.report_data["system_info"]["Operating System"] + """</div>
                        <div class="card-label">Operating System</div>
                    </div>
                    <div class="card">
                        <h3>Processor</h3>
                        <div class="card-value">""" + str(self.report_data["hardware"]["CPU"]["Total Cores"]) + """</div>
                        <div class="card-label">CPU Cores</div>
                    </div>
                    <div class="card">
                        <h3>Memory</h3>
                        <div class="card-value">""" + self.report_data["hardware"]["Memory"]["Total Memory"] + """</div>
                        <div class="card-label">Total RAM</div>
                    </div>
                    <div class="card">
                        <h3>Uptime</h3>
                        <div class="card-value">""" + self.report_data["system_info"]["System Uptime"].split(',')[0] + """</div>
                        <div class="card-label">System Running</div>
                    </div>
                </div>

                <div class="content">
                    """ + self._generate_security_alerts() + """

                    <div class="section">
                        <h2>System Information</h2>
                        <table>
                            """ + self._generate_dict_table(self.report_data["system_info"]) + """
                        </table>
                    </div>

                    <div class="section">
                        <h2>Hardware Information</h2>
                        """ + self._generate_hardware_tables() + """
                    </div>

                    <div class="section">
                        <h2>Software Information <span class="badge">""" + str(len(self.report_data["software"])) + """</span></h2>
                        <button type="button" class="collapsible">View Installed Software</button>
                        <div class="content-collapsible">
                            <table>
                                """ + self._generate_dict_table(self.report_data["software"]) + """
                            </table>
                        </div>
                    </div>

                    """ + self._generate_updates_section() + """

                    <div class="section">
                        <h2>Security Vulnerabilities</h2>
                        """ + self._generate_vulnerability_section() + """
                    </div>

                    <div class="section">
                        <h2>Network Information</h2>
                        """ + self._generate_network_tables() + """
                    </div>

                    <div class="section">
                        <h2>Security Information</h2>
                        <table>
                            """ + self._generate_security_table(self.report_data["security"]) + """
                        </table>
                    </div>

                    <div class="section">
                        <h2>User Information</h2>
                        <table>
                            """ + self._generate_users_table(self.report_data["users"]) + """
                        </table>
                    </div>

                    <div class="section">
                        <h2>Startup Items <span class="badge">""" + str(self._count_startup_items()) + """</span></h2>
                        <button type="button" class="collapsible">View Startup Items</button>
                        <div class="content-collapsible">
                            """ + self._generate_startup_items_table() + """
                        </div>
                    </div>

                    <div class="section">
                        <h2>Running Processes <span class="badge">""" + str(len(self.report_data["processes"])) + """</span></h2>
                        <table>
                            """ + self._generate_processes_table(self.report_data["processes"]) + """
                        </table>
                    </div>

                    <div class="section">
                        <h2>System Services <span class="badge">""" + str(len(self.report_data["services"])) + """</span></h2>
                        <button type="button" class="collapsible">View System Services</button>
                        <div class="content-collapsible">
                            <table>
                                """ + self._generate_services_table(self.report_data["services"]) + """
                            </table>
                        </div>
                    </div>

                    <div class="section">
                        <h2>Hardware Devices <span class="badge">""" + str(len(self.report_data["devices"])) + """</span></h2>
                        <button type="button" class="collapsible">View Hardware Devices</button>
                        <div class="content-collapsible">
                            <table>
                                """ + self._generate_devices_table(self.report_data["devices"]) + """
                            </table>
                        </div>
                    </div>

                    <div class="section">
                        <h2>Environment Variables <span class="badge">""" + str(len(self.report_data["environment"])) + """</span></h2>
                        <button type="button" class="collapsible">View Environment Variables</button>
                        <div class="content-collapsible">
                            <table>
                                """ + self._generate_dict_table(self.report_data["environment"]) + """
                            </table>
                        </div>
                    </div>
                </div>

                <footer>
                    <p>PC Reporter - Comprehensive System Analysis Tool</p>
                    <p>Report generated on """ + self.report_data["system_info"]["Report Generated"] + """</p>
                </footer>
            </div>

            <script>
                var coll = document.getElementsByClassName("collapsible");
                var i;

                for (i = 0; i < coll.length; i++) {
                    coll[i].addEventListener("click", function() {
                        this.classList.toggle("active");
                        var content = this.nextElementSibling;
                        if (content.style.display === "block") {
                            content.style.display = "none";
                        } else {
                            content.style.display = "block";
                        }
                    });
                }

                // Add smooth scroll behavior
                document.querySelectorAll('a[href^="#"]').forEach(anchor => {
                    anchor.addEventListener("click", function (e) {
                        e.preventDefault();
                        document.querySelector(this.getAttribute("href")).scrollIntoView({
                            behavior: "smooth"
                        });
                    });
                });
            </script>
        </body>
        </html>"""

        # Write to file with UTF-8 encoding
        try:
            with open(self.report_file, "w", encoding='utf-8') as f:
                f.write(html_content)
        except Exception as e:
            print(f"Error writing HTML file: {e}")
            # Fallback: try without encoding parameter
            with open(self.report_file, "w") as f:
                f.write(html_content)

        return self.report_file

    def _count_startup_items(self):
        """Count the total number of startup items"""
        count = 0
        if "startup_items" in self.report_data:
            startup_data = self.report_data["startup_items"]
            for category, items in startup_data.items():
                if isinstance(items, dict):
                    for subcategory, subitems in items.items():
                        if isinstance(subitems, dict):
                            count += len(subitems)
        return count

    def _generate_startup_items_table(self):
        """Generate HTML table for startup items"""
        if "startup_items" not in self.report_data or not self.report_data["startup_items"]:
            return "<p>No startup items information available.</p>"

        startup_data = self.report_data["startup_items"]
        html = ""

        for category, items in startup_data.items():
            if isinstance(items, dict):
                html += f"<h3>{category}</h3>"
                for subcategory, subitems in items.items():
                    if isinstance(subitems, dict):
                        html += f"<h4>{subcategory}</h4>"
                        html += "<table>"
                        html += "<tr><th>Name</th><th>Value/Path</th><th>Status</th></tr>"
                        for name, info in subitems.items():
                            if isinstance(info, dict):
                                value_path = info.get("Value", info.get("Path", "N/A"))
                                status = info.get("Status", "Unknown")
                                status_class = "startup-enabled" if status == "Enabled" else "startup-disabled" if status == "Disabled" else ""
                                html += f"<tr><td>{name}</td><td>{value_path}</td><td class='{status_class}'>{status}</td></tr>"
                        html += "</table>"

        return html

    def _generate_security_alerts(self):
        """Generate security alerts based on vulnerability information"""
        alerts = ""

        if "vulnerabilities" in self.report_data and self.report_data["vulnerabilities"]:
            vuln = self.report_data["vulnerabilities"]

            # Check for pending updates
            if vuln.get("Status") == "Updates Available":
                alerts += """
                        <div class="alert warning">
                            <div class="alert-icon"></div>
                            <div>
                                <strong>Security Updates Available</strong><br>
                                Your system has pending security updates. Please install them as soon as possible to protect against vulnerabilities.
                            </div>
                        </div>
                        """

            # Check for Windows support status
            if vuln.get("Windows Support Status") == "End of Life - Security Risk":
                alerts += """
                        <div class="alert danger">
                            <div class="alert-icon"></div>
                            <div>
                                <strong>Unsupported Windows Version</strong><br>
                                Your Windows version is no longer supported by Microsoft. This means you won't receive security updates and are at high risk. Consider upgrading to a supported version.
                            </div>
                        </div>
                        """

            # Check for Windows Defender status
            if "Windows Defender" in vuln:
                defender = vuln["Windows Defender"]
                if isinstance(defender, dict):
                    if defender.get("RealTimeProtectionEnabled") == "False":
                        alerts += """
                                <div class="alert danger">
                                    <div class="alert-icon"></div>
                                    <div>
                                        <strong>Real-time Protection Disabled</strong><br>
                                        Windows Defender real-time protection is disabled. Your system is not protected against malware in real-time.
                                    </div>
                                </div>
                                """
                    elif defender.get("AntivirusEnabled") == "False":
                        alerts += """
                                <div class="alert danger">
                                    <div class="alert-icon"></div>
                                    <div>
                                        <strong>Antivirus Disabled</strong><br>
                                        Windows Defender antivirus is disabled. Your system is not protected against viruses and malware.
                                    </div>
                                </div>
                                """

            # Check for firewall status
            if "Windows Firewall" in vuln:
                firewall = vuln["Windows Firewall"]
                if isinstance(firewall, dict):
                    for profile, status in firewall.items():
                        if status.lower() == "off":
                            alerts += f"""
                                    <div class="alert danger">
                                        <div class="alert-icon"></div>
                                        <div>
                                            <strong>Firewall Disabled</strong><br>
                                            Windows Firewall is turned off for the {profile} profile. Your system may be vulnerable to network attacks.
                                        </div>
                                    </div>
                                    """
                            break  # Only show one firewall alert

        return alerts

    def _generate_vulnerability_section(self):
        """Generate HTML for the vulnerability section"""
        if "vulnerabilities" not in self.report_data or not self.report_data["vulnerabilities"]:
            return "<p>No vulnerability information available.</p>"

        vuln = self.report_data["vulnerabilities"]
        rows = ""

        for key, value in vuln.items():
            if key == "Windows Defender" and isinstance(value, dict):
                rows += f"<tr><td class='key'>{key}</td><td class='value'><table class='nested-table'>"
                for sub_key, sub_value in value.items():
                    status = "success" if "True" in str(sub_value) else "danger" if "False" in str(
                        sub_value) else ""
                    badge = f" <span class='badge {status}'>{sub_value}</span>" if status else f" {sub_value}"
                    rows += f"<tr><td class='key'>{sub_key}</td><td class='value'>{badge}</td></tr>"
                rows += "</table></td></tr>"
            elif key == "Windows Firewall" and isinstance(value, dict):
                rows += f"<tr><td class='key'>{key}</td><td class='value'><table class='nested-table'>"
                for profile, status in value.items():
                    status_class = "success" if status.lower() == "on" else "danger" if status.lower() == "off" else ""
                    badge = f" <span class='badge {status_class}'>{status}</span>" if status_class else f" {status}"
                    rows += f"<tr><td class='key'>{profile}</td><td class='value'>{badge}</td></tr>"
                rows += "</table></td></tr>"
            elif key == "Status":
                status_class = "success" if value == "Up to Date" else "warning" if value == "Updates Available" else ""
                badge = f" <span class='badge {status_class}'>{value}</span>" if status_class else f" {value}"
                rows += f"<tr><td class='key'>{key}</td><td class='value'>{badge}</td></tr>"
            elif key == "Windows Support Status":
                status_class = "success" if value == "Supported" else "danger" if "End of Life" in value else ""
                badge = f" <span class='badge {status_class}'>{value}</span>" if status_class else f" {value}"
                rows += f"<tr><td class='key'>{key}</td><td class='value'>{badge}</td></tr>"
            else:
                rows += f"<tr><td class='key'>{key}</td><td class='value'>{value}</td></tr>"

        return f"<table>{rows}</table>"

    def _generate_updates_section(self):
        """Generate Windows updates section"""
        if "updates" in self.report_data and self.report_data["updates"]:
            return """
                    <div class="section">
                        <h2>Windows Updates <span class="badge">""" + str(len(self.report_data["updates"])) + """</span></h2>
                        <button type="button" class="collapsible">View Recent Updates</button>
                        <div class="content-collapsible">
                            <table>
                                """ + self._generate_updates_table(self.report_data["updates"]) + """
                            </table>
                        </div>
                    </div>
                    """
        return ""

    def _generate_updates_table(self, data):
        """Generate HTML table for Windows updates"""
        if isinstance(data, dict) and "Error" in data:
            return f"<tr><td colspan='3'>{data['Error']}</td></tr>"

        rows = "<tr><th>Hotfix ID</th><th>Installed On</th><th>Installed By</th></tr>"
        for update in data:
            rows += f"<tr><td>{update.get('Hotfix ID', '')}</td><td>{update.get('Installed On', '')}</td><td>{update.get('Installed By', '')}</td></tr>"

        return rows

    def _generate_hardware_tables(self):
        """Generate HTML tables for hardware information"""
        hardware_tables = ""
        for category, data in self.report_data["hardware"].items():
            if isinstance(data, dict):
                hardware_tables += f"<h3>{category}</h3>"
                if category == "Storage":
                    hardware_tables += self._generate_storage_table(data)
                elif category == "CPU" and "CPU Usage Per Core" in data:
                    hardware_tables += self._generate_cpu_table(data)
                else:
                    hardware_tables += self._generate_dict_table(data)
        return hardware_tables

    def _generate_cpu_table(self, data):
        """Generate HTML table for CPU information with per-core usage"""
        rows = ""
        for key, value in data.items():
            if key == "CPU Usage Per Core":
                rows += f"<tr><td class='key'>{key}</td><td class='value'>"
                for core, usage in value.items():
                    rows += f"<div style='margin-bottom: 5px;'>Core {core}: <span class='highlight'>{usage}%</span></div>"
                rows += "</td></tr>"
            else:
                rows += f"<tr><td class='key'>{key}</td><td class='value'>{value}</td></tr>"
        return rows

    def _generate_network_tables(self):
        """Generate HTML tables for network information"""
        network_tables = ""
        for category, data in self.report_data["network"].items():
            if category == "Interfaces":
                network_tables += "<h3>Network Interfaces</h3>"
                network_tables += self._generate_interfaces_table(data)
            elif category == "Active Connections":
                network_tables += "<h3>Active Connections</h3>"
                network_tables += self._generate_connections_table(data)
            elif category == "DNS Servers":
                network_tables += "<h3>DNS Servers</h3>"
                network_tables += self._generate_list_table(data, "DNS Server")
            else:
                network_tables += f"<h3>{category}</h3>"
                network_tables += self._generate_dict_table(data)
        return network_tables

    def _generate_list_table(self, data, label):
        """Generate HTML table from list data"""
        if not data:
            return "<tr><td>No data available</td></tr>"

        rows = ""
        for item in data:
            rows += f"<tr><td class='value'><div class='highlight'>{item}</div></td></tr>"

        return rows

    def _generate_connections_table(self, data):
        """Generate HTML table for active connections"""
        if not data:
            return "<tr><td colspan='4'>No active connections</td></tr>"

        rows = "<tr><th>Local Address</th><th>Remote Address</th><th>Status</th><th>PID</th></tr>"
        for conn in data:
            rows += f"<tr><td>{conn['Local Address']}</td><td>{conn['Remote Address']}</td><td>{conn['Status']}</td><td>{conn['PID']}</td></tr>"

        return rows

    def _generate_dict_table(self, data):
        """Generate HTML table from dictionary data"""
        if not data:
            return "<tr><td colspan='2'>No data available</td></tr>"

        rows = ""
        for key, value in data.items():
            if isinstance(value, dict):
                rows += f"<tr><td class='key'>{key}</td><td class='value'><table class='nested-table'>"
                for sub_key, sub_value in value.items():
                    rows += f"<tr><td class='key'>{sub_key}</td><td class='value'>{sub_value}</td></tr>"
                rows += "</table></td></tr>"
            else:
                rows += f"<tr><td class='key'>{key}</td><td class='value'>{value}</td></tr>"

        return rows

    def _generate_storage_table(self, data):
        """Generate HTML table for storage information"""
        if not data:
            return "<tr><td colspan='2'>No storage information available</td></tr>"

        rows = ""
        for drive, info in data.items():
            rows += f"<tr><td class='key'>{drive}</td><td class='value'><table class='nested-table'>"
            for key, value in info.items():
                if key == "Percentage":
                    # Add a progress bar for percentage
                    rows += f"<tr><td class='key'>{key}</td><td class='value'>"
                    rows += f"<div class='progress-bar'><div class='progress' style='width:{value}'>{value}</div></div>"
                    rows += "</td></tr>"
                else:
                    rows += f"<tr><td class='key'>{key}</td><td class='value'>{value}</td></tr>"
            rows += "</table></td></tr>"

        return rows

    def _generate_interfaces_table(self, data):
        """Generate HTML table for network interfaces"""
        if not data:
            return "<tr><td colspan='2'>No network interface information available</td></tr>"

        rows = ""
        for interface, info in data.items():
            rows += f"<tr><td class='key'>{interface}</td><td class='value'><table class='nested-table'>"
            for key, value in info.items():
                if key == "IP Addresses" and isinstance(value, list):
                    rows += f"<tr><td class='key'>{key}</td><td class='value'>"
                    for ip in value:
                        rows += f"<div class='highlight'>{ip['Address']}</div> Netmask: {ip['Netmask']}<br>"
                    rows += "</td></tr>"
                else:
                    rows += f"<tr><td class='key'>{key}</td><td class='value'>{value}</td></tr>"
            rows += "</table></td></tr>"

        return rows

    def _generate_security_table(self, data):
        """Generate HTML table for security information"""
        if not data:
            return "<tr><td colspan='2'>No security information available</td></tr>"

        rows = ""
        for key, value in data.items():
            if isinstance(value, dict):
                rows += f"<tr><td class='key'>{key}</td><td class='value'><table class='nested-table'>"
                for sub_key, sub_value in value.items():
                    status = "success" if "Enabled" in str(sub_value) or "On" in str(
                        sub_value) else "danger" if "Disabled" in str(sub_value) or "Off" in str(sub_value) else ""
                    badge = f" <span class='badge {status}'>{sub_value}</span>" if status else f" {sub_value}"
                    rows += f"<tr><td class='key'>{sub_key}</td><td class='value'>{badge}</td></tr>"
                rows += "</table></td></tr>"
            else:
                rows += f"<tr><td class='key'>{key}</td><td class='value'>{value}</td></tr>"

        return rows

    def _generate_users_table(self, data):
        """Generate HTML table for user information"""
        if not data:
            return "<tr><td colspan='2'>No user information available</td></tr>"

        rows = ""
        for key, value in data.items():
            if key == "User Accounts" and isinstance(value, list):
                rows += f"<tr><td class='key'>{key}</td><td class='value'>"
                for user in value:
                    rows += f"<div class='highlight'>{user}</div>"
                rows += "</td></tr>"
            elif key == "User Groups" and isinstance(value, list):
                rows += f"<tr><td class='key'>{key}</td><td class='value'>"
                for group in value:
                    rows += f"<span class='badge'>{group}</span> "
                rows += "</td></tr>"
            else:
                rows += f"<tr><td class='key'>{key}</td><td class='value'>{value}</td></tr>"

        return rows

    def _generate_processes_table(self, data):
        """Generate HTML table for processes"""
        if not data:
            return "<tr><td colspan='6'>No process information available</td></tr>"

        rows = "<tr><th>PID</th><th>Name</th><th>User</th><th>CPU %</th><th>Memory %</th><th>Memory (MB)</th><th>Started</th></tr>"
        for process in data:
            rows += f"<tr><td>{process['PID']}</td><td>{process['Name']}</td><td>{process['User']}</td><td>{process['CPU %']}</td><td>{process['Memory %']}</td><td>{process['Memory (MB)']}</td><td>{process['Started']}</td></tr>"

        return rows

    def _generate_services_table(self, data):
        """Generate HTML table for services"""
        if not data:
            return "<tr><td colspan='5'>No service information available</td></tr>"

        # Determine headers based on the first service
        if data and isinstance(data[0], dict):
            headers = list(data[0].keys())
            rows = "<tr>" + "".join([f"<th>{h}</th>" for h in headers]) + "</tr>"

            for service in data:
                rows += "<tr>"
                for header in headers:
                    value = service.get(header, '')
                    if header == "State":
                        if "RUNNING" in value:
                            value = f"<span class='badge success'>{value}</span>"
                        elif "STOPPED" in value:
                            value = f"<span class='badge danger'>{value}</span>"
                        else:
                            value = f"<span class='badge warning'>{value}</span>"
                    rows += f"<td>{value}</td>"
                rows += "</tr>"

            return rows

        return "<tr><td colspan='5'>Invalid service data format</td></tr>"

    def _generate_devices_table(self, data):
        """Generate HTML table for devices"""
        if not data:
            return "<tr><td colspan='4'>No device information available</td></tr>"

        rows = "<tr><th>Name</th><th>Description</th><th>Manufacturer</th><th>Device ID</th></tr>"
        for device in data:
            if "Error" in device:
                rows += f"<tr><td colspan='4'>{device['Error']}</td></tr>"
            else:
                rows += f"<tr><td>{device.get('Name', '')}</td><td>{device.get('Description', '')}</td><td>{device.get('Manufacturer', '')}</td><td>{device.get('Device ID', '')}</td></tr>"

        return rows


class SystemCleanerGUI:
    def __init__(self, root, theme=DARK_THEME):
        try:
            self.root = root
            self.theme = theme
            self.current_theme = 'dark'
            self.widgets = []
            self.widget_fonts = {}  # Store original font settings for each widget
            self.font_size_factor = 1.0  # Default font size factor

            # Load font size preference if it exists
            try:
                if os.path.exists("font_size_pref.json"):
                    with open("font_size_pref.json", "r") as f:
                        pref = json.load(f)
                        self.font_size_factor = pref.get("font_size_factor", 1.0)
            except:
                pass

            self.root.title("Windows System Cleaner")
            self.root.geometry("1100x1000")
            self.root.minsize(900, 750)
            self.root.resizable(True, True)

            # Set window icon
            try:
                current_dir = os.path.dirname(os.path.abspath(__file__))
                potential_icons = [
                    os.path.join(current_dir, "app_icon.png"),
                    os.path.join(current_dir, "dist", "app_icon.png"), # Check dist folder
                    os.path.join(current_dir, "..", "app_icon.png"),
                    "app_icon.png"
                ]
                
                icon_path = None
                for path in potential_icons:
                    if os.path.exists(path):
                        icon_path = path
                        break
                
                if icon_path:
                    # Use both iconphoto (all windows) and iconbitmap (taskbar) if .ico available
                    # For .png, iconphoto is correct
                    icon_image = tk.PhotoImage(file=icon_path)
                    self.root.iconphoto(True, icon_image)
            except Exception as e:
                print(f"Failed to load icon: {e}")

            # Apply theme to root
            self.root.configure(bg=self.theme['bg'])

            # Create menu
            self.create_menu()

            # Task progress tracking
            self.task_progress = {}
            self.total_tasks = 0
            self.completed_tasks = 0
            self.start_time = None
            self.progress_active = False

            # Create GUI elements
            self.create_widgets()

            # Check if running as admin
            self.admin_status = self.is_admin()
            self.update_admin_status()

            # Queue for thread communication
            self.queue = queue.Queue()

        except Exception as e:
            messagebox.showerror("Initialization Error", f"Failed to initialize GUI: {str(e)}")
            sys.exit(1)

    def create_menu(self):
        """Create the application menu"""
        menubar = Menu(self.root, bg=self.theme['menu_bg'], fg=self.theme['menu_fg'])
        self.root.config(menu=menubar)

        # View menu
        view_menu = Menu(menubar, tearoff=0, bg=self.theme['menu_bg'], fg=self.theme['menu_fg'])
        menubar.add_cascade(label="View", menu=view_menu)

        # Theme submenu
        theme_menu = Menu(view_menu, tearoff=0, bg=self.theme['menu_bg'], fg=self.theme['menu_fg'])
        view_menu.add_cascade(label=" Theme", menu=theme_menu)
        
        self.theme_var = tk.StringVar(value='dark')
        theme_menu.add_radiobutton(
            label=" Light",
            variable=self.theme_var,
            value='light',
            command=lambda: self.switch_theme('light')
        )
        theme_menu.add_radiobutton(
            label=" Dark",
            variable=self.theme_var,
            value='dark',
            command=lambda: self.switch_theme('dark')
        )
        theme_menu.add_separator()
        theme_menu.add_radiobutton(
            label=" Cyberpunk",
            variable=self.theme_var,
            value='cyberpunk',
            command=lambda: self.switch_theme('cyberpunk')
        )
        theme_menu.add_radiobutton(
            label=" Ocean",
            variable=self.theme_var,
            value='ocean',
            command=lambda: self.switch_theme('ocean')
        )
        theme_menu.add_radiobutton(
            label=" Sunset",
            variable=self.theme_var,
            value='sunset',
            command=lambda: self.switch_theme('sunset')
        )
        theme_menu.add_radiobutton(
            label=" Forest",
            variable=self.theme_var,
            value='forest',
            command=lambda: self.switch_theme('forest')
        )
        
        # Keep dark_mode_var for backwards compatibility
        self.dark_mode_var = tk.BooleanVar(value=True)

        # Font size menu
        font_menu = Menu(menubar, tearoff=0, bg=self.theme['menu_bg'], fg=self.theme['menu_fg'])
        menubar.add_cascade(label="Change Font Size", menu=font_menu)

        # Font size options
        self.font_size_var = tk.IntVar(value=10)  # Default to medium
        font_menu.add_radiobutton(
            label="Small",
            variable=self.font_size_var,
            value=8,
            command=lambda: self.change_font_size(8)
        )
        font_menu.add_radiobutton(
            label="Medium",
            variable=self.font_size_var,
            value=10,
            command=lambda: self.change_font_size(10)
        )
        font_menu.add_radiobutton(
            label="Large",
            variable=self.font_size_var,
            value=12,
            command=lambda: self.change_font_size(12)
        )
        font_menu.add_radiobutton(
            label="Extra Large",
            variable=self.font_size_var,
            value=14,
            command=lambda: self.change_font_size(14)
        )

        # Register menu for theme updates
        self.widgets.append(('menu', menubar))
        self.widgets.append(('menu', view_menu))
        self.widgets.append(('menu', theme_menu))
        self.widgets.append(('menu', font_menu))

    def change_font_size(self, size):
        """Change the font size of all widgets in the GUI"""
        # Calculate the factor based on the default size (10)
        self.font_size_factor = size / 10.0

        # Save the preference
        try:
            with open("font_size_pref.json", "w") as f:
                json.dump({"font_size_factor": self.font_size_factor}, f)
        except:
            pass

        # Update all widget fonts
        self.update_all_fonts()

    def update_all_fonts(self):
        """Update the font size of all registered widgets"""
        for widget, original_font in self.widget_fonts.items():
            if original_font:
                # original_font is a tuple: (family, size, ...)
                family = original_font[0]
                base_size = original_font[1]
                # The rest of the tuple (if any) are the style options
                style = original_font[2:] if len(original_font) > 2 else ()
                new_size = int(base_size * self.font_size_factor)
                new_font = (family, new_size) + style
                try:
                    widget.config(font=new_font)
                except:
                    pass  # Ignore errors

    def toggle_dark_mode(self):
        """Toggle between light and dark mode (legacy compatibility)"""
        if self.dark_mode_var.get():
            self.switch_theme('dark')
        else:
            self.switch_theme('light')

    def switch_theme(self, theme_name):
        """Switch to a specific theme by name"""
        theme_map = {
            'light': LIGHT_THEME,
            'dark': DARK_THEME,
            'cyberpunk': CYBERPUNK_THEME,
            'ocean': OCEAN_THEME,
            'sunset': SUNSET_THEME,
            'forest': FOREST_THEME
        }
        
        if theme_name in theme_map:
            self.current_theme = theme_name
            self.theme = theme_map[theme_name]
            self.theme_var.set(theme_name)
            # Update dark_mode_var for backwards compatibility
            self.dark_mode_var.set(theme_name != 'light')
        else:
            return

        # Apply theme to all widgets
        self.apply_theme()

        # Update progress bar style
        self.style.configure(
            "Horizontal.TProgressbar", 
            troughcolor=self.theme['surface_alt'],
            background=self.theme['primary'],
            bordercolor=self.theme['surface_alt'],
            lightcolor=self.theme['primary'],
            darkcolor=self.theme['primary']
        )

        # Save theme preference
        try:
            with open("theme_pref.json", "w") as f:
                json.dump({"theme": theme_name}, f)
        except:
            pass

    def apply_theme(self):
        """Apply the current theme to all registered widgets"""
        for widget_type, widget in self.widgets:
            try:
                if widget_type == 'label':
                    widget.config(bg=widget.cget('bg') if 'indicator' in str(widget) else self.theme['bg'], 
                               fg=self.theme['label_fg'])
                    # If it's a pill label (admin status), keep its special background
                    if hasattr(self, 'admin_label') and widget == self.admin_label:
                        self.update_admin_status()
                elif widget_type == 'button':
                    if hasattr(self, 'run_button') and widget == self.run_button:
                        widget.config(bg=self.theme['button_bg'], fg=self.theme['button_fg'])
                    elif hasattr(self, 'exit_button') and widget == self.exit_button:
                        widget.config(bg=self.theme['button_secondary_bg'], fg=self.theme['button_secondary_fg'])
                    else:
                        widget.config(bg=self.theme['button_bg'], fg=self.theme['button_fg'])
                elif widget_type == 'entry':
                    widget.config(bg=self.theme['entry_bg'], fg=self.theme['entry_fg'])
                elif widget_type == 'text':
                    widget.config(bg=self.theme['surface'], fg=self.theme['text_fg'])
                elif widget_type == 'log':
                    widget.config(bg=self.theme['surface'], fg=self.theme['log_text_fg'])
                elif widget_type == 'frame':
                    # Special handling for frames that are "cards"
                    if widget in [self.checkbox_frame, self.app_checkbox_frame, self.additional_checkbox_frame]:
                        widget.config(bg=self.theme['surface'])
                    elif hasattr(self, 'header_frame') and widget == self.header_frame:
                         widget.config(bg=self.theme['header_bg'])
                    else:
                        widget.config(bg=self.theme['bg'])
                elif widget_type == 'labelframe':
                    widget.config(bg=self.theme['surface'], fg=self.theme['primary'])
                elif widget_type == 'checkbutton':
                    widget.config(bg=self.theme['surface'], fg=self.theme['task_fg'],
                                  selectcolor=self.theme['surface'],
                                  activebackground=self.theme['surface_alt'])
                elif widget_type == 'progress':
                    widget.config(style="Horizontal.TProgressbar")
                elif widget_type == 'menu':
                    # For menus, we need to update the menu itself and its items
                    widget.config(bg=self.theme['menu_bg'], fg=self.theme['menu_fg'])
                    # Update menu items
                    if isinstance(widget, Menu):
                        for index in range(widget.index(tk.END) + 1):
                            try:
                                widget.entryconfig(index, bg=self.theme['menu_bg'], fg=self.theme['menu_fg'])
                            except:
                                pass
            except Exception as e:
                pass  # Silently ignore theme application errors

        # Update root window
        self.root.configure(bg=self.theme['bg'])

        # Update additional frames
        if hasattr(self, 'left_frame'):
            self.left_frame.configure(bg=self.theme['bg'])
        if hasattr(self, 'right_frame'):
            self.right_frame.configure(bg=self.theme['bg'])

    def create_widgets(self):
        try:
            # Header frame (Modern sleek design)
            self.header_frame = tk.Frame(
                self.root, 
                bg=self.theme['header_bg'],
                height=70
            )
            self.header_frame.pack(fill=tk.X)
            self.header_frame.pack_propagate(False) # Keep fixed height
            self.widgets.append(('frame', self.header_frame))

            # Header separator
            separator = tk.Frame(self.root, bg=self.theme['primary'], height=2)
            separator.pack(fill=tk.X)
            self.widgets.append(('frame', separator))

            # Title with modern font
            title_font = ('Segoe UI', 18, 'bold')
            self.title_label = tk.Label(
                self.header_frame,
                text="Windows System Cleaner",
                font=title_font,
                bg=self.theme['header_bg'],
                fg=self.theme['header_fg']
            )
            self.title_label.pack(side=tk.LEFT, padx=30, pady=15)
            self.widgets.append(('label', self.title_label))
            self.widget_fonts[self.title_label] = title_font

            # Scrollable container for all main content
            self.scroll_canvas = tk.Canvas(self.root, bg=self.theme['bg'], highlightthickness=0)
            self.scroll_canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            self.widgets.append(('canvas', self.scroll_canvas))
            
            # Scrollbar for the canvas
            self.main_scrollbar = ttk.Scrollbar(self.root, orient=tk.VERTICAL, command=self.scroll_canvas.yview)
            self.main_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            
            self.scroll_canvas.configure(yscrollcommand=self.main_scrollbar.set)
            
            # Main container inside the canvas
            self.main_container = tk.Frame(self.scroll_canvas, bg=self.theme['bg'])
            self.canvas_window = self.scroll_canvas.create_window((0, 0), window=self.main_container, anchor='nw')
            self.widgets.append(('frame', self.main_container))
            
            # Configure canvas scrolling
            def configure_scroll_region(event):
                self.scroll_canvas.configure(scrollregion=self.scroll_canvas.bbox('all'))
            
            def configure_canvas_width(event):
                self.scroll_canvas.itemconfig(self.canvas_window, width=event.width)
            
            self.main_container.bind('<Configure>', configure_scroll_region)
            self.scroll_canvas.bind('<Configure>', configure_canvas_width)
            
            # Bind mousewheel scrolling
            def on_mousewheel(event):
                self.scroll_canvas.yview_scroll(int(-1*(event.delta/120)), "units")
            
            self.scroll_canvas.bind_all('<MouseWheel>', on_mousewheel)
            
            # Add padding inside main_container
            self.content_frame = tk.Frame(self.main_container, bg=self.theme['bg'])
            self.content_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
            self.widgets.append(('frame', self.content_frame))


            # Admin status (Pill style)
            admin_container = tk.Frame(self.content_frame, bg=self.theme['bg'])
            admin_container.pack(fill=tk.X, pady=(0, 20))
            self.widgets.append(('frame', admin_container))

            admin_font = ('Segoe UI', 10, 'bold')
            self.admin_label = tk.Label(
                admin_container, 
                text="", 
                font=admin_font,
                bg=self.theme['bg'], 
                fg=self.theme['admin_fg'],
                padx=10,
                pady=5
            )
            self.admin_label.pack(side=tk.LEFT)
            self.widgets.append(('label', self.admin_label))
            self.widget_fonts[self.admin_label] = admin_font

            # Create a frame for the two columns
            columns_frame = tk.Frame(self.content_frame, bg=self.theme['bg'])
            columns_frame.pack(fill=tk.BOTH, expand=True)
            self.widgets.append(('frame', columns_frame))

            # Left column
            self.left_frame = tk.Frame(columns_frame, bg=self.theme['bg'])
            self.left_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 10))
            self.widgets.append(('frame', self.left_frame))

            # Card-style Labelframes
            task_frame_font = ('Segoe UI', 11, 'bold')
            self.task_frame = tk.LabelFrame(
                self.left_frame,
                text=" CORE SYSTEM TASKS ",
                font=task_frame_font,
                bd=1,
                relief=tk.FLAT,
                bg=self.theme['surface'],
                fg=self.theme['primary'],
                padx=15,
                pady=15
            )
            self.task_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 15))
            self.widgets.append(('labelframe', self.task_frame))
            self.widget_fonts[self.task_frame] = task_frame_font

            app_frame_font = ('Segoe UI', 11, 'bold')
            self.app_frame = tk.LabelFrame(
                self.left_frame,
                text=" APP SETTINGS ",
                font=app_frame_font,
                bd=1,
                relief=tk.FLAT,
                bg=self.theme['surface'],
                fg=self.theme['primary'],
                padx=15,
                pady=15
            )
            self.app_frame.pack(fill=tk.BOTH, expand=True)
            self.widgets.append(('labelframe', self.app_frame))
            self.widget_fonts[self.app_frame] = app_frame_font

            # Right column
            self.right_frame = tk.Frame(columns_frame, bg=self.theme['bg'])
            self.right_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=(10, 0))
            self.widgets.append(('frame', self.right_frame))

            additional_task_frame_font = ('Segoe UI', 11, 'bold')
            self.additional_task_frame = tk.LabelFrame(
                self.right_frame,
                text=" ADDITIONAL TASKS ",
                font=additional_task_frame_font,
                bd=1,
                relief=tk.FLAT,
                bg=self.theme['surface'],
                fg=self.theme['primary'],
                padx=15,
                pady=15
            )
            self.additional_task_frame.pack(fill=tk.BOTH, expand=True)
            self.widgets.append(('labelframe', self.additional_task_frame))
            self.widget_fonts[self.additional_task_frame] = additional_task_frame_font

            # Task variables (No change to logic)
            self.clean_temp = tk.BooleanVar(value=False)
            self.disk_cleanup = tk.BooleanVar(value=False)
            self.disable_fast_startup = tk.BooleanVar(value=False)
            self.repair_system = tk.BooleanVar(value=False)
            self.autopilot_csv = tk.BooleanVar(value=False)
            self.chk_dsk = tk.BooleanVar(value=False)
            self.windows_adjustments = tk.BooleanVar(value=False)
            self.windows_updates = tk.BooleanVar(value=False)
            self.device_firmware = tk.BooleanVar(value=False)
            self.flush_dns = tk.BooleanVar(value=False)
            self.ipconfig_all = tk.BooleanVar(value=False)
            self.change_dns = tk.BooleanVar(value=False)
            self.pc_report = tk.BooleanVar(value=False)
            self.chris_titus_utility = tk.BooleanVar(value=False)
            self.storage_sence = tk.BooleanVar(value=False)
            self.oo_shutup10 = tk.BooleanVar(value=False)
            self.edge_performance = tk.BooleanVar(value=False)
            self.disable_gaming_features = tk.BooleanVar(value=False)
            self.adjust_virtual_memory = tk.BooleanVar(value=False)

            # App settings variables
            self.stop_background_apps_var = tk.BooleanVar(value=False)
            self.disable_startup_apps_var = tk.BooleanVar(value=False)
            self.update_apps = tk.BooleanVar(value=False)


            # Checkbox containers
            self.checkbox_frame = tk.Frame(self.task_frame, bg=self.theme['surface'])
            self.checkbox_frame.pack(fill=tk.BOTH, expand=True)
            self.widgets.append(('frame', self.checkbox_frame))

            self.app_checkbox_frame = tk.Frame(self.app_frame, bg=self.theme['surface'])
            self.app_checkbox_frame.pack(fill=tk.BOTH, expand=True)
            self.widgets.append(('frame', self.app_checkbox_frame))

            self.additional_checkbox_frame = tk.Frame(self.additional_task_frame, bg=self.theme['surface'])
            self.additional_checkbox_frame.pack(fill=tk.BOTH, expand=True)
            self.widgets.append(('frame', self.additional_checkbox_frame))

            # Create core system tasks checkboxes
            task_font = ('Segoe UI', 9)
            
            # Clean Temp
            temp_frame = tk.Frame(self.checkbox_frame, bg=self.theme['surface'])
            temp_frame.pack(fill=tk.X, pady=2)
            self.temp_checkbox = tk.Checkbutton(
                temp_frame,
                text="Clean Temp Files (System-wide)",
                variable=self.clean_temp,
                font=task_font,
                anchor=tk.W,
                bg=self.theme['surface'],
                fg=self.theme['task_fg'],
                selectcolor=self.theme['surface'],
                activebackground=self.theme['surface_alt'],
                relief=tk.FLAT
            )
            self.temp_checkbox.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.widgets.append(('checkbutton', self.temp_checkbox))
            self.widget_fonts[self.temp_checkbox] = task_font
            temp_indicator = tk.Label(temp_frame, text="", font=('Segoe UI', 9), bg=self.theme['surface'], fg=self.theme['admin_indicator'])
            temp_indicator.pack(side=tk.RIGHT, padx=5)
            Tooltip(self.temp_checkbox, "Cleans: Windows Temp, User Temp, Prefetch, and browser caches. Frees up disk space without affecting system files.", self.theme)

            # Disk Cleanup
            disk_cleanup_frame = tk.Frame(self.checkbox_frame, bg=self.theme['surface'])
            disk_cleanup_frame.pack(fill=tk.X, pady=2)
            self.disk_cleanup_checkbox = tk.Checkbutton(
                disk_cleanup_frame,
                text="Deep Disk Cleanup",
                variable=self.disk_cleanup,
                font=task_font,
                anchor=tk.W,
                bg=self.theme['surface'],
                fg=self.theme['task_fg'],
                selectcolor=self.theme['surface'],
                activebackground=self.theme['surface_alt']
            )
            self.disk_cleanup_checkbox.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.widgets.append(('checkbutton', self.disk_cleanup_checkbox))
            self.widget_fonts[self.disk_cleanup_checkbox] = task_font
            disk_cleanup_indicator = tk.Label(disk_cleanup_frame, text="", font=('Segoe UI', 9), bg=self.theme['surface'], fg=self.theme['admin_indicator'])
            disk_cleanup_indicator.pack(side=tk.RIGHT, padx=5)
            Tooltip(self.disk_cleanup_checkbox, "Runs Windows Disk Cleanup with ALL options enabled: System cache, Update cleanup, Thumbnails, and Error reports.", self.theme)

            # Fast Startup
            fast_startup_frame = tk.Frame(self.checkbox_frame, bg=self.theme['surface'])
            fast_startup_frame.pack(fill=tk.X, pady=2)
            self.fast_startup_checkbox = tk.Checkbutton(
                fast_startup_frame,
                text="Disable Fast Startup",
                variable=self.disable_fast_startup,
                font=task_font,
                anchor=tk.W,
                bg=self.theme['surface'],
                fg=self.theme['task_fg'],
                selectcolor=self.theme['surface'],
                activebackground=self.theme['surface_alt']
            )
            self.fast_startup_checkbox.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.widgets.append(('checkbutton', self.fast_startup_checkbox))
            self.widget_fonts[self.fast_startup_checkbox] = task_font
            fast_startup_indicator = tk.Label(fast_startup_frame, text="", font=('Segoe UI', 9), bg=self.theme['surface'], fg=self.theme['admin_indicator'])
            fast_startup_indicator.pack(side=tk.RIGHT, padx=5)
            Tooltip(self.fast_startup_checkbox, "Disables Fast Startup (Hybrid shutdown). Fixes issues with dual-boot, drivers, and ensures clean shutdowns. Recommended for most users.", self.theme)

            # Adjust Virtual Memory (Core System Task)
            virtual_memory_frame = tk.Frame(self.checkbox_frame, bg=self.theme['surface'])
            virtual_memory_frame.pack(fill=tk.X, pady=2)
            self.virtual_memory_checkbox = tk.Checkbutton(
                virtual_memory_frame,
                text="Optimize Virtual Memory",
                variable=self.adjust_virtual_memory,
                font=task_font,
                anchor=tk.W,
                bg=self.theme['surface'],
                fg=self.theme['task_fg'],
                selectcolor=self.theme['surface'],
                activebackground=self.theme['surface_alt']
            )
            self.virtual_memory_checkbox.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.widgets.append(('checkbutton', self.virtual_memory_checkbox))
            self.widget_fonts[self.virtual_memory_checkbox] = task_font
            virtual_memory_indicator = tk.Label(virtual_memory_frame, text="", font=('Segoe UI', 9), bg=self.theme['surface'], fg=self.theme['admin_indicator'])
            virtual_memory_indicator.pack(side=tk.RIGHT, padx=5)
            Tooltip(self.virtual_memory_checkbox, "Detects your RAM (e.g. 16GB)  Sets page file to 2x RAM (32GB). Shows current vs recommended settings. Requires restart.", self.theme)

            # Create additional tasks checkboxes

            # PC Report
            pc_report_frame = tk.Frame(self.additional_checkbox_frame, bg=self.theme['surface'])
            pc_report_frame.pack(fill=tk.X, pady=2)
            self.pc_report_checkbox = tk.Checkbutton(
                pc_report_frame,
                text="Generate PC Report",
                variable=self.pc_report,
                font=task_font,
                anchor=tk.W,
                bg=self.theme['surface'],
                fg=self.theme['task_fg'],
                selectcolor=self.theme['surface'],
                activebackground=self.theme['surface_alt']
            )
            self.pc_report_checkbox.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.widgets.append(('checkbutton', self.pc_report_checkbox))
            self.widget_fonts[self.pc_report_checkbox] = task_font
            pc_report_indicator = tk.Label(pc_report_frame, text="", font=('Segoe UI', 9), bg=self.theme['surface'], fg=self.theme['user_indicator'])
            pc_report_indicator.pack(side=tk.RIGHT, padx=5)
            Tooltip(self.pc_report_checkbox, "Generates a detailed system report", self.theme)

            # Chris Titus Utility
            chris_titus_frame = tk.Frame(self.additional_checkbox_frame, bg=self.theme['surface'])
            chris_titus_frame.pack(fill=tk.X, pady=2)
            self.chris_titus_checkbox = tk.Checkbutton(
                chris_titus_frame,
                text="Chris Titus Windows Utility",
                variable=self.chris_titus_utility,
                font=task_font,
                anchor=tk.W,
                bg=self.theme['surface'],
                fg=self.theme['task_fg'],
                selectcolor=self.theme['surface'],
                activebackground=self.theme['surface_alt']
            )
            self.chris_titus_checkbox.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.widgets.append(('checkbutton', self.chris_titus_checkbox))
            self.widget_fonts[self.chris_titus_checkbox] = task_font
            chris_titus_indicator = tk.Label(chris_titus_frame, text="", font=('Segoe UI', 9), bg=self.theme['surface'], fg=self.theme['admin_indicator'])
            chris_titus_indicator.pack(side=tk.RIGHT, padx=5)
            Tooltip(self.chris_titus_checkbox, "Runs the Chris Titus Windows Utility script", self.theme)

            # StorageSence
            storage_sence_frame = tk.Frame(self.additional_checkbox_frame, bg=self.theme['surface'])
            storage_sence_frame.pack(fill=tk.X, pady=2)
            self.storage_sence_checkbox = tk.Checkbutton(
                storage_sence_frame,
                text="Storage Analyzer (Drive Scanner)",
                variable=self.storage_sence,
                font=task_font,
                anchor=tk.W,
                bg=self.theme['surface'],
                fg=self.theme['task_fg'],
                selectcolor=self.theme['surface'],
                activebackground=self.theme['surface_alt']
            )
            self.storage_sence_checkbox.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.widgets.append(('checkbutton', self.storage_sence_checkbox))
            self.widget_fonts[self.storage_sence_checkbox] = task_font
            storage_sence_indicator = tk.Label(storage_sence_frame, text="", font=('Segoe UI', 9), bg=self.theme['surface'], fg=self.theme['admin_indicator'])
            storage_sence_indicator.pack(side=tk.RIGHT, padx=5)
            Tooltip(self.storage_sence_checkbox, "Launches advanced drive health and space scanner", self.theme)

            # Windows Updates (moved to Core System Tasks)
            windows_updates_frame = tk.Frame(self.checkbox_frame, bg=self.theme['surface'])
            windows_updates_frame.pack(fill=tk.X, pady=2)
            self.windows_updates_checkbox = tk.Checkbutton(
                windows_updates_frame,
                text="Check Windows Updates",
                variable=self.windows_updates,
                font=task_font,
                anchor=tk.W,
                bg=self.theme['surface'],
                fg=self.theme['task_fg'],
                selectcolor=self.theme['surface'],
                activebackground=self.theme['surface_alt']
            )
            self.windows_updates_checkbox.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.widgets.append(('checkbutton', self.windows_updates_checkbox))
            self.widget_fonts[self.windows_updates_checkbox] = task_font
            windows_updates_indicator = tk.Label(windows_updates_frame, text="", font=('Segoe UI', 9), bg=self.theme['surface'], fg=self.theme['admin_indicator'])
            windows_updates_indicator.pack(side=tk.RIGHT, padx=5)
            Tooltip(self.windows_updates_checkbox, "Checks for and installs available Windows updates", self.theme)

            # Device Firmware
            device_firmware_frame = tk.Frame(self.additional_checkbox_frame, bg=self.theme['surface'])
            device_firmware_frame.pack(fill=tk.X, pady=2)
            self.device_firmware_checkbox = tk.Checkbutton(
                device_firmware_frame,
                text="OEM Firmware Updates",
                variable=self.device_firmware,
                font=task_font,
                anchor=tk.W,
                bg=self.theme['surface'],
                fg=self.theme['task_fg'],
                selectcolor=self.theme['surface'],
                activebackground=self.theme['surface_alt']
            )
            self.device_firmware_checkbox.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.widgets.append(('checkbutton', self.device_firmware_checkbox))
            self.widget_fonts[self.device_firmware_checkbox] = task_font
            device_firmware_indicator = tk.Label(device_firmware_frame, text="", font=('Segoe UI', 9), bg=self.theme['surface'], fg=self.theme['admin_indicator'])
            device_firmware_indicator.pack(side=tk.RIGHT, padx=5)
            Tooltip(self.device_firmware_checkbox, "Checks for Dell, HP, and Lenovo firmware updates", self.theme)

            # Repair System (moved to Core System Tasks)
            repair_system_frame = tk.Frame(self.checkbox_frame, bg=self.theme['surface'])
            repair_system_frame.pack(fill=tk.X, pady=2)
            self.repair_system_checkbox = tk.Checkbutton(
                repair_system_frame,
                text="Repair System (SFC/DISM)",
                variable=self.repair_system,
                font=task_font,
                anchor=tk.W,
                bg=self.theme['surface'],
                fg=self.theme['task_fg'],
                selectcolor=self.theme['surface'],
                activebackground=self.theme['surface_alt']
            )
            self.repair_system_checkbox.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.widgets.append(('checkbutton', self.repair_system_checkbox))
            self.widget_fonts[self.repair_system_checkbox] = task_font
            repair_system_indicator = tk.Label(repair_system_frame, text="", font=('Segoe UI', 9), bg=self.theme['surface'], fg=self.theme['admin_indicator'])
            repair_system_indicator.pack(side=tk.RIGHT, padx=5)
            Tooltip(self.repair_system_checkbox, "Repairs Windows system files using SFC and DISM", self.theme)

            # CHKDSK (moved to Core System Tasks)
            chk_dsk_frame = tk.Frame(self.checkbox_frame, bg=self.theme['surface'])
            chk_dsk_frame.pack(fill=tk.X, pady=2)
            self.chk_dsk_checkbox = tk.Checkbutton(
                chk_dsk_frame,
                text="CHKDSK C: /R (Reboot required)",
                variable=self.chk_dsk,
                font=task_font,
                anchor=tk.W,
                bg=self.theme['surface'],
                fg=self.theme['task_fg'],
                selectcolor=self.theme['surface'],
                activebackground=self.theme['surface_alt']
            )
            self.chk_dsk_checkbox.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.widgets.append(('checkbutton', self.chk_dsk_checkbox))
            self.widget_fonts[self.chk_dsk_checkbox] = task_font
            chk_dsk_indicator = tk.Label(chk_dsk_frame, text="", font=('Segoe UI', 9), bg=self.theme['surface'], fg=self.theme['admin_indicator'])
            chk_dsk_indicator.pack(side=tk.RIGHT, padx=5)
            Tooltip(self.chk_dsk_checkbox, "Checks disk for errors and repairs them on next reboot", self.theme)

            # Windows Adjustments
            windows_adjustments_frame = tk.Frame(self.additional_checkbox_frame, bg=self.theme['surface'])
            windows_adjustments_frame.pack(fill=tk.X, pady=2)
            self.windows_adjustments_checkbox = tk.Checkbutton(
                windows_adjustments_frame,
                text="Performance Adjustments",
                variable=self.windows_adjustments,
                font=task_font,
                anchor=tk.W,
                bg=self.theme['surface'],
                fg=self.theme['task_fg'],
                selectcolor=self.theme['surface'],
                activebackground=self.theme['surface_alt']
            )
            self.windows_adjustments_checkbox.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.widgets.append(('checkbutton', self.windows_adjustments_checkbox))
            self.widget_fonts[self.windows_adjustments_checkbox] = task_font
            windows_adjustments_indicator = tk.Label(windows_adjustments_frame, text="", font=('Segoe UI', 9), bg=self.theme['surface'], fg=self.theme['admin_indicator'])
            windows_adjustments_indicator.pack(side=tk.RIGHT, padx=5)
            Tooltip(self.windows_adjustments_checkbox, "Applies performance tweaks to Windows", self.theme)
            
            # Flush DNS
            flush_dns_frame = tk.Frame(self.additional_checkbox_frame, bg=self.theme['surface'])
            flush_dns_frame.pack(fill=tk.X, pady=2)
            self.flush_dns_checkbox = tk.Checkbutton(
                flush_dns_frame,
                text="Flush DNS & Renew IP",
                variable=self.flush_dns,
                font=task_font,
                anchor=tk.W,
                bg=self.theme['surface'],
                fg=self.theme['task_fg'],
                selectcolor=self.theme['surface'],
                activebackground=self.theme['surface_alt']
            )
            self.flush_dns_checkbox.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.widgets.append(('checkbutton', self.flush_dns_checkbox))
            self.widget_fonts[self.flush_dns_checkbox] = task_font
            flush_dns_indicator = tk.Label(flush_dns_frame, text="", font=('Segoe UI', 9), bg=self.theme['surface'], fg=self.theme['user_indicator'])
            flush_dns_indicator.pack(side=tk.RIGHT, padx=5)
            Tooltip(self.flush_dns_checkbox, "Flushes DNS cache and renews your IP address", self.theme)

            # Display IP Config
            ipconfig_frame = tk.Frame(self.additional_checkbox_frame, bg=self.theme['surface'])
            ipconfig_frame.pack(fill=tk.X, pady=2)
            self.ipconfig_all_checkbox = tk.Checkbutton(
                ipconfig_frame,
                text="Display Network Config",
                variable=self.ipconfig_all,
                font=task_font,
                anchor=tk.W,
                bg=self.theme['surface'],
                fg=self.theme['task_fg'],
                selectcolor=self.theme['surface'],
                activebackground=self.theme['surface_alt']
            )
            self.ipconfig_all_checkbox.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.widgets.append(('checkbutton', self.ipconfig_all_checkbox))
            self.widget_fonts[self.ipconfig_all_checkbox] = task_font
            ipconfig_indicator = tk.Label(ipconfig_frame, text="", font=('Segoe UI', 9), bg=self.theme['surface'], fg=self.theme['user_indicator'])
            ipconfig_indicator.pack(side=tk.RIGHT, padx=5)
            Tooltip(self.ipconfig_all_checkbox, "Displays detailed network configuration information", self.theme)

            # Change DNS
            change_dns_frame = tk.Frame(self.additional_checkbox_frame, bg=self.theme['surface'])
            change_dns_frame.pack(fill=tk.X, pady=2)
            self.change_dns_checkbox = tk.Checkbutton(
                change_dns_frame,
                text="Set Fast DNS (1.1.1.1/8.8.8.8)",
                variable=self.change_dns,
                font=task_font,
                anchor=tk.W,
                bg=self.theme['surface'],
                fg=self.theme['task_fg'],
                selectcolor=self.theme['surface'],
                activebackground=self.theme['surface_alt']
            )
            self.change_dns_checkbox.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.widgets.append(('checkbutton', self.change_dns_checkbox))
            self.widget_fonts[self.change_dns_checkbox] = task_font
            change_dns_indicator = tk.Label(change_dns_frame, text="", font=('Segoe UI', 9), bg=self.theme['surface'], fg=self.theme['admin_indicator'])
            change_dns_indicator.pack(side=tk.RIGHT, padx=5)
            Tooltip(self.change_dns_checkbox, "Changes DNS servers to Cloudflare and Google", self.theme)

            # AutoPilot CSV
            autopilot_frame = tk.Frame(self.additional_checkbox_frame, bg=self.theme['surface'])
            autopilot_frame.pack(fill=tk.X, pady=2)
            self.autopilot_csv_checkbox = tk.Checkbutton(
                autopilot_frame,
                text="Create AutoPilot CSV",
                variable=self.autopilot_csv,
                font=task_font,
                anchor=tk.W,
                bg=self.theme['surface'],
                fg=self.theme['task_fg'],
                selectcolor=self.theme['surface'],
                activebackground=self.theme['surface_alt']
            )
            self.autopilot_csv_checkbox.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.widgets.append(('checkbutton', self.autopilot_csv_checkbox))
            self.widget_fonts[self.autopilot_csv_checkbox] = task_font
            autopilot_indicator = tk.Label(autopilot_frame, text="", font=('Segoe UI', 9), bg=self.theme['surface'], fg=self.theme['admin_indicator'])
            autopilot_indicator.pack(side=tk.RIGHT, padx=5)
            Tooltip(self.autopilot_csv_checkbox, "Creates an AutoPilot CSV for deployment", self.theme)

            # O&O ShutUp10
            oo_shutup10_frame = tk.Frame(self.additional_checkbox_frame, bg=self.theme['surface'])
            oo_shutup10_frame.pack(fill=tk.X, pady=2)
            self.oo_shutup10_checkbox = tk.Checkbutton(
                oo_shutup10_frame,
                text="O&O ShutUp10 (Privacy Tool)",
                variable=self.oo_shutup10,
                font=task_font,
                anchor=tk.W,
                bg=self.theme['surface'],
                fg=self.theme['task_fg'],
                selectcolor=self.theme['surface'],
                activebackground=self.theme['surface_alt']
            )
            self.oo_shutup10_checkbox.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.widgets.append(('checkbutton', self.oo_shutup10_checkbox))
            self.widget_fonts[self.oo_shutup10_checkbox] = task_font
            oo_shutup10_indicator = tk.Label(oo_shutup10_frame, text="", font=('Segoe UI', 9), bg=self.theme['surface'], fg=self.theme['admin_indicator'])
            oo_shutup10_indicator.pack(side=tk.RIGHT, padx=5)
            Tooltip(self.oo_shutup10_checkbox, "Downloads and launches O&O ShutUp10 - a free privacy tool that lets you control Windows 10/11 telemetry, Cortana, and data collection settings.", self.theme)

            # Edge Performance Adjustments
            edge_perf_frame = tk.Frame(self.additional_checkbox_frame, bg=self.theme['surface'])
            edge_perf_frame.pack(fill=tk.X, pady=2)
            self.edge_performance_checkbox = tk.Checkbutton(
                edge_perf_frame,
                text="Edge Performance Adjustments",
                variable=self.edge_performance,
                font=task_font,
                anchor=tk.W,
                bg=self.theme['surface'],
                fg=self.theme['task_fg'],
                selectcolor=self.theme['surface'],
                activebackground=self.theme['surface_alt']
            )
            self.edge_performance_checkbox.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.widgets.append(('checkbutton', self.edge_performance_checkbox))
            self.widget_fonts[self.edge_performance_checkbox] = task_font
            edge_perf_indicator = tk.Label(edge_perf_frame, text="", font=('Segoe UI', 9), bg=self.theme['surface'], fg=self.theme['user_indicator'])
            edge_perf_indicator.pack(side=tk.RIGHT, padx=5)
            Tooltip(self.edge_performance_checkbox, "Disables: Startup Boost (runs Edge at boot), Background Apps. Changes default search to Google instead of Bing.", self.theme)

            # Turn Off Gaming Features
            gaming_features_frame = tk.Frame(self.additional_checkbox_frame, bg=self.theme['surface'])
            gaming_features_frame.pack(fill=tk.X, pady=2)
            self.gaming_features_checkbox = tk.Checkbutton(
                gaming_features_frame,
                text="Turn Off All Gaming Features",
                variable=self.disable_gaming_features,
                font=task_font,
                anchor=tk.W,
                bg=self.theme['surface'],
                fg=self.theme['task_fg'],
                selectcolor=self.theme['surface'],
                activebackground=self.theme['surface_alt']
            )
            self.gaming_features_checkbox.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.widgets.append(('checkbutton', self.gaming_features_checkbox))
            self.widget_fonts[self.gaming_features_checkbox] = task_font
            gaming_features_indicator = tk.Label(gaming_features_frame, text="", font=('Segoe UI', 9), bg=self.theme['surface'], fg=self.theme['admin_indicator'])
            gaming_features_indicator.pack(side=tk.RIGHT, padx=5)
            Tooltip(self.gaming_features_checkbox, "Turns OFF: Game Bar overlay, Game DVR recording, Game Mode optimizations, Background recording, Xbox Game Monitoring. May improve performance on non-gaming PCs.", self.theme)

            # Note label


            note_font = ('Segoe UI', 8, 'italic')
            self.note_label = tk.Label(
                self.additional_task_frame,
                text=" Note: Repair, Updates, and Firmware require reboot.",
                font=note_font,
                fg=self.theme['admin_error_fg'],
                bg=self.theme['surface']
            )
            self.note_label.pack(anchor=tk.W, pady=(10, 0))
            self.widgets.append(('label', self.note_label))
            self.widget_fonts[self.note_label] = note_font

            # App Settings (Left Column)
            # Stop Background Apps
            stop_apps_frame = tk.Frame(self.app_checkbox_frame, bg=self.theme['surface'])
            stop_apps_frame.pack(fill=tk.X, pady=2)
            self.stop_background_apps_checkbox = tk.Checkbutton(
                stop_apps_frame,
                text="Stop Background Apps",
                variable=self.stop_background_apps_var,
                font=task_font,
                anchor=tk.W,
                bg=self.theme['surface'],
                fg=self.theme['task_fg'],
                selectcolor=self.theme['surface'],
                activebackground=self.theme['surface_alt']
            )
            self.stop_background_apps_checkbox.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.widgets.append(('checkbutton', self.stop_background_apps_checkbox))
            self.widget_fonts[self.stop_background_apps_checkbox] = task_font
            stop_apps_indicator = tk.Label(stop_apps_frame, text="", font=('Segoe UI', 9), bg=self.theme['surface'], fg=self.theme['user_indicator'])
            stop_apps_indicator.pack(side=tk.RIGHT, padx=5)
            Tooltip(self.stop_background_apps_checkbox, "Stops unnecessary background applications", self.theme)

            # Disable Startup Apps
            startup_apps_frame = tk.Frame(self.app_checkbox_frame, bg=self.theme['surface'])
            startup_apps_frame.pack(fill=tk.X, pady=2)
            self.disable_startup_apps_checkbox = tk.Checkbutton(
                startup_apps_frame,
                text="Optimize Startup Apps",
                variable=self.disable_startup_apps_var,
                font=task_font,
                anchor=tk.W,
                bg=self.theme['surface'],
                fg=self.theme['task_fg'],
                selectcolor=self.theme['surface'],
                activebackground=self.theme['surface_alt']
            )
            self.disable_startup_apps_checkbox.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.widgets.append(('checkbutton', self.disable_startup_apps_checkbox))
            self.widget_fonts[self.disable_startup_apps_checkbox] = task_font
            startup_apps_indicator = tk.Label(startup_apps_frame, text="", font=('Segoe UI', 9), bg=self.theme['surface'], fg=self.theme['user_indicator'])
            startup_apps_indicator.pack(side=tk.RIGHT, padx=5)
            Tooltip(self.disable_startup_apps_checkbox, "Disables non-essential startup items", self.theme)

            # Update Apps
            update_apps_frame = tk.Frame(self.app_checkbox_frame, bg=self.theme['surface'])
            update_apps_frame.pack(fill=tk.X, pady=2)
            self.update_apps_checkbox = tk.Checkbutton(
                update_apps_frame,
                text="Update Apps (Winget)",
                variable=self.update_apps,
                font=task_font,
                anchor=tk.W,
                bg=self.theme['surface'],
                fg=self.theme['task_fg'],
                selectcolor=self.theme['surface'],
                activebackground=self.theme['surface_alt']
            )
            self.update_apps_checkbox.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.widgets.append(('checkbutton', self.update_apps_checkbox))
            self.widget_fonts[self.update_apps_checkbox] = task_font
            update_apps_indicator = tk.Label(update_apps_frame, text="", font=('Segoe UI', 9), bg=self.theme['surface'], fg=self.theme['admin_indicator'])
            update_apps_indicator.pack(side=tk.RIGHT, padx=5)
            Tooltip(self.update_apps_checkbox, "Updates internal applications using WinGet", self.theme)

            # Action buttons frame (Modern layout)
            button_frame = tk.Frame(self.main_container, bg=self.theme['bg'])
            button_frame.pack(fill=tk.X, pady=(0, 20))
            self.widgets.append(('frame', button_frame))

            run_button_font = ('Segoe UI', 11, 'bold')
            self.run_button = tk.Button(
                button_frame,
                text=" RUN SELECTED TASKS ",
                font=run_button_font,
                command=self.run_selected_tasks,
                bg=self.theme['button_bg'],
                fg=self.theme['button_fg'],
                activebackground=self.theme['primary'],
                activeforeground=self.theme['button_fg'],
                bd=0,
                padx=25,
                pady=12,
                cursor="hand2"
            )
            self.run_button.pack(side=tk.LEFT, padx=(0, 15))
            self.widgets.append(('button', self.run_button))
            self.widget_fonts[self.run_button] = run_button_font

            exit_button_font = ('Segoe UI', 11)
            self.exit_button = tk.Button(
                button_frame,
                text=" EXIT ",
                font=exit_button_font,
                command=self.root.quit,
                bg=self.theme['button_secondary_bg'],
                fg=self.theme['button_secondary_fg'],
                activebackground=self.theme['select_bg'],
                bd=0,
                padx=25,
                pady=12,
                cursor="hand2"
            )
            self.exit_button.pack(side=tk.LEFT)
            self.widgets.append(('button', self.exit_button))
            self.widget_fonts[self.exit_button] = exit_button_font

            # Install Needed Apps Button
            install_apps_button_font = ('Segoe UI', 11)
            self.install_apps_button = tk.Button(
                button_frame,
                text="  INSTALL APPS ",
                font=install_apps_button_font,
                command=self.open_install_apps_window,
                bg=self.theme['primary'],
                fg=self.theme['button_fg'],
                activebackground=self.theme['select_bg'],
                bd=0,
                padx=25,
                pady=12,
                cursor="hand2"
            )
            self.install_apps_button.pack(side=tk.LEFT, padx=(15, 0))
            self.widgets.append(('button', self.install_apps_button))
            self.widget_fonts[self.install_apps_button] = install_apps_button_font

            # Progress section (Integrated look)
            self.progress_section = tk.Frame(self.main_container, bg=self.theme['bg'])
            self.widgets.append(('frame', self.progress_section))

            current_task_font = ('Segoe UI', 9, 'bold')
            self.current_task_label = tk.Label(
                self.progress_section,
                text="Current Task: Ready",
                font=current_task_font,
                bg=self.theme['bg'],
                fg=self.theme['primary']
            )
            self.current_task_label.pack(anchor=tk.W, pady=(0, 5))
            self.widgets.append(('label', self.current_task_label))
            self.widget_fonts[self.current_task_label] = current_task_font

            progress_bar_frame = tk.Frame(self.progress_section, bg=self.theme['bg'])
            progress_bar_frame.pack(fill=tk.X, pady=(0, 10))
            self.widgets.append(('frame', progress_bar_frame))

            self.progress_bar = ttk.Progressbar(
                progress_bar_frame,
                orient=tk.HORIZONTAL,
                mode='indeterminate'
            )
            self.progress_bar.pack(side=tk.LEFT, fill=tk.X, expand=True)
            self.widgets.append(('progress', self.progress_bar))

            self.progress_percent_label = tk.Label(
                progress_bar_frame,
                text="",
                font=('Segoe UI', 9),
                bg=self.theme['bg'],
                fg=self.theme['fg']
            )
            self.progress_percent_label.pack(side=tk.LEFT, padx=(10, 0))
            self.widgets.append(('label', self.progress_percent_label))

            # Log Area (Professional terminal look)
            self.log_container = tk.Frame(self.main_container, bg=self.theme['bg'])
            self.log_container.pack(fill=tk.BOTH, expand=True)
            self.widgets.append(('frame', self.log_container))

            log_label_font = ('Segoe UI', 10, 'bold')
            self.log_label = tk.Label(
                self.log_container,
                text=" ACTIVITY LOG ",
                font=log_label_font,
                bg=self.theme['bg'],
                fg=self.theme['fg']
            )
            self.log_label.pack(anchor=tk.W, pady=(0, 5))
            self.widgets.append(('label', self.log_label))
            self.widget_fonts[self.log_label] = log_label_font

            self.log_frame = tk.Frame(self.log_container, bd=1, relief=tk.FLAT, bg=self.theme['card_border'])
            self.log_frame.pack(fill=tk.BOTH, expand=True)
            self.widgets.append(('frame', self.log_frame))

            log_area_font = ('Consolas', 9)
            self.log_area = tk.Text(
                self.log_frame,
                wrap=tk.WORD,
                font=log_area_font,
                height=35,
                padx=10,
                pady=10,
                bg=self.theme['surface'],
                fg=self.theme['log_text_fg'],
                bd=0,
                highlightthickness=0
            )
            self.log_area.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            self.widgets.append(('log', self.log_area))
            self.widget_fonts[self.log_area] = log_area_font

            self.log_scrollbar = ttk.Scrollbar(
                self.log_frame,
                orient=tk.VERTICAL,
                command=self.log_area.yview
            )
            self.log_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            self.log_area.config(yscrollcommand=self.log_scrollbar.set)

            # Styling for ttk widgets
            self.style = ttk.Style()
            self.style.theme_use('clam') # base for modern styling
            self.style.configure(
                "Horizontal.TProgressbar", 
                thickness=10,
                troughcolor=self.theme['surface_alt'],
                background=self.theme['primary'],
                bordercolor=self.theme['surface_alt'],
                lightcolor=self.theme['primary'],
                darkcolor=self.theme['primary']
            )

            self.update_all_fonts()

            # Start queue processing immediately to capture all background task logs
            self.root.after(100, self.process_queue)

        except Exception as e:
            raise

    def is_admin(self):
        try:
            result = ctypes.windll.shell32.IsUserAnAdmin()
            return result
        except Exception as e:
            return False

    def update_admin_status(self):
        if self.admin_status:
            self.admin_label.config(
                text=" ADMINISTRATOR MODE ACTIVE ",
                bg=self.theme['admin_indicator'],
                fg='#FFFFFF'
            )
        else:
            self.admin_label.config(
                text=" STANDARD USER MODE ",
                bg=self.theme['user_indicator'],
                fg='#FFFFFF'
            )

    def log_message(self, message, task_name=None):
        try:
            timestamp = time.strftime("[%H:%M:%S]")
            safe_message = re.sub(r'[\x00-\x1f\x7f-\x9f]', '', str(message))
            
            # Setup tags if not present
            if not "status_ok" in self.log_area.tag_names():
                self.log_area.tag_configure("status_ok", foreground=self.theme['log_text_fg'])
                self.log_area.tag_configure("status_err", foreground=self.theme['admin_error_fg'])
                self.log_area.tag_configure("timestamp", foreground=self.theme['primary'], font=('Consolas', 9, 'bold'))

            self.log_area.insert(tk.END, f"{timestamp} ", "timestamp")
            
            if task_name:
                self.log_area.insert(tk.END, f"[{task_name}] ")
            
            tag = ""
            msg_lower = safe_message.lower()
            if any(ok in msg_lower for ok in ["success", "done", "complete", "ok"]):
                tag = "status_ok"
            elif any(err in msg_lower for err in ["error", "fail", "denied", "required"]):
                tag = "status_err"
                
            self.log_area.insert(tk.END, f"{safe_message}\n", tag)
            self.log_area.see(tk.END)
            self.root.update_idletasks()
        except Exception:
            pass

    def show_progress(self, show=True):
        """Show or hide the progress section"""
        if show and not self.progress_active:
            self.progress_section.pack(fill=tk.X, pady=(0, 10))
            self.progress_bar.start(10)
            self.progress_active = True
        elif not show and self.progress_active:
            self.progress_bar.stop()
            self.progress_section.pack_forget()
            self.progress_active = False

    def update_progress_info(self, task_name=None, info=None):
        """Update progress information"""
        if task_name:
            self.current_task_label.config(text=f"Current Task: {task_name}")
        if info:
            self.progress_percent_label.config(text=info)

    def run_selected_tasks(self):
        # Disable button during operation
        self.run_button.config(state=tk.DISABLED)

        # Get selected tasks
        tasks = []
        if self.clean_temp.get():
            tasks.append("clean_temp")
        if self.disk_cleanup.get():
            tasks.append("disk_cleanup")
        if self.disable_fast_startup.get():
            tasks.append("disable_fast_startup")
        if self.update_apps.get():
            tasks.append("update_apps")
        if self.windows_updates.get():
            tasks.append("windows_updates")
        if self.device_firmware.get():
            tasks.append("device_firmware")
        if self.repair_system.get():
            tasks.append("repair_system")
        if self.chk_dsk.get():
            tasks.append("chk_dsk")
        if self.windows_adjustments.get():
            tasks.append("windows_adjustments")
        if self.flush_dns.get():
            tasks.append("flush_dns")
        if self.ipconfig_all.get():
            tasks.append("ipconfig_all")
        if self.change_dns.get():
            tasks.append("change_dns")
        if self.autopilot_csv.get():
            tasks.append("autopilot_csv")
        if self.pc_report.get():  # New PC Report task
            tasks.append("pc_report")
        if self.chris_titus_utility.get():  # New Chris Titus Utility task
            tasks.append("chris_titus_utility")
        if self.storage_sence.get():  # New StorageSence task
            tasks.append("storage_sence")
        if self.stop_background_apps_var.get():
            tasks.append("stop_background_apps")
        if self.disable_startup_apps_var.get():
            tasks.append("disable_startup_apps")
        if self.oo_shutup10.get():
            tasks.append("oo_shutup10")
        if self.edge_performance.get():
            tasks.append("edge_performance")
        if self.disable_gaming_features.get():
            tasks.append("disable_gaming_features")
        if self.adjust_virtual_memory.get():
            tasks.append("adjust_virtual_memory")

        if not tasks:
            self.log_message("No tasks selected!")
            self.run_button.config(state=tk.NORMAL)
            return

        # Show progress bar
        self.show_progress(True)

        # Start worker thread
        self.log_message("Starting selected tasks...")
        threading.Thread(target=self.execute_tasks, args=(tasks,), daemon=True).start()

    def reset_all_checkboxes(self):
        """Reset all task checkboxes to unchecked state after tasks complete"""
        # Core System Tasks
        self.clean_temp.set(False)
        self.disk_cleanup.set(False)
        self.disable_fast_startup.set(False)
        self.repair_system.set(False)
        self.chk_dsk.set(False)
        self.windows_updates.set(False)
        
        # App Settings
        self.stop_background_apps_var.set(False)
        self.disable_startup_apps_var.set(False)
        self.update_apps.set(False)
        
        # Additional Tasks
        self.windows_adjustments.set(False)
        self.flush_dns.set(False)
        self.ipconfig_all.set(False)
        self.change_dns.set(False)
        self.autopilot_csv.set(False)
        self.pc_report.set(False)
        self.chris_titus_utility.set(False)
        self.storage_sence.set(False)
        self.device_firmware.set(False)
        self.oo_shutup10.set(False)
        self.edge_performance.set(False)
        self.disable_gaming_features.set(False)
        self.adjust_virtual_memory.set(False)
        
        self.log_message("All task checkboxes have been reset.")

    def execute_tasks(self, tasks):

        if not self.admin_status:
            self.queue.put("ERROR: Administrator privileges required!")
            self.queue.put("Please restart the application as administrator.")
            self.queue.put("TASKS_FAILED")
            return

        for task in tasks:
            try:
                # Map task names to display names
                task_display_names = {
                    "clean_temp": "Clean Temp Files",
                    "disk_cleanup": "Disk Cleanup",
                    "disable_fast_startup": "Disable Fast Startup",
                    "update_apps": "Update Apps",
                    "windows_updates": "Windows Updates",
                    "device_firmware": "Device Firmware Updates",
                    "repair_system": "Repair System",
                    "chk_dsk": "Check Disk",
                    "windows_adjustments": "Windows Adjustments",
                    "flush_dns": "Flush DNS and Renew IP",
                    "ipconfig_all": "Display IP Configuration",
                    "change_dns": "Change DNS to 1.1.1.1 and 8.8.8.8",
                    "autopilot_csv": "AutoPilot CSV Creation",
                    "pc_report": "PC Report",
                    "chris_titus_utility": "Chris Titus Windows Utility",
                    "storage_sence": "StorageSence (Advanced Drive Scanner)",
                    "stop_background_apps": "Stop Background Apps",
                    "disable_startup_apps": "Disable Startup Apps",
                    "oo_shutup10": "O&O ShutUp10 Privacy Tool",
                    "edge_performance": "Edge Performance Adjustments",
                    "disable_gaming_features": "Turn Off All Gaming Features",
                    "adjust_virtual_memory": "Optimize Virtual Memory"
                }

                display_name = task_display_names.get(task, task)
                self.queue.put(f"TASK_START:{task}:{display_name}")

                if task == "clean_temp":
                    self.clean_temp_files()
                elif task == "disk_cleanup":
                    self.run_disk_cleanup()
                elif task == "disable_fast_startup":
                    self.perform_disable_fast_startup()
                elif task == "update_apps":
                    self.update_installed_apps()
                elif task == "windows_updates":
                    self.check_and_install_windows_updates()
                elif task == "device_firmware":
                    self.check_and_install_device_firmware()
                elif task == "repair_system":
                    self.repair_system_files()
                elif task == "chk_dsk":
                    self.run_chk_dsk()
                elif task == "windows_adjustments":
                    self.perform_windows_adjustments()
                elif task == "flush_dns":
                    self.flush_dns_and_renew_ip()
                elif task == "ipconfig_all":
                    self.display_ip_config()
                elif task == "change_dns":
                    self.change_dns_servers()
                elif task == "autopilot_csv":
                    self.create_autopilot_csv()
                elif task == "pc_report":  # New PC Report task
                    self.generate_pc_report()
                elif task == "chris_titus_utility":  # New Chris Titus Utility task
                    self.run_chris_titus_utility()
                elif task == "storage_sence":  # New StorageSence task
                    self.run_storage_sence()
                elif task == "stop_background_apps":
                    self.stop_background_apps()
                elif task == "disable_startup_apps":
                    self.disable_startup_apps()
                elif task == "oo_shutup10":
                    self.run_oo_shutup10()
                elif task == "edge_performance":
                    self.apply_edge_performance_adjustments()
                elif task == "disable_gaming_features":
                    self.disable_all_gaming_features()
                elif task == "adjust_virtual_memory":
                    self.optimize_virtual_memory()

                self.queue.put(f"TASK_END:{task}")
            except Exception as e:
                self.queue.put(f"Error in task {task}: {str(e)}")

        self.queue.put("All selected tasks completed!")
        self.queue.put("TASKS_COMPLETE")

    def process_queue(self):
        task_display_names = {
            "clean_temp": "Clean Temp Files",
            "disk_cleanup": "Disk Cleanup",
            "disable_fast_startup": "Disable Fast Startup",
            "update_apps": "Update Apps",
            "windows_updates": "Windows Updates",
            "device_firmware": "Device Firmware Updates",
            "repair_system": "Repair System",
            "chk_dsk": "Check Disk",
            "windows_adjustments": "Windows Adjustments",
            "flush_dns": "Flush DNS and Renew IP",
            "ipconfig_all": "Display IP Configuration",
            "change_dns": "Change DNS to 1.1.1.1 and 8.8.8.8",
            "autopilot_csv": "AutoPilot CSV Creation",
            "pc_report": "PC Report",
            "chris_titus_utility": "Chris Titus Windows Utility",
            "storage_sence": "StorageSence",
            "stop_background_apps": "Stop Background Apps",
            "disable_startup_apps": "Disable Startup Apps",
            "app_installer": "App Installer"
        }

        try:
            while True:
                msg = self.queue.get_nowait()

                # Handle task start
                if msg.startswith("TASK_START:"):
                    parts = msg.split(":", 2)
                    if len(parts) >= 3:
                        task_id = parts[1]
                        display_name = task_display_names.get(task_id, parts[2])
                        self.log_message(f"Starting task: {display_name}", display_name)
                        self.update_progress_info(display_name, "0%")

                # Handle task progress
                elif msg.startswith("PROGRESS:"):
                    parts = msg.split(":", 2)
                    if len(parts) >= 3:
                        task_id = parts[1]
                        progress_info = parts[2]
                        display_name = task_display_names.get(task_id, task_id)

                        # Extract progress percentage if available
                        progress_match = re.search(r'(\d+)%', progress_info)
                        if progress_match:
                            progress = progress_match.group(1)
                            self.update_progress_info(display_name, f"{progress}%")

                        self.log_message(progress_info, display_name)

                # Handle task end
                elif msg.startswith("TASK_END:"):
                    task_id = msg.split(":", 1)[1]
                    display_name = task_display_names.get(task_id, task_id)
                    self.log_message(f"Task completed: {display_name}", display_name)
                    self.update_progress_info(display_name, "100%")

                # Handle regular messages
                else:
                    self.log_message(msg)

                # Handle task completion
                if msg == "TASKS_COMPLETE":
                    self.run_button.config(state=tk.NORMAL)
                    self.show_progress(False)
                    self.update_progress_info("None", "")
                    self.log_message("Tasks finished successfully!")
                    self.reset_all_checkboxes()  # Auto-uncheck all checkboxes
                elif msg == "TASKS_FAILED":
                    self.run_button.config(state=tk.NORMAL)
                    self.show_progress(False)
                    self.update_progress_info("None", "")
        except queue.Empty:
            self.root.after(100, self.process_queue)

    # ==================== CHRIS TITUS UTILITY METHODS ====================
    def run_chris_titus_utility(self):
        """Run Chris Titus Windows Utility using PowerShell script"""
        self.queue.put("PROGRESS:Chris Titus Utility:Starting Chris Titus Windows Utility...")
        self.queue.put("PROGRESS:Chris Titus Utility:This will download and run the utility from christitus.com")

        try:
            # PowerShell command to run the Chris Titus Windows Utility
            ps_command = "irm christitus.com/win | iex"

            self.queue.put("PROGRESS:Chris Titus Utility:Executing PowerShell command...")
            self.queue.put(f"PROGRESS:Chris Titus Utility:Command: {ps_command}")

            # Run PowerShell command
            result = subprocess.run(
                ['powershell', '-Command', ps_command],
                capture_output=True,
                text=True,
                check=False,
                timeout=600,  # 10 minute timeout
                creationflags=CREATE_NO_WINDOW  # Hide console window
            )

            # Log output
            if result.stdout.strip():
                self.queue.put("PROGRESS:Chris Titus Utility:Output:")
                for line in result.stdout.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:Chris Titus Utility:  {line.strip()}")

            if result.stderr.strip():
                self.queue.put("PROGRESS:Chris Titus Utility:Errors:")
                for line in result.stderr.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:Chris Titus Utility:  {line.strip()}")

            # Check return code
            if result.returncode == 0:
                self.queue.put("PROGRESS:Chris Titus Utility:Chris Titus Windows Utility completed successfully")
            else:
                self.queue.put(f"PROGRESS:Chris Titus Utility:Completed with return code: {result.returncode}")

        except subprocess.TimeoutExpired:
            self.queue.put("PROGRESS:Chris Titus Utility:Operation timed out after 10 minutes")
        except Exception as e:
            self.queue.put(f"PROGRESS:Chris Titus Utility:Error running Chris Titus Utility: {str(e)}")

    # ==================== STORAGESENCE METHODS ====================
    def run_storage_sence(self):
        """Run StorageSence Advanced Drive Scanner - Opens the built-in scanner UI"""
        self.queue.put("PROGRESS:StorageSence:Launching built-in StorageSense...")
        try:
            # Open the merged StorageSenseApp as a Toplevel window
            # This runs in the same process - no need to search for external files
            def open_scanner():
                try:
                    StorageSenseApp(self.root)
                    self.queue.put("PROGRESS:StorageSence:StorageSense window opened successfully.")
                except Exception as e:
                    self.queue.put(f"PROGRESS:StorageSence:Error opening window: {str(e)}")
            
            # Schedule to run on the main thread (Tkinter requirement)
            self.root.after(100, open_scanner)
            self.queue.put("PROGRESS:StorageSence:StorageSense launched successfully.")
            
        except Exception as e:
            self.queue.put(f"PROGRESS:StorageSence:Error: {str(e)}")

    # ==================== PC REPORT METHODS ====================
    def generate_pc_report(self):
        """Generate a comprehensive PC report using the new PCReporter class"""
        self.queue.put("PROGRESS:PC Report:Starting comprehensive PC report generation...")
        self.queue.put("PROGRESS:PC Report:This may take several minutes. Please be patient.")

        try:
            # Create a PCReporter instance
            reporter = PCReporter()

            # Collect all system information
            self.queue.put("PROGRESS:PC Report:Collecting system information...")
            reporter.collect_system_info()

            self.queue.put("PROGRESS:PC Report:Collecting hardware information...")
            reporter.collect_hardware_info()

            self.queue.put("PROGRESS:PC Report:Collecting software information...")
            reporter.collect_software_info()

            self.queue.put("PROGRESS:PC Report:Collecting network information...")
            reporter.collect_network_info()

            self.queue.put("PROGRESS:PC Report:Collecting security information...")
            reporter.collect_security_info()

            self.queue.put("PROGRESS:PC Report:Collecting user information...")
            reporter.collect_user_info()

            self.queue.put("PROGRESS:PC Report:Collecting environment variables...")
            reporter.collect_environment_info()

            self.queue.put("PROGRESS:PC Report:Collecting running processes...")
            reporter.collect_process_info()

            self.queue.put("PROGRESS:PC Report:Collecting system services...")
            reporter.collect_service_info()

            self.queue.put("PROGRESS:PC Report:Collecting hardware devices...")
            reporter.collect_device_info()

            self.queue.put("PROGRESS:PC Report:Collecting performance metrics...")
            reporter.collect_performance_metrics()

            self.queue.put("PROGRESS:PC Report:Checking for security vulnerabilities...")
            reporter.collect_vulnerability_info()

            self.queue.put("PROGRESS:PC Report:Collecting startup items information...")
            reporter.collect_startup_info()

            # Generate HTML report
            self.queue.put("PROGRESS:PC Report:Generating HTML report...")
            report_file = reporter.generate_html_report()

            # Get the full path to the report
            report_path = os.path.abspath(report_file)

            self.queue.put(f"PROGRESS:PC Report:Report saved to: {report_path}")

            # Open the report in the default browser
            self.queue.put("PROGRESS:PC Report:Opening report in default browser...")
            webbrowser.open(f"file:///{report_path}")

            self.queue.put("PROGRESS:PC Report:PC Report generation completed successfully!")

        except Exception as e:
            self.queue.put(f"PROGRESS:PC Report:Error generating PC Report: {str(e)}")
            import traceback
            self.queue.put(f"PROGRESS:PC Report:Traceback: {traceback.format_exc()}")

    # ==================== SYSTEM TASKS METHODS ====================

    def clean_temp_files(self):
        """Clean temporary files from system directories"""
        self.queue.put("PROGRESS:Clean Temp Files:Starting temporary files cleanup...")
        self.queue.put("PROGRESS:Clean Temp Files:Checking temporary directories...")

        try:
            temp_paths = [
                os.environ.get('TEMP', 'C:\\Temp'),
                os.path.join(os.environ.get('SystemRoot', 'C:\\Windows'), 'Temp'),
                os.path.join(os.environ.get('SystemRoot', 'C:\\Windows'), 'Prefetch')
            ]

            for i, path in enumerate(temp_paths):
                try:
                    # Sanitize path
                    safe_path = SecurityUtils.sanitize_path(path)
                    self.queue.put(
                        f"PROGRESS:Clean Temp Files:Processing directory {i + 1}/{len(temp_paths)}: {safe_path}")

                    # Check if path exists
                    if not os.path.exists(safe_path):
                        self.queue.put(f"PROGRESS:Clean Temp Files:Path does not exist: {safe_path}")
                        continue

                    # Count files before deletion
                    try:
                        file_count = len(os.listdir(safe_path))
                        self.queue.put(f"PROGRESS:Clean Temp Files:Found {file_count} items in {safe_path}")
                    except:
                        self.queue.put(f"PROGRESS:Clean Temp Files:Unable to count items in {safe_path}")

                    # Use PowerShell to clean files with detailed output
                    ps_command = f'''
                    $ErrorActionPreference = 'SilentlyContinue'
                    $path = "{safe_path}"
                    $deletedCount = 0
                    $failedCount = 0

                    if (Test-Path $path) {{
                        Get-ChildItem -Path $path -Force | ForEach-Object {{
                            try {{
                                Remove-Item -Path $_.FullName -Recurse -Force -ErrorAction Stop
                                $deletedCount++
                                Write-Host "Deleted: $($_.Name)"
                            }} catch {{
                                $failedCount++
                                Write-Host "Could not delete: $($_.Name) - $($_.Exception.Message)"
                            }}
                        }}
                    }}

                    Write-Host "Summary: Deleted $deletedCount items, Failed: $failedCount items"
                    '''

                    # Run PowerShell command
                    self.queue.put(f"PROGRESS:Clean Temp Files:Executing PowerShell cleanup command...")
                    result = subprocess.run(
                        ['powershell', '-Command', ps_command],
                        capture_output=True,
                        text=True,
                        check=False,
                        timeout=300,  # 5 minute timeout
                        creationflags=CREATE_NO_WINDOW  # Hide console window
                    )

                    # Log output
                    if result.stdout.strip():
                        for line in result.stdout.strip().split('\n'):
                            if line.strip():
                                self.queue.put(f"PROGRESS:Clean Temp Files:{line.strip()}")

                    if result.stderr.strip():
                        self.queue.put(f"PROGRESS:Clean Temp Files:Errors: {result.stderr.strip()}")

                except ValueError as e:
                    self.queue.put(f"PROGRESS:Clean Temp Files:Invalid path rejected: {path}")
                except subprocess.TimeoutExpired:
                    self.queue.put(f"PROGRESS:Clean Temp Files:Timeout cleaning: {path}")
                except Exception as e:
                    self.queue.put(f"PROGRESS:Clean Temp Files:Error cleaning {path}: {str(e)}")

            self.queue.put("PROGRESS:Clean Temp Files:Temporary files cleanup completed")

        except Exception as e:
            self.queue.put(f"PROGRESS:Clean Temp Files:Error in clean temp files: {str(e)}")

    def run_disk_cleanup(self):
        """Run Windows disk cleanup with all options enabled"""
        self.queue.put("PROGRESS:Disk Cleanup:Starting disk cleanup with all options...")
        self.queue.put("PROGRESS:Disk Cleanup:This process may take several minutes. Please be patient.")

        try:
            # Safe registry manipulation with validation
            registry_key_path = r"SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\VolumeCaches"

            # Validate registry path
            SecurityUtils.validate_registry_key(registry_key_path)

            try:
                # Open the key
                self.queue.put("PROGRESS:Disk Cleanup:Accessing Windows registry...")
                key = winreg.OpenKey(
                    winreg.HKEY_LOCAL_MACHINE,
                    registry_key_path,
                    0,
                    winreg.KEY_READ
                )

                # Get all subkeys (cleanup items)
                subkey_count = winreg.QueryInfoKey(key)[0]
                cleanup_items = []

                for i in range(subkey_count):
                    subkey_name = winreg.EnumKey(key, i)
                    cleanup_items.append(subkey_name)

                winreg.CloseKey(key)
                self.queue.put(f"PROGRESS:Disk Cleanup:Found {len(cleanup_items)} cleanup items")

                # Set StateFlags value for each item to 2 (selected for profile 1)
                for i, item in enumerate(cleanup_items):
                    try:
                        self.queue.put(f"PROGRESS:Disk Cleanup:Configuring item {i + 1}/{len(cleanup_items)}: {item}")
                        item_key_path = f"{registry_key_path}\\{item}"
                        # Validate each subkey path
                        SecurityUtils.validate_registry_key(item_key_path)

                        item_key = winreg.OpenKey(
                            winreg.HKEY_LOCAL_MACHINE,
                            item_key_path,
                            0,
                            winreg.KEY_WRITE
                        )

                        # Set StateFlags0001 to 2 (selected for profile 1)
                        winreg.SetValueEx(item_key, "StateFlags0001", 0, winreg.REG_DWORD, 2)
                        winreg.CloseKey(item_key)
                        self.queue.put(f"PROGRESS:Disk Cleanup:Enabled: {item}")
                    except Exception as e:
                        self.queue.put(f"PROGRESS:Disk Cleanup:Error enabling {item}: {str(e)}")

                self.queue.put("PROGRESS:Disk Cleanup:All cleanup options enabled")

                # Run disk cleanup safely
                try:
                    self.queue.put("PROGRESS:Disk Cleanup:Executing: cleanmgr /sagerun:1")
                    self.queue.put("PROGRESS:Disk Cleanup:Starting disk cleanup process...")

                    result = subprocess.run(
                        ['cleanmgr', '/sagerun:1'],
                        capture_output=True,
                        text=True,
                        check=False,
                        timeout=1800,  # 30 minute timeout
                        creationflags=CREATE_NO_WINDOW  # Hide console window
                    )

                    if result.returncode == 0:
                        self.queue.put("PROGRESS:Disk Cleanup:Disk cleanup completed successfully")
                    else:
                        self.queue.put(
                            f"PROGRESS:Disk Cleanup:Disk cleanup completed with return code: {result.returncode}")

                    if result.stdout.strip():
                        self.queue.put(f"PROGRESS:Disk Cleanup:Output: {result.stdout.strip()}")
                    if result.stderr.strip():
                        self.queue.put(f"PROGRESS:Disk Cleanup:Errors: {result.stderr.strip()}")

                except subprocess.TimeoutExpired:
                    self.queue.put("PROGRESS:Disk Cleanup:Disk cleanup timed out after 30 minutes")
                except Exception as e:
                    self.queue.put(f"PROGRESS:Disk Cleanup:Error running disk cleanup: {str(e)}")

            except Exception as e:
                self.queue.put(f"PROGRESS:Disk Cleanup:Error configuring registry: {str(e)}")

        except Exception as e:
            self.queue.put(f"PROGRESS:Disk Cleanup:Error in disk cleanup: {str(e)}")

    def perform_disable_fast_startup(self):
        """Disable Windows fast startup feature"""
        self.queue.put("PROGRESS:Disable Fast Startup:Starting fast startup disable process...")
        try:
            # Step 1: Disable hibernation safely
            self.queue.put("PROGRESS:Disable Fast Startup:Step 1: Disabling hibernation...")
            try:
                self.queue.put("PROGRESS:Disable Fast Startup:Executing: powercfg /h off")
                result = subprocess.run(
                    ['powercfg', '/h', 'off'],
                    capture_output=True,
                    text=True,
                    check=True,
                    timeout=30,
                    creationflags=CREATE_NO_WINDOW  # Hide console window
                )
                self.queue.put("PROGRESS:Disable Fast Startup:Hibernation disabled successfully")
                if result.stdout.strip():
                    self.queue.put(f"PROGRESS:Disable Fast Startup:Output: {result.stdout.strip()}")
            except subprocess.CalledProcessError as e:
                self.queue.put(f"PROGRESS:Disable Fast Startup:Powercfg error: {str(e)}")
                return
            except subprocess.TimeoutExpired:
                self.queue.put("PROGRESS:Disable Fast Startup:Powercfg command timed out")
                return

            # Step 2: Update registry safely
            self.queue.put("PROGRESS:Disable Fast Startup:Step 2: Updating registry settings...")
            registry_key_path = r"SYSTEM\CurrentControlSet\Control\Session Manager\Power"
            registry_value = "HiberbootEnabled"

            try:
                # Validate registry path
                SecurityUtils.validate_registry_key(registry_key_path)

                # Open the key with write access
                self.queue.put("PROGRESS:Disable Fast Startup:Opening registry key for write access...")
                key = winreg.OpenKey(
                    winreg.HKEY_LOCAL_MACHINE,
                    registry_key_path,
                    0,
                    winreg.KEY_WRITE
                )

                # Set the value to 0 (disable Fast Startup)
                self.queue.put("PROGRESS:Disable Fast Startup:Setting HiberbootEnabled to 0...")
                winreg.SetValueEx(key, registry_value, 0, winreg.REG_DWORD, 0)
                winreg.CloseKey(key)
                self.queue.put("PROGRESS:Disable Fast Startup:Registry updated successfully")
            except WindowsError as e:
                if e.errno == 2:  # Key not found
                    try:
                        # Create the key
                        self.queue.put("PROGRESS:Disable Fast Startup:Registry key not found, creating it...")
                        key = winreg.CreateKey(
                            winreg.HKEY_LOCAL_MACHINE,
                            registry_key_path
                        )
                        # Set the value
                        self.queue.put("PROGRESS:Disable Fast Startup:Setting HiberbootEnabled to 0 in new key...")
                        winreg.SetValueEx(key, registry_value, 0, winreg.REG_DWORD, 0)
                        winreg.CloseKey(key)
                        self.queue.put("PROGRESS:Disable Fast Startup:Registry key created and updated")
                    except Exception as create_error:
                        self.queue.put(
                            f"PROGRESS:Disable Fast Startup:Error creating registry key: {str(create_error)}")
                else:
                    self.queue.put(f"PROGRESS:Disable Fast Startup:Registry error: {str(e)}")

            # Step 3: Verify changes
            self.queue.put("PROGRESS:Disable Fast Startup:Step 3: Verifying changes...")
            try:
                key = winreg.OpenKey(
                    winreg.HKEY_LOCAL_MACHINE,
                    registry_key_path,
                    0,
                    winreg.KEY_READ
                )
                value, _ = winreg.QueryValueEx(key, registry_value)
                winreg.CloseKey(key)

                if value == 0:
                    self.queue.put("PROGRESS:Disable Fast Startup:Fast startup disabled successfully")
                else:
                    self.queue.put(f"PROGRESS:Disable Fast Startup:Warning: Registry value is {value}, expected 0")
            except WindowsError as e:
                self.queue.put(f"PROGRESS:Disable Fast Startup:Could not verify registry: {str(e)}")

        except Exception as e:
            self.queue.put(f"PROGRESS:Disable Fast Startup:Error disabling fast startup: {str(e)}")

    def check_and_install_windows_updates(self):
        """Check for and install Windows updates with detailed progress"""
        self.queue.put("PROGRESS:Windows Updates:Starting Windows Update process...")
        self.queue.put("PROGRESS:Windows Updates:This process may take a long time. Please be patient.")

        try:
            # PowerShell script to check for and install Windows updates with detailed progress
            ps_script = '''
            try {
                # Create update session
                $updateSession = New-Object -ComObject Microsoft.Update.Session
                $updateSearcher = $updateSession.CreateUpdateSearcher()

                Write-Host "Phase: Searching for updates..."
                # Search for updates
                Write-Host "Searching for updates..."
                $searchResult = $updateSearcher.Search("IsInstalled=0")

                if ($searchResult.Updates.Count -eq 0) {
                    Write-Host "No updates found."
                    exit 0
                }

                Write-Host "Found $($searchResult.Updates.Count) updates:"
                foreach ($update in $searchResult.Updates) {
                    Write-Host "- $($update.Title)"
                }

                # Download updates
                $updatesToDownload = New-Object -ComObject Microsoft.Update.UpdateColl
                foreach ($update in $searchResult.Updates) {
                    if (-not $update.IsDownloaded) {
                        $updatesToDownload.Add($update) | Out-Null
                    }
                }

                if ($updatesToDownload.Count -gt 0) {
                    Write-Host "Phase: Downloading updates..."
                    Write-Host "Downloading $($updatesToDownload.Count) updates..."
                    $downloader = $updateSession.CreateUpdateDownloader()
                    $downloader.Updates = $updatesToDownload
                    $downloadResult = $downloader.Download()

                    if ($downloadResult.ResultCode -eq 2) {
                        Write-Host "Updates downloaded successfully."
                    } else {
                        Write-Host "Failed to download updates. Result code: $($downloadResult.ResultCode)"
                        exit 1
                    }
                } else {
                    Write-Host "All updates are already downloaded."
                }

                # Install updates
                $updatesToInstall = New-Object -ComObject Microsoft.Update.UpdateColl
                foreach ($update in $searchResult.Updates) {
                    if ($update.IsDownloaded) {
                        $updatesToInstall.Add($update) | Out-Null
                    }
                }

                if ($updatesToInstall.Count -gt 0) {
                    Write-Host "Phase: Installing updates..."
                    Write-Host "Installing $($updatesToInstall.Count) updates..."
                    $installer = $updateSession.CreateUpdateInstaller()
                    $installer.Updates = $updatesToInstall
                    $installResult = $installer.Install()

                    if ($installResult.ResultCode -eq 2) {
                        Write-Host "Updates installed successfully."

                        if ($installResult.RebootRequired) {
                            Write-Host "A system reboot is required to complete the installation."
                            exit 2
                        }
                    } else {
                        Write-Host "Failed to install updates. Result code: $($installResult.ResultCode)"
                        exit 1
                    }
                } else {
                    Write-Host "No updates to install."
                }

                exit 0
            }
            catch {
                Write-Error "Error checking/installing updates: $($_.Exception.Message)"
                exit 1
            }
            '''

            # Run PowerShell script
            self.queue.put("PROGRESS:Windows Updates:Executing PowerShell update script...")
            result = subprocess.run(
                ['powershell', '-Command', ps_script],
                capture_output=True,
                text=True,
                check=False,
                timeout=7200,  # 2 hour timeout (updates can take a long time)
                creationflags=CREATE_NO_WINDOW  # Hide console window
            )

            # Log output
            if result.stdout.strip():
                for line in result.stdout.strip().split('\n'):
                    line = line.strip()
                    if line:
                        if line.startswith("Phase:"):
                            phase = line.replace("Phase:", "").strip()
                            self.queue.put(f"PROGRESS:Windows Updates:{phase}...")
                        elif line.startswith("Found") or line.startswith("Downloading") or line.startswith(
                                "Installing"):
                            self.queue.put(f"PROGRESS:Windows Updates:{line}")
                        elif line.startswith("- "):
                            self.queue.put(f"PROGRESS:Windows Updates:Update: {line[2:]}")
                        else:
                            self.queue.put(f"PROGRESS:Windows Updates:{line}")

            if result.stderr.strip():
                self.queue.put("PROGRESS:Windows Updates:Errors:")
                for line in result.stderr.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:Windows Updates:  {line.strip()}")

            # Check return code
            if result.returncode == 0:
                self.queue.put("PROGRESS:Windows Updates:Windows updates completed successfully")
            elif result.returncode == 2:
                self.queue.put("PROGRESS:Windows Updates:Windows updates installed successfully")
                self.queue.put("PROGRESS:Windows Updates:A system reboot is required to complete the installation")
                self.queue.put("WINDOWS_UPDATES_REBOOT_REQUIRED")
                self.root.after(100, self.prompt_reboot_for_updates)
            else:
                self.queue.put(
                    f"PROGRESS:Windows Updates:Windows updates completed with return code: {result.returncode}")

        except subprocess.TimeoutExpired:
            self.queue.put("PROGRESS:Windows Updates:Windows updates process timed out after 2 hours")
        except Exception as e:
            self.queue.put(f"PROGRESS:Windows Updates:Error in Windows updates: {str(e)}")

    def check_and_install_device_firmware(self):
        """Check for and install device firmware updates"""
        self.queue.put("PROGRESS:Device Firmware:Starting device firmware update process...")
        self.queue.put("PROGRESS:Device Firmware:This process may take a long time. Please be patient.")

        # Initialize COM for this thread
        initialized = False
        try:
            try:
                pythoncom.CoInitialize()
                initialized = True
            except Exception as e:
                self.queue.put(f"PROGRESS:Device Firmware:COM initialization failed: {str(e)}")
                return

            # Get device information
            self.queue.put("PROGRESS:Device Firmware:Detecting device information...")

            # Try to get WMI information with error handling
            try:
                c = wmi.WMI()

                # Get system manufacturer and model
                try:
                    system_info = c.Win32_ComputerSystem()[0]
                    manufacturer = system_info.Manufacturer.strip().lower()
                    model = system_info.Model.strip()
                    self.queue.put(f"PROGRESS:Device Firmware:Manufacturer: {manufacturer}")
                    self.queue.put(f"PROGRESS:Device Firmware:Model: {model}")
                except Exception as e:
                    self.queue.put(f"PROGRESS:Device Firmware:Error getting system info: {str(e)}")
                    manufacturer = "unknown"
                    model = "unknown"

                # Get serial number
                try:
                    bios_info = c.Win32_BIOS()[0]
                    serial_number = bios_info.SerialNumber.strip()
                    self.queue.put(f"PROGRESS:Device Firmware:Serial Number: {serial_number}")
                except Exception as e:
                    self.queue.put(f"PROGRESS:Device Firmware:Error getting BIOS info: {str(e)}")
                    serial_number = "unknown"

            except Exception as e:
                self.queue.put(f"PROGRESS:Device Firmware:Error initializing WMI: {str(e)}")
                self.queue.put("PROGRESS:Device Firmware:Unable to detect device information")
                self.queue.put("PROGRESS:Device Firmware:Please visit your manufacturer's support website manually")
                return

            # Check for supported manufacturers
            if 'dell' in manufacturer:
                self.queue.put("PROGRESS:Device Firmware:Detected Dell system")
                self.update_dell_firmware(model, serial_number)
            elif 'hp' in manufacturer or 'hewlett packard' in manufacturer:
                self.queue.put("PROGRESS:Device Firmware:Detected HP system")
                self.update_hp_firmware(model, serial_number)
            elif 'lenovo' in manufacturer:
                self.queue.put("PROGRESS:Device Firmware:Detected Lenovo system")
                self.update_lenovo_firmware(model, serial_number)
            else:
                self.queue.put(f"PROGRESS:Device Firmware:Unsupported manufacturer: {manufacturer}")
                self.queue.put("PROGRESS:Device Firmware:Please visit your manufacturer's support website manually")

                # Open manufacturer's support website
                try:
                    if 'dell' in manufacturer:
                        webbrowser.open("https://www.dell.com/support")
                    elif 'hp' in manufacturer or 'hewlett packard' in manufacturer:
                        webbrowser.open("https://support.hp.com")
                    elif 'lenovo' in manufacturer:
                        webbrowser.open("https://support.lenovo.com")
                    else:
                        webbrowser.open("https://www.bing.com/search?q=" + manufacturer + "+support")
                    self.queue.put("PROGRESS:Device Firmware:Opened manufacturer support website")
                except Exception as e:
                    self.queue.put(f"PROGRESS:Device Firmware:Error opening web browser: {str(e)}")

        except Exception as e:
            self.queue.put(f"PROGRESS:Device Firmware:Error in device firmware update: {str(e)}")
        finally:
            if initialized:
                pythoncom.CoUninitialize()

    def update_dell_firmware(self, model, serial_number):
        """Update Dell firmware using Dell Command Update or open support website"""
        self.queue.put("PROGRESS:Device Firmware:Checking for Dell Command Update...")

        # Check if Dell Command Update is installed
        dell_command_update_paths = [
            r"C:\Program Files\Dell\CommandUpdate\dcu-cli.exe",
            r"C:\Program Files (x86)\Dell\CommandUpdate\dcu-cli.exe"
        ]

        dcu_found = False
        for path in dell_command_update_paths:
            try:
                if os.path.exists(path):
                    dcu_found = True
                    self.queue.put(f"PROGRESS:Device Firmware:Dell Command Update found at: {path}")

                    # Run Dell Command Update
                    try:
                        self.queue.put("PROGRESS:Device Firmware:Running Dell Command Update...")
                        self.queue.put("PROGRESS:Device Firmware:Command: dcu-cli /scan /applyUpdates")

                        result = subprocess.run(
                            [path, '/scan', '/applyUpdates'],
                            capture_output=True,
                            text=True,
                            check=False,
                            timeout=3600,  # 1 hour timeout
                            creationflags=CREATE_NO_WINDOW  # Hide console window
                        )

                        if result.stdout.strip():
                            self.queue.put("PROGRESS:Device Firmware:Dell Command Update Output:")
                            for line in result.stdout.strip().split('\n'):
                                if line.strip():
                                    self.queue.put(f"PROGRESS:Device Firmware:  {line.strip()}")

                        if result.stderr.strip():
                            self.queue.put("PROGRESS:Device Firmware:Dell Command Update Errors:")
                            for line in result.stderr.strip().split('\n'):
                                if line.strip():
                                    self.queue.put(f"PROGRESS:Device Firmware:  {line.strip()}")

                        if result.returncode == 0:
                            self.queue.put("PROGRESS:Device Firmware:Dell firmware updates completed successfully")
                        else:
                            self.queue.put(
                                f"PROGRESS:Device Firmware:Dell Command Update completed with code: {result.returncode}")

                    except subprocess.TimeoutExpired:
                        self.queue.put("PROGRESS:Device Firmware:Dell Command Update timed out after 1 hour")
                    except Exception as e:
                        self.queue.put(f"PROGRESS:Device Firmware:Error running Dell Command Update: {str(e)}")

                    break
            except Exception as e:
                self.queue.put(f"PROGRESS:Device Firmware:Error checking path {path}: {str(e)}")
                continue

        if not dcu_found:
            self.queue.put("PROGRESS:Device Firmware:Dell Command Update not found")
            self.queue.put("PROGRESS:Device Firmware:Opening Dell support website...")

            # Open Dell support website with model pre-filled
            try:
                support_url = f"https://www.dell.com/support/home/en-us?app=drivers&serviceTag={serial_number}"
                self.queue.put(f"PROGRESS:Device Firmware:Opening: {support_url}")
                webbrowser.open(support_url)
                self.queue.put("PROGRESS:Device Firmware:Please download and install firmware updates manually")
            except Exception as e:
                self.queue.put(f"PROGRESS:Device Firmware:Error opening Dell support website: {str(e)}")
                # Fallback to generic Dell support page
                try:
                    webbrowser.open("https://www.dell.com/support")
                    self.queue.put("PROGRESS:Device Firmware:Opened generic Dell support page")
                except Exception as e2:
                    self.queue.put(f"PROGRESS:Device Firmware:Error opening generic support page: {str(e2)}")

    def update_hp_firmware(self, model, serial_number):
        """Update HP firmware using HP Support Assistant or open support website"""
        self.queue.put("PROGRESS:Device Firmware:Checking for HP Support Assistant...")

        # Check if HP Support Assistant is installed
        hp_support_assistant_paths = [
            r"C:\Program Files (x86)\Hewlett-Packard\HP Support Framework\HPSA.exe",
            r"C:\Program Files\Hewlett-Packard\HP Support Framework\HPSA.exe"
        ]

        hpsa_found = False
        for path in hp_support_assistant_paths:
            try:
                if os.path.exists(path):
                    hpsa_found = True
                    self.queue.put(f"PROGRESS:Device Firmware:HP Support Assistant found at: {path}")

                    # Run HP Support Assistant
                    try:
                        self.queue.put("PROGRESS:Device Firmware:Running HP Support Assistant...")

                        # HP Support Assistant doesn't have a good CLI, so we'll just open it
                        subprocess.Popen([path], creationflags=CREATE_NO_WINDOW)  # Hide console window
                        self.queue.put("PROGRESS:Device Firmware:HP Support Assistant opened")
                        self.queue.put(
                            "PROGRESS:Device Firmware:Please check for updates in the HP Support Assistant window")

                    except Exception as e:
                        self.queue.put(f"PROGRESS:Device Firmware:Error opening HP Support Assistant: {str(e)}")

                    break
            except Exception as e:
                self.queue.put(f"PROGRESS:Device Firmware:Error checking path {path}: {str(e)}")
                continue

        if not hpsa_found:
            self.queue.put("PROGRESS:Device Firmware:HP Support Assistant not found")
            self.queue.put("PROGRESS:Device Firmware:Opening HP support website...")

            # Open HP support website
            try:
                # Clean up model name for URL
                clean_model = re.sub(r'[^a-zA-Z0-9\- ]', '', model)
                clean_model = re.sub(r'\s+', '-', clean_model)
                support_url = f"https://support.hp.com/us-en/drivers/{clean_model}"
                self.queue.put(f"PROGRESS:Device Firmware:Opening: {support_url}")
                webbrowser.open(support_url)
                self.queue.put("PROGRESS:Device Firmware:Please download and install firmware updates manually")
            except Exception as e:
                self.queue.put(f"PROGRESS:Device Firmware:Error opening HP support website: {str(e)}")
                # Fallback to generic HP support page
                try:
                    webbrowser.open("https://support.hp.com")
                    self.queue.put("PROGRESS:Device Firmware:Opened generic HP support page")
                except Exception as e2:
                    self.queue.put(f"PROGRESS:Device Firmware:Error opening generic support page: {str(e2)}")

    def update_lenovo_firmware(self, model, serial_number):
        """Update Lenovo firmware using Lenovo Vantage or open support website"""
        self.queue.put("PROGRESS:Device Firmware:Checking for Lenovo Vantage...")

        # Check if Lenovo Vantage is installed
        lenovo_vantage_paths = [
            r"C:\Program Files\Lenovo\VantageService\LenovoVantage.exe",
            r"C:\Program Files (x86)\Lenovo\VantageService\LenovoVantage.exe"
        ]

        vantage_found = False
        for path in lenovo_vantage_paths:
            try:
                if os.path.exists(path):
                    vantage_found = True
                    self.queue.put(f"PROGRESS:Device Firmware:Lenovo Vantage found at: {path}")

                    # Run Lenovo Vantage
                    try:
                        self.queue.put("PROGRESS:Device Firmware:Running Lenovo Vantage...")

                        # Lenovo Vantage doesn't have a good CLI, so we'll just open it
                        subprocess.Popen([path], creationflags=CREATE_NO_WINDOW)  # Hide console window
                        self.queue.put("PROGRESS:Device Firmware:Lenovo Vantage opened")
                        self.queue.put("PROGRESS:Device Firmware:Please check for updates in the Lenovo Vantage window")

                    except Exception as e:
                        self.queue.put(f"PROGRESS:Device Firmware:Error opening Lenovo Vantage: {str(e)}")

                    break
            except Exception as e:
                self.queue.put(f"PROGRESS:Device Firmware:Error checking path {path}: {str(e)}")
                continue

        if not vantage_found:
            self.queue.put("PROGRESS:Device Firmware:Lenovo Vantage not found")
            self.queue.put("PROGRESS:Device Firmware:Opening Lenovo support website...")

            # Open Lenovo support website with MTM (Machine Type Model) pre-filled
            try:
                # Extract MTM from model name
                mtm_match = re.search(r'\b[A-Z0-9]{4}\b', model)
                if mtm_match:
                    mtm = mtm_match.group(0)
                else:
                    # If no MTM found, use the cleaned model name
                    mtm = re.sub(r'[^a-zA-Z0-9\- ]', '', model)
                    mtm = re.sub(r'\s+', '-', mtm)

                support_url = f"https://support.lenovo.com/us/en/products/{mtm}"
                self.queue.put(f"PROGRESS:Device Firmware:Opening: {support_url}")
                webbrowser.open(support_url)
                self.queue.put("PROGRESS:Device Firmware:Please download and install firmware updates manually")
            except Exception as e:
                self.queue.put(f"PROGRESS:Device Firmware:Error opening Lenovo support website: {str(e)}")
                # Fallback to generic Lenovo support page
                try:
                    webbrowser.open("https://support.lenovo.com")
                    self.queue.put("PROGRESS:Device Firmware:Opened generic Lenovo support page")
                except Exception as e2:
                    self.queue.put(f"PROGRESS:Device Firmware:Error opening generic support page: {str(e2)}")

    def repair_system_files(self):
        """Repair Windows system files using SFC and DISM"""
        self.queue.put("PROGRESS:System Repair:Starting Windows system file repair...")
        self.queue.put("PROGRESS:System Repair:This process may take 30 minutes or more. Please be patient.")

        # Step 1: Run SFC (System File Checker)
        self.queue.put("PROGRESS:System Repair:=== Running System File Checker (SFC) ===")
        try:
            self.queue.put("PROGRESS:System Repair:Executing: sfc /scannow")
            self.queue.put("PROGRESS:System Repair:Starting SFC scan...")

            result = subprocess.run(
                ['sfc', '/scannow'],
                capture_output=True,
                text=True,
                timeout=1800,  # 30 minute timeout
                creationflags=CREATE_NO_WINDOW  # Hide console window
            )

            self.queue.put("PROGRESS:System Repair:SFC scan completed")

            if result.stdout.strip():
                self.queue.put("PROGRESS:System Repair:SFC Output:")
                for line in result.stdout.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:System Repair:  {line.strip()}")

            if result.stderr.strip():
                self.queue.put("PROGRESS:System Repair:SFC Errors:")
                for line in result.stderr.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:System Repair:  {line.strip()}")

            # Check return code
            if result.returncode == 0:
                self.queue.put("PROGRESS:System Repair:SFC scan completed successfully")
            elif result.returncode == 1:
                self.queue.put("PROGRESS:System Repair:SFC found and fixed corrupted files")
            elif result.returncode == 2:
                self.queue.put("PROGRESS:System Repair:SFC found corrupted files but couldn't fix some")
            else:
                self.queue.put(f"PROGRESS:System Repair:SFC completed with return code: {result.returncode}")

        except subprocess.TimeoutExpired:
            self.queue.put("PROGRESS:System Repair:SFC scan timed out after 30 minutes")
        except Exception as e:
            self.queue.put(f"PROGRESS:System Repair:Error running SFC: {str(e)}")

        # Step 2: Run DISM (Deployment Image Servicing and Management)
        self.queue.put("PROGRESS:System Repair:=== Running DISM to repair component store ===")
        try:
            self.queue.put("PROGRESS:System Repair:Executing: DISM /Online /Cleanup-Image /RestoreHealth")
            self.queue.put("PROGRESS:System Repair:Starting DISM repair...")

            result = subprocess.run(
                ['DISM', '/Online', '/Cleanup-Image', '/RestoreHealth'],
                capture_output=True,
                text=True,
                timeout=1800,  # 30 minute timeout
                creationflags=CREATE_NO_WINDOW  # Hide console window
            )

            self.queue.put("PROGRESS:System Repair:DISM repair completed")

            if result.stdout.strip():
                self.queue.put("PROGRESS:System Repair:DISM Output:")
                for line in result.stdout.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:System Repair:  {line.strip()}")

            if result.stderr.strip():
                self.queue.put("PROGRESS:System Repair:DISM Errors:")
                for line in result.stderr.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:System Repair:  {line.strip()}")

            # Check return code
            if result.returncode == 0:
                self.queue.put("PROGRESS:System Repair:DISM repair completed successfully")
            else:
                self.queue.put(f"PROGRESS:System Repair:DISM completed with return code: {result.returncode}")

        except subprocess.TimeoutExpired:
            self.queue.put("PROGRESS:System Repair:DISM repair timed out after 30 minutes")
        except Exception as e:
            self.queue.put(f"PROGRESS:System Repair:Error running DISM: {str(e)}")

        # Step 3: Run SFC again after DISM
        self.queue.put("PROGRESS:System Repair:=== Running System File Checker (SFC) again after DISM ===")
        try:
            self.queue.put("PROGRESS:System Repair:Executing: sfc /scannow")
            self.queue.put("PROGRESS:System Repair:Starting second SFC scan...")

            result = subprocess.run(
                ['sfc', '/scannow'],
                capture_output=True,
                text=True,
                timeout=1800,  # 30 minute timeout
                creationflags=CREATE_NO_WINDOW  # Hide console window
            )

            self.queue.put("PROGRESS:System Repair:Second SFC scan completed")

            if result.stdout.strip():
                self.queue.put("PROGRESS:System Repair:SFC Output:")
                for line in result.stdout.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:System Repair:  {line.strip()}")

            if result.stderr.strip():
                self.queue.put("PROGRESS:System Repair:SFC Errors:")
                for line in result.stderr.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:System Repair:  {line.strip()}")

            # Check return code
            if result.returncode == 0:
                self.queue.put("PROGRESS:System Repair:Second SFC scan completed successfully")
            elif result.returncode == 1:
                self.queue.put("PROGRESS:System Repair:SFC found and fixed corrupted files")
            elif result.returncode == 2:
                self.queue.put("PROGRESS:System Repair:SFC found corrupted files but couldn't fix some")
            else:
                self.queue.put(f"PROGRESS:System Repair:SFC completed with return code: {result.returncode}")

        except subprocess.TimeoutExpired:
            self.queue.put("PROGRESS:System Repair:Second SFC scan timed out after 30 minutes")
        except Exception as e:
            self.queue.put(f"PROGRESS:System Repair:Error running second SFC: {str(e)}")

        self.queue.put("PROGRESS:System Repair:System repair process completed!")
        self.queue.put("PROGRESS:System Repair:A restart may be required for all changes to take effect.")

    def run_chk_dsk(self):
        """Schedule CHKDSK to run on next reboot with repair options"""
        self.queue.put("PROGRESS:CHKDSK:Starting CHKDSK on drive C: with repair options...")
        self.queue.put("PROGRESS:CHKDSK:Warning: This operation requires a system reboot to complete.")

        try:
            # First, check if the drive is already marked for checking
            self.queue.put("PROGRESS:CHKDSK:Checking current disk status...")
            result = subprocess.run(
                ['fsutil', 'dirty', 'query', 'C:'],
                capture_output=True,
                text=True,
                check=False,
                timeout=30,
                creationflags=CREATE_NO_WINDOW  # Hide console window
            )

            if "Volume is dirty" in result.stdout:
                self.queue.put("PROGRESS:CHKDSK:Drive C: is already marked for checking")
            else:
                self.queue.put("PROGRESS:CHKDSK:Drive C: is not currently marked for checking")

            # Schedule CHKDSK to run on next reboot with repair options
            self.queue.put("PROGRESS:CHKDSK:Scheduling CHKDSK to run on next reboot...")
            self.queue.put("PROGRESS:CHKDSK:Executing: chkdsk C: /F /R /X")

            result = subprocess.run(
                ['chkdsk', 'C:', '/F', '/R', '/X'],
                capture_output=True,
                text=True,
                check=False,
                timeout=60,
                creationflags=CREATE_NO_WINDOW  # Hide console window
            )

            # Log the output
            if result.stdout.strip():
                self.queue.put("PROGRESS:CHKDSK:CHKDSK Output:")
                for line in result.stdout.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:CHKDSK:  {line.strip()}")

            if result.stderr.strip():
                self.queue.put("PROGRESS:CHKDSK:CHKDSK Errors:")
                for line in result.stderr.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:CHKDSK:  {line.strip()}")

            # Check return code
            if result.returncode == 0:
                self.queue.put("PROGRESS:CHKDSK:CHKDSK successfully scheduled for next reboot")

                # Ask user if they want to reboot now
                self.queue.put("CHKDSK_SCHEDULED")
                self.root.after(100, self.prompt_reboot)
            else:
                self.queue.put(f"PROGRESS:CHKDSK:CHKDSK scheduling completed with return code: {result.returncode}")

        except subprocess.TimeoutExpired:
            self.queue.put("PROGRESS:CHKDSK:CHKDSK command timed out")
        except Exception as e:
            self.queue.put(f"PROGRESS:CHKDSK:Error scheduling CHKDSK: {str(e)}")

    def perform_windows_adjustments(self):
        """Apply various Windows system adjustments for better performance"""
        self.queue.put("PROGRESS:Windows Adjustments:Starting Windows adjustments...")
        self.queue.put(
            "PROGRESS:Windows Adjustments:This will modify focus, network, visual effects, and gaming settings.")

        try:
            # Registry modifications with validation
            adjustments = [
                {
                    "name": "Focus Assist",
                    "path": r"SOFTWARE\Microsoft\Windows\CurrentVersion\Notifications\Settings\QuietHours",
                    "values": [("QuietHoursState", 0)]
                },
                {
                    "name": "Transparency Effects",
                    "path": r"SOFTWARE\Microsoft\Windows\CurrentVersion\Themes\Personalize",
                    "values": [("EnableTransparency", 0)]
                },
                {
                    "name": "Game Bar",
                    "path": r"SOFTWARE\Microsoft\Windows\CurrentVersion\GameDVR",
                    "values": [("AppCaptureEnabled", 0), ("BackgroundRecordingEnabled", 0)]
                },
                {
                    "name": "Game Mode",
                    "path": r"SOFTWARE\Microsoft\GameBar",
                    "values": [("AllowAutoGameMode", 0), ("AutoGameModeEnabled", 0)]
                },
                {
                    "name": "Game DVR",
                    "path": r"SOFTWARE\Microsoft\Windows\CurrentVersion\GameDVR",
                    "values": [("AllowGameDVR", 0)]
                },
                {
                    "name": "Game Capture",
                    "path": r"SOFTWARE\Microsoft\Windows\CurrentVersion\GameDVR",
                    "values": [("GameCaptureEnabled", 0)]
                }
            ]

            for i, adjustment in enumerate(adjustments):
                try:
                    self.queue.put(
                        f"PROGRESS:Windows Adjustments:Processing adjustment {i + 1}/{len(adjustments)}: {adjustment['name']}...")

                    # Validate registry path
                    SecurityUtils.validate_registry_key(adjustment["path"])

                    # Open or create registry key
                    try:
                        key = winreg.OpenKey(
                            winreg.HKEY_CURRENT_USER,
                            adjustment["path"],
                            0,
                            winreg.KEY_WRITE
                        )
                    except WindowsError as e:
                        if e.errno == 2:  # Key not found
                            self.queue.put(f"PROGRESS:Windows Adjustments:Registry key not found, creating it...")
                            key = winreg.CreateKey(
                                winreg.HKEY_CURRENT_USER,
                                adjustment["path"]
                            )
                        else:
                            raise

                    # Set values
                    for j, (value_name, value_data) in enumerate(adjustment["values"]):
                        self.queue.put(
                            f"PROGRESS:Windows Adjustments:Setting registry value {j + 1}/{len(adjustment['values'])}: {value_name} = {value_data}")
                        winreg.SetValueEx(key, value_name, 0, winreg.REG_DWORD, value_data)

                    winreg.CloseKey(key)
                    self.queue.put(f"PROGRESS:Windows Adjustments:{adjustment['name']} disabled")

                except Exception as e:
                    self.queue.put(f"PROGRESS:Windows Adjustments:Error disabling {adjustment['name']}: {str(e)}")

            # Network adjustment using safe PowerShell
            self.queue.put("PROGRESS:Windows Adjustments:Changing network to private...")
            try:
                ps_script = '''
                try {
                    Get-NetConnectionProfile | Set-NetConnectionProfile -NetworkCategory Private
                    Write-Host "Network category set to Private"
                } catch {
                    Write-Host "Error setting network category: $($_.Exception.Message)"
                }
                '''

                self.queue.put("PROGRESS:Windows Adjustments:Executing PowerShell network adjustment script...")
                result = subprocess.run(
                    ['powershell', '-Command', ps_script],
                    capture_output=True,
                    text=True,
                    check=False,
                    timeout=60,
                    creationflags=CREATE_NO_WINDOW  # Hide console window
                )

                if result.stdout.strip():
                    self.queue.put("PROGRESS:Windows Adjustments:Network adjustment output:")
                    for line in result.stdout.strip().split('\n'):
                        if line.strip():
                            self.queue.put(f"PROGRESS:Windows Adjustments:  {line.strip()}")

                if result.stderr.strip():
                    self.queue.put("PROGRESS:Windows Adjustments:Network adjustment errors:")
                    for line in result.stderr.strip().split('\n'):
                        if line.strip():
                            self.queue.put(f"PROGRESS:Windows Adjustments:  {line.strip()}")

            except subprocess.TimeoutExpired:
                self.queue.put("PROGRESS:Windows Adjustments:Network adjustment timed out")
            except Exception as e:
                self.queue.put(f"PROGRESS:Windows Adjustments:Error changing network: {str(e)}")

            self.queue.put("PROGRESS:Windows Adjustments:Windows adjustments completed!")
            self.queue.put("PROGRESS:Windows Adjustments:Some changes may require a restart or logout to take effect.")

        except Exception as e:
            self.queue.put(f"PROGRESS:Windows Adjustments:Error in Windows adjustments: {str(e)}")

    def flush_dns_and_renew_ip(self):
        """Flush DNS and renew IP address"""
        self.queue.put("PROGRESS:Flush DNS and Renew IP:Starting DNS flush and IP renewal...")

        try:
            # Step 1: Release IP
            self.queue.put("PROGRESS:Flush DNS and Renew IP:Step 1: Releasing IP address...")
            try:
                self.queue.put("PROGRESS:Flush DNS and Renew IP:Executing: ipconfig /release")
                result = subprocess.run(
                    ['ipconfig', '/release'],
                    capture_output=True,
                    text=True,
                    check=False,
                    timeout=30,
                    creationflags=CREATE_NO_WINDOW  # Hide console window
                )
                self.queue.put("PROGRESS:Flush DNS and Renew IP:IP address released successfully")
                if result.stdout.strip():
                    self.queue.put(f"PROGRESS:Flush DNS and Renew IP:Output: {result.stdout.strip()}")
                if result.stderr.strip():
                    self.queue.put(f"PROGRESS:Flush DNS and Renew IP:Errors: {result.stderr.strip()}")
            except subprocess.TimeoutExpired:
                self.queue.put("PROGRESS:Flush DNS and Renew IP:IP release command timed out")
            except Exception as e:
                self.queue.put(f"PROGRESS:Flush DNS and Renew IP:Error releasing IP: {str(e)}")

            # Step 2: Renew IP
            self.queue.put("PROGRESS:Flush DNS and Renew IP:Step 2: Renewing IP address...")
            try:
                self.queue.put("PROGRESS:Flush DNS and Renew IP:Executing: ipconfig /renew")
                result = subprocess.run(
                    ['ipconfig', '/renew'],
                    capture_output=True,
                    text=True,
                    check=False,
                    timeout=60,  # May take longer
                    creationflags=CREATE_NO_WINDOW  # Hide console window
                )
                self.queue.put("PROGRESS:Flush DNS and Renew IP:IP address renewed successfully")
                if result.stdout.strip():
                    self.queue.put(f"PROGRESS:Flush DNS and Renew IP:Output: {result.stdout.strip()}")
                if result.stderr.strip():
                    self.queue.put(f"PROGRESS:Flush DNS and Renew IP:Errors: {result.stderr.strip()}")
            except subprocess.TimeoutExpired:
                self.queue.put("PROGRESS:Flush DNS and Renew IP:IP renewal command timed out")
            except Exception as e:
                self.queue.put(f"PROGRESS:Flush DNS and Renew IP:Error renewing IP: {str(e)}")

            # Step 3: Flush DNS
            self.queue.put("PROGRESS:Flush DNS and Renew IP:Step 3: Flushing DNS...")
            try:
                self.queue.put("PROGRESS:Flush DNS and Renew IP:Executing: ipconfig /flushdns")
                result = subprocess.run(
                    ['ipconfig', '/flushdns'],
                    capture_output=True,
                    text=True,
                    check=False,
                    timeout=30,
                    creationflags=CREATE_NO_WINDOW  # Hide console window
                )
                self.queue.put("PROGRESS:Flush DNS and Renew IP:DNS flushed successfully")
                if result.stdout.strip():
                    self.queue.put(f"PROGRESS:Flush DNS and Renew IP:Output: {result.stdout.strip()}")
                if result.stderr.strip():
                    self.queue.put(f"PROGRESS:Flush DNS and Renew IP:Errors: {result.stderr.strip()}")
            except subprocess.TimeoutExpired:
                self.queue.put("PROGRESS:Flush DNS and Renew IP:DNS flush command timed out")
            except Exception as e:
                self.queue.put(f"PROGRESS:Flush DNS and Renew IP:Error flushing DNS: {str(e)}")

            self.queue.put("PROGRESS:Flush DNS and Renew IP:DNS flush and IP renewal completed successfully!")

        except Exception as e:
            self.queue.put(f"PROGRESS:Flush DNS and Renew IP:Error in DNS flush and IP renewal: {str(e)}")

    def display_ip_config(self):
        """Display IP configuration using ipconfig /all"""
        self.queue.put("PROGRESS:Display IP Configuration:Retrieving IP configuration...")

        try:
            self.queue.put("PROGRESS:Display IP Configuration:Executing: ipconfig /all")
            result = subprocess.run(
                ['ipconfig', '/all'],
                capture_output=True,
                text=True,
                check=False,
                timeout=30,
                creationflags=CREATE_NO_WINDOW  # Hide console window
            )

            self.queue.put("PROGRESS:Display IP Configuration:IP configuration retrieved successfully")

            if result.stdout.strip():
                self.queue.put("PROGRESS:Display IP Configuration:=== IP Configuration ===")
                for line in result.stdout.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:Display IP Configuration:{line.strip()}")

            if result.stderr.strip():
                self.queue.put("PROGRESS:Display IP Configuration:Errors:")
                for line in result.stderr.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:Display IP Configuration:  {line.strip()}")

            self.queue.put("PROGRESS:Display IP Configuration:IP configuration display completed!")

        except subprocess.TimeoutExpired:
            self.queue.put("PROGRESS:Display IP Configuration:IP configuration command timed out")
        except Exception as e:
            self.queue.put(f"PROGRESS:Display IP Configuration:Error displaying IP configuration: {str(e)}")

    def change_dns_servers(self):
        """Change DNS servers to 1.1.1.1 and 8.8.8.8"""
        self.queue.put("PROGRESS:Change DNS:Starting DNS server change process...")
        self.queue.put("PROGRESS:Change DNS:This will change the DNS servers for all active network interfaces.")

        try:
            # PowerShell script to change DNS servers for all active interfaces
            ps_script = '''
            try {
                $interfaces = Get-NetAdapter | Where-Object {$_.Status -eq "Up"}
                $changedCount = 0

                foreach ($interface in $interfaces) {
                    try {
                        $interfaceName = $interface.Name
                        Write-Host "Changing DNS for interface: $interfaceName"

                        # Set DNS servers
                        Set-DnsClientServerAddress -InterfaceAlias $interfaceName -ServerAddresses "1.1.1.1","8.8.8.8" -ErrorAction Stop

                        # Verify the change
                        $dnsServers = Get-DnsClientServerAddress -InterfaceAlias $interfaceName -AddressFamily IPv4 -ErrorAction SilentlyContinue
                        if ($dnsServers.ServerAddresses -contains "1.1.1.1" -and $dnsServers.ServerAddresses -contains "8.8.8.8") {
                            Write-Host "DNS successfully changed for $interfaceName"
                            $changedCount++
                        } else {
                            Write-Host "Warning: DNS change may not have been applied correctly for $interfaceName"
                        }
                    } catch {
                        Write-Host "Error changing DNS for $($interface.Name): $($_.Exception.Message)"
                    }
                }

                if ($changedCount -gt 0) {
                    Write-Host "DNS servers changed successfully for $changedCount interface(s)"
                    Write-Host "Primary DNS: 1.1.1.1 (Cloudflare)"
                    Write-Host "Secondary DNS: 8.8.8.8 (Google)"
                } else {
                    Write-Host "No active network interfaces found or DNS could not be changed"
                }
            } catch {
                Write-Error "Error changing DNS servers: $($_.Exception.Message)"
            }
            '''

            self.queue.put("PROGRESS:Change DNS:Executing PowerShell DNS change script...")
            result = subprocess.run(
                ['powershell', '-Command', ps_script],
                capture_output=True,
                text=True,
                check=False,
                timeout=60,
                creationflags=CREATE_NO_WINDOW  # Hide console window
            )

            self.queue.put("PROGRESS:Change DNS:DNS change process completed")

            if result.stdout.strip():
                self.queue.put("PROGRESS:Change DNS:Script output:")
                for line in result.stdout.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:Change DNS:  {line.strip()}")

            if result.stderr.strip():
                self.queue.put("PROGRESS:Change DNS:Script errors:")
                for line in result.stderr.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:Change DNS:  {line.strip()}")

            self.queue.put("PROGRESS:Change DNS:DNS server change process completed!")
            self.queue.put(
                "PROGRESS:Change DNS:Note: You may need to restart your browser or applications for changes to take effect.")

        except subprocess.TimeoutExpired:
            self.queue.put("PROGRESS:Change DNS:DNS change process timed out")
        except Exception as e:
            self.queue.put(f"PROGRESS:Change DNS:Error changing DNS servers: {str(e)}")

    def create_autopilot_csv(self):
        """Create AutoPilot CSV for Windows deployment"""
        self.queue.put("PROGRESS:AutoPilot CSV:Starting AutoPilot CSV creation...")
        self.queue.put("PROGRESS:AutoPilot CSV:This process may take several minutes. Please be patient.")

        try:
            # Step 1: Create PowerShell folder safely
            self.queue.put("PROGRESS:AutoPilot CSV:Step 1: Creating PowerShell folder on C: drive...")

            try:
                powershell_folder = SecurityUtils.sanitize_path("C:\\PowerShell")

                if not os.path.exists(powershell_folder):
                    os.makedirs(powershell_folder)
                    self.queue.put(f"PROGRESS:AutoPilot CSV:Created folder: {powershell_folder}")
                else:
                    self.queue.put(f"PROGRESS:AutoPilot CSV:Folder already exists: {powershell_folder}")

            except Exception as e:
                self.queue.put(f"PROGRESS:AutoPilot CSV:Error creating folder: {str(e)}")
                return

            # Step 2: Create a secure script for autopilot info
            self.queue.put("PROGRESS:AutoPilot CSV:Step 2: Creating AutoPilot script...")
            try:
                script_content = '''
# Secure AutoPilot Info Script
function Get-AutoPilotInfo {
    param(
        [string]$OutputFile = "AutoPilot.csv"
    )

    try {
        # Get device serial number
        $serialNumber = (Get-WmiObject -Class Win32_BIOS).SerialNumber

        # Get hardware hash
        $hardwareHash = ""
        try {
            $devDetail = Get-WmiObject -Namespace root/cimv2/mdm/dmmap -Class MDM_DevDetail_Ext01 -Filter "InstanceID='Ext'"
            if ($devDetail) {
                $hardwareHash = $devDetail.DeviceHardwareData
            }
        } catch {
            Write-Warning "Could not retrieve hardware hash"
        }

        # Create CSV content
        $csvHeader = "Device Serial Number,Windows Product ID,Hardware Hash"
        $csvData = "$serialNumber,,$hardwareHash"

        # Write to file
        $csvContent = $csvHeader + "`r`n" + $csvData
        $csvContent | Out-File -FilePath $OutputFile -Encoding UTF8

        Write-Host "AutoPilot CSV created: $OutputFile"
        Write-Host "Serial Number: $serialNumber"
        Write-Host "Hardware Hash Length: $($hardwareHash.Length)"

    } catch {
        Write-Error "Error creating AutoPilot CSV: $($_.Exception.Message)"
    }
}

# Run the function
Get-AutoPilotInfo -OutputFile "C:\\PowerShell\\AutoPilot.csv"
'''

                script_path = os.path.join(powershell_folder, "Get-AutoPilotInfo.ps1")
                with open(script_path, 'w', encoding='utf-8') as f:
                    f.write(script_content)

                self.queue.put(f"PROGRESS:AutoPilot CSV:Script created at: {script_path}")

                # Step 3: Run the script safely
                self.queue.put("PROGRESS:AutoPilot CSV:Step 3: Running AutoPilot script...")

                result = subprocess.run(
                    ['powershell', '-ExecutionPolicy', 'Bypass', '-File', script_path],
                    capture_output=True,
                    text=True,
                    timeout=300,  # 5 minute timeout
                    creationflags=CREATE_NO_WINDOW  # Hide console window
                )

                if result.stdout.strip():
                    self.queue.put("PROGRESS:AutoPilot CSV:Script output:")
                    for line in result.stdout.strip().split('\n'):
                        if line.strip():
                            self.queue.put(f"PROGRESS:AutoPilot CSV:  {line.strip()}")

                if result.stderr.strip():
                    self.queue.put("PROGRESS:AutoPilot CSV:Script errors:")
                    for line in result.stderr.strip().split('\n'):
                        if line.strip():
                            self.queue.put(f"PROGRESS:AutoPilot CSV:  {line.strip()}")

                # Check if CSV was created
                output_file = os.path.join(powershell_folder, "AutoPilot.csv")
                if os.path.exists(output_file):
                    self.queue.put(f"PROGRESS:AutoPilot CSV:AutoPilot CSV created successfully: {output_file}")

                    # Verify content
                    try:
                        with open(output_file, 'r', encoding='utf-8') as f:
                            content = f.read()
                        if content.strip():
                            self.queue.put("PROGRESS:AutoPilot CSV:CSV file contains data")
                            self.queue.put("PROGRESS:AutoPilot CSV:File size: {len(content)} bytes")
                        else:
                            self.queue.put("PROGRESS:AutoPilot CSV:Warning: CSV file is empty")
                    except Exception as e:
                        self.queue.put(f"PROGRESS:AutoPilot CSV:Error reading CSV: {str(e)}")
                else:
                    self.queue.put("PROGRESS:AutoPilot CSV:Warning: CSV file was not created")

            except subprocess.TimeoutExpired:
                self.queue.put("PROGRESS:AutoPilot CSV:AutoPilot script timed out")
            except Exception as e:
                self.queue.put(f"PROGRESS:AutoPilot CSV:Error running script: {str(e)}")

            self.queue.put("PROGRESS:AutoPilot CSV:AutoPilot CSV creation process completed!")

        except Exception as e:
            self.queue.put(f"PROGRESS:AutoPilot CSV:Error in AutoPilot CSV creation: {str(e)}")

    # ==================== APP SETTINGS METHODS ====================

    def stop_background_apps(self):
        """Stop background applications from running"""
        self.queue.put("PROGRESS:Stop Background Apps:Stopping background apps...")
        try:
            # Safe PowerShell script to disable background apps
            ps_script = '''
            try {
                # Disable background apps globally
                $registryPath = "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\BackgroundAccessApplications"

                # Create registry path if it doesn't exist
                if (-not (Test-Path "HKCU:\\$registryPath")) {
                    New-Item -Path "HKCU:\\$registryPath" -Force | Out-Null
                }

                # Set global disable flag
                Set-ItemProperty -Path "HKCU:\\$registryPath" -Name "GlobalUserDisabled" -Value 1 -Type DWORD -Force

                Write-Host "Background apps disabled successfully"
            } catch {
                Write-Error "Error disabling background apps: $($_.Exception.Message)"
            }
            '''

            self.queue.put("PROGRESS:Stop Background Apps:Executing PowerShell script...")
            result = subprocess.run(
                ['powershell', '-Command', ps_script],
                capture_output=True,
                text=True,
                check=False,
                timeout=60,
                creationflags=CREATE_NO_WINDOW  # Hide console window
            )

            if result.stdout.strip():
                self.queue.put("PROGRESS:Stop Background Apps:Script output:")
                for line in result.stdout.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:Stop Background Apps:  {line.strip()}")

            if result.stderr.strip():
                self.queue.put("PROGRESS:Stop Background Apps:Script errors:")
                for line in result.stderr.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:Stop Background Apps:  {line.strip()}")

        except subprocess.TimeoutExpired:
            self.queue.put("PROGRESS:Stop Background Apps:Background apps operation timed out")
        except Exception as e:
            self.queue.put(f"PROGRESS:Stop Background Apps:Error stopping background apps: {str(e)}")

    def disable_startup_apps(self):
        """Disable startup applications except OneDrive (using StartupApproved registry - does NOT remove entries)"""
        self.queue.put("PROGRESS:Disable Startup Apps:Disabling startup apps (except OneDrive)...")
        try:
            # Fixed PowerShell script that DISABLES instead of REMOVES startup entries
            # Uses the StartupApproved registry which is how Windows Task Manager disables items
            ps_script = '''
            try {
                $disabledCount = 0
                
                # Get startup items from Run key
                $runPath = "HKCU:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run"
                $approvedPath = "HKCU:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\StartupApproved\\Run"
                
                # Ensure StartupApproved\\Run exists
                if (-not (Test-Path $approvedPath)) {
                    New-Item -Path $approvedPath -Force | Out-Null
                }
                
                if (Test-Path $runPath) {
                    $runItems = Get-ItemProperty -Path $runPath
                    
                    foreach ($prop in $runItems.PSObject.Properties) {
                        if ($prop.Name -notlike "PS*" -and $prop.Name -notlike "*OneDrive*") {
                            try {
                                # Create a disabled value (first byte = 03 means disabled)
                                # Format: 03 00 00 00 00 00 00 00 00 00 00 00
                                $disabledValue = [byte[]](0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
                                Set-ItemProperty -Path $approvedPath -Name $prop.Name -Value $disabledValue -Type Binary -Force
                                Write-Host "Disabled startup item: $($prop.Name)"
                                $disabledCount++
                            } catch {
                                Write-Warning "Could not disable: $($prop.Name) - $($_.Exception.Message)"
                            }
                        } elseif ($prop.Name -like "*OneDrive*") {
                            Write-Host "Skipped OneDrive: $($prop.Name)"
                        }
                    }
                }
                
                Write-Host "Startup apps disabled successfully (entries preserved, can be re-enabled)"
                Write-Host "Total disabled items: $disabledCount"
                
            } catch {
                Write-Error "Error disabling startup apps: $($_.Exception.Message)"
            }
            '''

            self.queue.put("PROGRESS:Disable Startup Apps:Executing PowerShell script...")
            result = subprocess.run(
                ['powershell', '-Command', ps_script],
                capture_output=True,
                text=True,
                check=False,
                timeout=60,
                creationflags=CREATE_NO_WINDOW  # Hide console window
            )

            if result.stdout.strip():
                self.queue.put("PROGRESS:Disable Startup Apps:Script output:")
                for line in result.stdout.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:Disable Startup Apps:  {line.strip()}")

            if result.stderr.strip():
                self.queue.put("PROGRESS:Disable Startup Apps:Script errors:")
                for line in result.stderr.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:Disable Startup Apps:  {line.strip()}")

        except subprocess.TimeoutExpired:
            self.queue.put("PROGRESS:Disable Startup Apps:Startup apps operation timed out")
        except Exception as e:
            self.queue.put(f"PROGRESS:Disable Startup Apps:Error disabling startup apps: {str(e)}")

    def run_oo_shutup10(self):
        """Download and run O&O ShutUp10 privacy tool"""
        self.queue.put("PROGRESS:O&O ShutUp10:Starting O&O ShutUp10 download...")
        try:
            import tempfile
            
            # Download using PowerShell to avoid SSL certificate issues
            temp_dir = tempfile.gettempdir()
            exe_path = os.path.join(temp_dir, "OOSU10.exe")
            download_url = "https://dl5.oo-software.com/files/ooshutup10/OOSU10.exe"
            
            self.queue.put("PROGRESS:O&O ShutUp10:Downloading from official O&O Software site...")
            
            # Use PowerShell to download (bypasses Python SSL issues)
            ps_script = f'''
            [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
            $ProgressPreference = 'SilentlyContinue'
            try {{
                Invoke-WebRequest -Uri '{download_url}' -OutFile '{exe_path}' -UseBasicParsing
                Write-Host "Download successful"
            }} catch {{
                Write-Error "Download failed: $($_.Exception.Message)"
                exit 1
            }}
            '''
            
            result = subprocess.run(
                ['powershell', '-Command', ps_script],
                capture_output=True,
                text=True,
                check=False,
                timeout=120,
                creationflags=CREATE_NO_WINDOW
            )
            
            if result.returncode != 0 or not os.path.exists(exe_path):
                self.queue.put(f"PROGRESS:O&O ShutUp10:Download failed: {result.stderr.strip()}")
                return
            
            self.queue.put("PROGRESS:O&O ShutUp10:Download complete. Launching O&O ShutUp10...")
            
            # Run the executable (without CREATE_NO_WINDOW so user can see the GUI)
            subprocess.Popen([exe_path])
            
            self.queue.put("PROGRESS:O&O ShutUp10:O&O ShutUp10 launched successfully!")
            self.queue.put("PROGRESS:O&O ShutUp10:Note: Apply your preferred privacy settings in the O&O ShutUp10 window.")
            
        except Exception as e:
            self.queue.put(f"PROGRESS:O&O ShutUp10:Error running O&O ShutUp10: {str(e)}")


    def apply_edge_performance_adjustments(self):
        """Disable Edge startup boost, background apps, and change search engine to Google"""
        self.queue.put("PROGRESS:Edge Performance:Applying Edge performance adjustments...")
        try:
            ps_script = '''
            try {
                $edgePolicyPath = "HKCU:\\SOFTWARE\\Policies\\Microsoft\\Edge"
                
                # Create Edge policy path if it doesn't exist
                if (-not (Test-Path $edgePolicyPath)) {
                    New-Item -Path $edgePolicyPath -Force | Out-Null
                    Write-Host "Created Edge policy registry path"
                }
                
                # Disable Startup Boost
                Set-ItemProperty -Path $edgePolicyPath -Name "StartupBoostEnabled" -Value 0 -Type DWord -Force
                Write-Host "Disabled Edge Startup Boost"
                
                # Disable Background Mode (continue running background extensions and apps when Edge is closed)
                Set-ItemProperty -Path $edgePolicyPath -Name "BackgroundModeEnabled" -Value 0 -Type DWord -Force
                Write-Host "Disabled Edge Background Mode"
                
                # Try to set Google as default search engine via Edge preferences
                $edgePrefsPath = "$env:LOCALAPPDATA\\Microsoft\\Edge\\User Data\\Default\\Preferences"
                if (Test-Path $edgePrefsPath) {
                    try {
                        $prefs = Get-Content $edgePrefsPath -Raw | ConvertFrom-Json
                        # Note: Changing search engine via preferences is complex due to encryption
                        # Using policy-based approach instead
                        Write-Host "Edge preferences file found"
                    } catch {
                        Write-Host "Could not modify Edge preferences directly"
                    }
                }
                
                # Set default search provider via policy (more reliable)
                Set-ItemProperty -Path $edgePolicyPath -Name "DefaultSearchProviderEnabled" -Value 1 -Type DWord -Force
                Set-ItemProperty -Path $edgePolicyPath -Name "DefaultSearchProviderName" -Value "Google" -Type String -Force
                Set-ItemProperty -Path $edgePolicyPath -Name "DefaultSearchProviderSearchURL" -Value "https://www.google.com/search?q={searchTerms}" -Type String -Force
                Set-ItemProperty -Path $edgePolicyPath -Name "DefaultSearchProviderSuggestURL" -Value "https://www.google.com/complete/search?q={searchTerms}&output=chrome" -Type String -Force
                Write-Host "Set default search engine to Google"
                
                Write-Host "Edge performance adjustments applied successfully!"
                Write-Host "Note: Restart Edge for changes to take effect."
                
            } catch {
                Write-Error "Error applying Edge adjustments: $($_.Exception.Message)"
            }
            '''

            self.queue.put("PROGRESS:Edge Performance:Executing Edge optimization script...")
            result = subprocess.run(
                ['powershell', '-Command', ps_script],
                capture_output=True,
                text=True,
                check=False,
                timeout=60,
                creationflags=CREATE_NO_WINDOW
            )

            if result.stdout.strip():
                self.queue.put("PROGRESS:Edge Performance:Script output:")
                for line in result.stdout.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:Edge Performance:  {line.strip()}")

            if result.stderr.strip():
                self.queue.put("PROGRESS:Edge Performance:Script errors:")
                for line in result.stderr.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:Edge Performance:  {line.strip()}")

        except subprocess.TimeoutExpired:
            self.queue.put("PROGRESS:Edge Performance:Edge adjustments operation timed out")
        except Exception as e:
            self.queue.put(f"PROGRESS:Edge Performance:Error applying Edge adjustments: {str(e)}")

    def disable_all_gaming_features(self):
        """Turn off all Windows gaming features: Game Bar, Game DVR, Game Mode, and captures"""
        self.queue.put("PROGRESS:Gaming Features:Disabling all Windows gaming features...")
        try:
            ps_script = '''
            try {
                Write-Host "=== Disabling Windows Gaming Features ==="
                
                # Disable Game Bar
                Write-Host "Disabling Game Bar..."
                $gamingPath = "HKCU:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\GameDVR"
                if (-not (Test-Path $gamingPath)) { New-Item -Path $gamingPath -Force | Out-Null }
                Set-ItemProperty -Path $gamingPath -Name "AppCaptureEnabled" -Value 0 -Type DWord -Force
                Write-Host "  - Game Bar capture disabled"
                
                $gameBarPath = "HKCU:\\Software\\Microsoft\\GameBar"
                if (-not (Test-Path $gameBarPath)) { New-Item -Path $gameBarPath -Force | Out-Null }
                Set-ItemProperty -Path $gameBarPath -Name "UseNexusForGameBarEnabled" -Value 0 -Type DWord -Force
                Set-ItemProperty -Path $gameBarPath -Name "AutoGameModeEnabled" -Value 0 -Type DWord -Force
                Write-Host "  - Game Bar overlay disabled"
                
                # Disable Game DVR
                Write-Host "Disabling Game DVR..."
                $gameDVRPolicy = "HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\GameDVR"
                if (-not (Test-Path $gameDVRPolicy)) { New-Item -Path $gameDVRPolicy -Force | Out-Null }
                Set-ItemProperty -Path $gameDVRPolicy -Name "AllowGameDVR" -Value 0 -Type DWord -Force
                Write-Host "  - Game DVR recording disabled"
                
                # Disable Game Mode
                Write-Host "Disabling Game Mode..."
                $gameModePath = "HKCU:\\Software\\Microsoft\\GameBar"
                Set-ItemProperty -Path $gameModePath -Name "AllowAutoGameMode" -Value 0 -Type DWord -Force
                Write-Host "  - Auto Game Mode disabled"
                
                $gameConfigPath = "HKCU:\\System\\GameConfigStore"
                if (-not (Test-Path $gameConfigPath)) { New-Item -Path $gameConfigPath -Force | Out-Null }
                Set-ItemProperty -Path $gameConfigPath -Name "GameDVR_Enabled" -Value 0 -Type DWord -Force
                Set-ItemProperty -Path $gameConfigPath -Name "GameDVR_FSEBehaviorMode" -Value 2 -Type DWord -Force
                Set-ItemProperty -Path $gameConfigPath -Name "GameDVR_HonorUserFSEBehaviorMode" -Value 1 -Type DWord -Force
                Set-ItemProperty -Path $gameConfigPath -Name "GameDVR_DXGIHonorFSEWindowsCompatible" -Value 1 -Type DWord -Force
                Set-ItemProperty -Path $gameConfigPath -Name "GameDVR_EFSEFeatureFlags" -Value 0 -Type DWord -Force
                Write-Host "  - Game optimizations disabled"
                
                # Disable Game Capture features
                Write-Host "Disabling Game Capture..."
                Set-ItemProperty -Path $gamingPath -Name "HistoricalCaptureEnabled" -Value 0 -Type DWord -Force
                Write-Host "  - Background recording disabled"
                
                # Disable "Use Game Bar for supported controllers" (Guide button)
                Write-Host "Disabling Game Bar controller guide button..."
                Set-ItemProperty -Path $gameBarPath -Name "ShowStartupPanel" -Value 0 -Type DWord -Force
                Set-ItemProperty -Path $gameBarPath -Name "GamePanelStartupTipIndex" -Value 3 -Type DWord -Force
                Write-Host "  - Game Bar guide button disabled"
                
                # Disable optimizations for windowed games
                Write-Host "Disabling optimizations for windowed games..."
                Set-ItemProperty -Path $gameConfigPath -Name "GameDVR_DSEBehavior" -Value 2 -Type DWord -Force
                $graphicsPath = "HKCU:\\Software\\Microsoft\\DirectX\\UserGpuPreferences"
                if (-not (Test-Path $graphicsPath)) { New-Item -Path $graphicsPath -Force | Out-Null }
                # Disable Hardware-accelerated GPU scheduling effect on windowed games
                $fullscreenOptPath = "HKCU:\\System\\GameConfigStore"
                Set-ItemProperty -Path $fullscreenOptPath -Name "GameDVR_FSEBehavior" -Value 2 -Type DWord -Force
                Write-Host "  - Windowed games optimizations disabled"
                
                # Disable Xbox Game Monitoring
                Write-Host "Disabling Xbox Game Monitoring..."
                $xboxPath = "HKLM:\\SYSTEM\\CurrentControlSet\\Services\\xbgm"
                if (Test-Path $xboxPath) {
                    Set-ItemProperty -Path $xboxPath -Name "Start" -Value 4 -Type DWord -Force
                    Write-Host "  - Xbox Game Monitoring service disabled"
                }
                
                Write-Host ""
                Write-Host "=== All gaming features have been disabled! ==="
                Write-Host "Disabled: Game Bar, Game DVR, Game Mode, Background Recording,"
                Write-Host "          Controller Guide Button, Windowed Games Optimizations"
                Write-Host "Note: Some changes may require a restart to take effect."
                
            } catch {
                Write-Error "Error disabling gaming features: $($_.Exception.Message)"
            }
            '''

            self.queue.put("PROGRESS:Gaming Features:Executing gaming features disable script...")
            result = subprocess.run(
                ['powershell', '-Command', ps_script],
                capture_output=True,
                text=True,
                check=False,
                timeout=60,
                creationflags=CREATE_NO_WINDOW
            )

            if result.stdout.strip():
                self.queue.put("PROGRESS:Gaming Features:Script output:")
                for line in result.stdout.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:Gaming Features:  {line.strip()}")

            if result.stderr.strip():
                self.queue.put("PROGRESS:Gaming Features:Script errors:")
                for line in result.stderr.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:Gaming Features:  {line.strip()}")

        except subprocess.TimeoutExpired:
            self.queue.put("PROGRESS:Gaming Features:Operation timed out")
        except Exception as e:
            self.queue.put(f"PROGRESS:Gaming Features:Error disabling gaming features: {str(e)}")

    def optimize_virtual_memory(self):
        """Set virtual memory (page file) to optimal size based on installed RAM"""
        self.queue.put("PROGRESS:Virtual Memory:Analyzing system RAM and optimizing virtual memory...")
        try:
            ps_script = '''
            try {
                # Get system RAM
                $computerInfo = Get-CimInstance -ClassName Win32_ComputerSystem
                $ramBytes = $computerInfo.TotalPhysicalMemory
                $ramGB = [math]::Round($ramBytes / 1GB, 2)
                $ramMB = [math]::Round($ramBytes / 1MB)
                
                Write-Host "=== System Memory Analysis ==="
                Write-Host "Installed RAM: $ramGB GB ($ramMB MB)"
                
                # Calculate optimal page file size (Initial = RAM, Maximum = 2x RAM)
                $initialSizeMB = $ramMB
                $maxSizeMB = $ramMB * 2
                
                # Cap at reasonable values (max 32GB for page file)
                if ($maxSizeMB -gt 32768) { $maxSizeMB = 32768 }
                if ($initialSizeMB -gt 16384) { $initialSizeMB = 16384 }
                
                Write-Host ""
                Write-Host "=== Recommended Virtual Memory Settings ==="
                Write-Host "Initial Size: $initialSizeMB MB"
                Write-Host "Maximum Size: $maxSizeMB MB"
                Write-Host "(Formula: Initial = RAM, Maximum = 2x RAM, capped at 32GB)"
                
                # Get current page file info
                Write-Host ""
                Write-Host "=== Current Configuration ==="
                $currentPF = Get-CimInstance -ClassName Win32_PageFileUsage -ErrorAction SilentlyContinue
                if ($currentPF) {
                    Write-Host "Current page file: $($currentPF.Name)"
                    Write-Host "Current size: $($currentPF.AllocatedBaseSize) MB"
                } else {
                    Write-Host "No page file currently active or system managed"
                }
                
                Write-Host ""
                Write-Host "=== Applying Custom Settings ==="
                
                # Step 1: Disable automatic management
                $cs = Get-WmiObject -Class Win32_ComputerSystem -EnableAllPrivileges
                if ($cs.AutomaticManagedPagefile -eq $true) {
                    $cs.AutomaticManagedPagefile = $false
                    $oldErr = $ErrorActionPreference
                    $ErrorActionPreference = 'Stop'
                    try {
                        $cs.Put() | Out-Null
                        Write-Host "Disabled automatic page file management"
                    } catch {
                        Write-Host "Note: Could not disable automatic management (may need restart first)"
                    }
                    $ErrorActionPreference = $oldErr
                } else {
                    Write-Host "Automatic management already disabled"
                }
                
                # Step 2: Set custom page file via registry (most reliable method)
                $regPath = "HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management"
                
                # Format: "C:\\pagefile.sys InitialSize MaxSize"
                $pageFileValue = "C:\\pagefile.sys $initialSizeMB $maxSizeMB"
                
                Set-ItemProperty -Path $regPath -Name "PagingFiles" -Value @($pageFileValue) -Type MultiString -Force
                Write-Host "Set registry: PagingFiles = $pageFileValue"
                
                # Verify the setting
                $verifyPF = (Get-ItemProperty -Path $regPath -Name "PagingFiles").PagingFiles
                Write-Host "Verified registry value: $verifyPF"
                
                Write-Host ""
                Write-Host "=== Virtual Memory Optimization Complete! ==="
                Write-Host "Custom page file configured:"
                Write-Host "  Drive: C:\\"
                Write-Host "  Initial Size: $initialSizeMB MB"
                Write-Host "  Maximum Size: $maxSizeMB MB"
                Write-Host ""
                Write-Host "IMPORTANT: Restart your computer for changes to take effect!"
                
            } catch {
                Write-Error "Error optimizing virtual memory: $($_.Exception.Message)"
            }
            '''


            self.queue.put("PROGRESS:Virtual Memory:Executing virtual memory optimization script...")
            result = subprocess.run(
                ['powershell', '-Command', ps_script],
                capture_output=True,
                text=True,
                check=False,
                timeout=60,
                creationflags=CREATE_NO_WINDOW
            )

            if result.stdout.strip():
                self.queue.put("PROGRESS:Virtual Memory:Script output:")
                for line in result.stdout.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:Virtual Memory:  {line.strip()}")

            if result.stderr.strip():
                self.queue.put("PROGRESS:Virtual Memory:Script errors:")
                for line in result.stderr.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:Virtual Memory:  {line.strip()}")

        except subprocess.TimeoutExpired:
            self.queue.put("PROGRESS:Virtual Memory:Operation timed out")
        except Exception as e:
            self.queue.put(f"PROGRESS:Virtual Memory:Error optimizing virtual memory: {str(e)}")

    def update_installed_apps(self):

        """Update installed applications using Windows Package Manager (winget)"""
        self.queue.put("PROGRESS:Update Apps:Starting application update process...")
        try:
            # Check if winget is available
            self.queue.put("PROGRESS:Update Apps:Checking for Windows Package Manager (winget)...")
            try:
                subprocess.run(['winget', '--version'], capture_output=True, check=True, timeout=10,
                               creationflags=CREATE_NO_WINDOW)
                self.queue.put("PROGRESS:Update Apps:Windows Package Manager found")
            except (subprocess.CalledProcessError, FileNotFoundError, subprocess.TimeoutExpired):
                self.queue.put("PROGRESS:Update Apps:Error: Windows Package Manager (winget) not found.")
                self.queue.put("PROGRESS:Update Apps:Please install winget from the Microsoft Store.")
                return

            # First, get list of available updates
            self.queue.put("PROGRESS:Update Apps:Checking for available updates...")
            list_command = ['winget', 'upgrade', '--list']
            result = subprocess.run(
                list_command,
                capture_output=True,
                text=True,
                check=False,
                timeout=60,
                creationflags=CREATE_NO_WINDOW
            )

            updates = []
            if result.returncode == 0:
                lines = result.stdout.strip().split('\n')
                for line in lines:
                    if line.strip() and not line.startswith('-') and not line.startswith('Name'):
                        # Extract app name from the line
                        parts = line.split()
                        if len(parts) >= 2:
                            app_name = parts[0]
                            updates.append(app_name)

                if updates:
                    self.queue.put(f"PROGRESS:Update Apps:Found {len(updates)} updates:")
                    for app in updates:
                        self.queue.put(f"PROGRESS:Update Apps:  - {app}")
                else:
                    self.queue.put("PROGRESS:Update Apps:No updates found.")
                    return
            else:
                self.queue.put("PROGRESS:Update Apps:Could not list updates. Proceeding with upgrade all.")

            # Now run the upgrade command with real-time output
            self.queue.put("PROGRESS:Update Apps:Starting upgrade process...")
            safe_args = ['winget', 'upgrade', '--all', '--silent',
                         '--accept-package-agreements', '--accept-source-agreements']

            # Run the command and capture output in real-time
            process = subprocess.Popen(
                safe_args,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                creationflags=CREATE_NO_WINDOW  # Hide console window
            )

            # Read the output in real-time
            while True:
                output = process.stdout.readline()
                if output == '' and process.poll() is not None:
                    break
                if output:
                    self.queue.put(f"PROGRESS:Update Apps:{output.strip()}")

            # Check for any errors
            stderr = process.stderr.read()
            if stderr:
                self.queue.put(f"PROGRESS:Update Apps:Errors:")
                for line in stderr.strip().split('\n'):
                    if line.strip():
                        self.queue.put(f"PROGRESS:Update Apps:  {line.strip()}")

            if process.returncode == 0:
                self.queue.put("PROGRESS:Update Apps:App updates completed successfully")
            else:
                self.queue.put(f"PROGRESS:Update Apps:App updates completed with return code: {process.returncode}")

        except subprocess.TimeoutExpired:
            self.queue.put("PROGRESS:Update Apps:App update process timed out after 30 minutes")
        except Exception as e:
            self.queue.put(f"PROGRESS:Update Apps:Error updating apps: {str(e)}")

    # ==================== UTILITY METHODS ====================

    def prompt_reboot_for_updates(self):
        """Prompt user to reboot now to complete Windows updates"""
        response = messagebox.askyesno(
            "Updates Installed",
            "Windows updates have been installed successfully.\n\n"
            "A system reboot is required to complete the installation.\n\n"
            "Would you like to reboot now?"
        )

        if response:
            self.queue.put("PROGRESS:Windows Updates:User initiated system reboot for updates...")
            try:
                # Reboot the system
                subprocess.run(['shutdown', '/r', '/t', '30'], check=True, timeout=10, creationflags=CREATE_NO_WINDOW)
                self.queue.put("PROGRESS:Windows Updates:System will reboot in 30 seconds...")
                self.queue.put("PROGRESS:Windows Updates:Please save all work and close applications.")

                # Show countdown dialog
                messagebox.showinfo(
                    "Reboot Initiated",
                    "System will reboot in 30 seconds.\n\n"
                    "To cancel the reboot, run 'shutdown /a' in command prompt."
                )
            except Exception as e:
                self.queue.put(f"PROGRESS:Windows Updates:Error initiating reboot: {str(e)}")
        else:
            self.queue.put("PROGRESS:Windows Updates:User chose not to reboot now.")
            self.queue.put("PROGRESS:Windows Updates:Updates will be applied on the next manual reboot.")

    def prompt_reboot(self):
        """Prompt user to reboot now to run CHKDSK"""
        response = messagebox.askyesno(
            "CHKDSK Scheduled",
            "CHKDSK has been scheduled to run on the next reboot.\n\n"
            "Would you like to reboot now to start the disk check?\n\n"
            "WARNING: The reboot process may take a long time as CHKDSK runs.\n"
            "Make sure to save all your work before proceeding."
        )

        if response:
            self.queue.put("PROGRESS:CHKDSK:User initiated system reboot...")
            try:
                # Reboot the system with confirmation
                subprocess.run(['shutdown', '/r', '/t', '30'], check=True, timeout=10, creationflags=CREATE_NO_WINDOW)
                self.queue.put("PROGRESS:CHKDSK:System will reboot in 30 seconds...")
                self.queue.put("PROGRESS:CHKDSK:Please save all work and close applications.")

                # Show countdown dialog
                messagebox.showinfo(
                    "Reboot Initiated",
                    "System will reboot in 30 seconds.\n\n"
                    "To cancel the reboot, run 'shutdown /a' in command prompt."
                )
            except Exception as e:
                self.queue.put(f"PROGRESS:CHKDSK:Error initiating reboot: {str(e)}")
        else:
            self.queue.put("PROGRESS:CHKDSK:User chose not to reboot now.")
            self.queue.put("PROGRESS:CHKDSK:CHKDSK will run on the next manual reboot.")

    def open_install_apps_window(self):
        """Open a professional dialog to search and install apps from the winutil database"""
        # Diagnostic: Check database status
        try:
            db_size = len(INSTALLABLE_APPS)
            categories = get_categories()
            print(f"DEBUG: App Installer database size: {db_size}")
            print(f"DEBUG: Categories found: {len(categories)}")
        except Exception as e:
            print(f"DEBUG: Error accessing app database: {str(e)}")
            messagebox.showerror("Database Error",
                                 "Could not access the application internal database. Please report this error.")
            return

        installer_win = tk.Toplevel(self.root)
        installer_win.title("Windows System Cleaner - App Installer")
        installer_win.geometry("1100x820")
        installer_win.configure(bg=self.theme['bg'])
        installer_win.transient(self.root)
        installer_win.grab_set()

        # Center the window
        installer_win.update_idletasks()
        width = installer_win.winfo_width()
        height = installer_win.winfo_height()
        x = (installer_win.winfo_screenwidth() // 2) - (width // 2)
        y = (installer_win.winfo_screenheight() // 2) - (height // 2)
        installer_win.geometry('{}x{}+{}+{}'.format(width, height, x, y))

        # Main Header
        header_frame = tk.Frame(installer_win, bg=self.theme['primary'], height=70)
        header_frame.pack(fill=tk.X)
        header_frame.pack_propagate(False)

        header_label = tk.Label(
            header_frame,
            text="  WINDOWS SYSTEM CLEANER - APP INSTALLER ",
            font=('Segoe UI', 18, 'bold'),
            bg=self.theme['primary'],
            fg=self.theme['button_fg']
        )
        header_label.pack(side=tk.LEFT, padx=30, pady=15)

        # Search and Selection Summary Frame
        top_bar = tk.Frame(installer_win, bg=self.theme['surface'], height=60)
        top_bar.pack(fill=tk.X, padx=20, pady=15)

        search_label = tk.Label(top_bar, text="Search Apps:", font=('Segoe UI', 10), bg=self.theme['surface'],
                                fg=self.theme['label_fg'])
        search_label.pack(side=tk.LEFT, padx=(10, 5))

        search_var = tk.StringVar()
        search_entry = tk.Entry(
            top_bar,
            textvariable=search_var,
            font=('Segoe UI', 11),
            bg=self.theme['entry_bg'],
            fg=self.theme['entry_fg'],
            insertbackground=self.theme['primary'],
            bd=0,
            highlightthickness=1,
            highlightbackground=self.theme['surface_alt']
        )
        search_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=10, pady=10)
        search_entry.focus_set()

        selection_label = tk.Label(top_bar, text="Apps: 0/0", font=('Segoe UI', 10, 'bold'),
                                   bg=self.theme['surface'], fg=self.theme['primary'])
        selection_label.pack(side=tk.RIGHT, padx=20)

        diagnostic_label = tk.Label(top_bar, text="Status: Ready", font=('Segoe UI', 9),
                                    bg=self.theme['surface'], fg=self.theme['label_fg_dim'])
        diagnostic_label.pack(side=tk.RIGHT, padx=10)

        # Content Area with Sidebar and App Grid
        content_frame = tk.Frame(installer_win, bg=self.theme['bg'])
        content_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=(0, 20))

        # Sidebar for Categories
        sidebar = tk.Frame(content_frame, bg=self.theme['surface'], width=220)
        sidebar.pack(side=tk.LEFT, fill=tk.Y, padx=(0, 15))
        sidebar.pack_propagate(False)

        sidebar_header = tk.Label(sidebar, text="CATEGORIES", font=('Segoe UI', 9, 'bold'), bg=self.theme['surface'],
                                  fg=self.theme['label_fg_dim'], pady=10)
        sidebar_header.pack(fill=tk.X)

        # Scroll wheel scroll handling to prevent background bleed
        def _on_mousewheel(event, canvas):
            canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")
            return "break"

        def bind_scroll(widget, canvas):
            widget.bind("<MouseWheel>", lambda e: _on_mousewheel(e, canvas))

        # Scrollable categories list
        cat_canvas = tk.Canvas(sidebar, bg=self.theme['surface'], highlightthickness=0)
        cat_scrollbar = ttk.Scrollbar(sidebar, orient="vertical", command=cat_canvas.yview)
        cat_scrollable_frame = tk.Frame(cat_canvas, bg=self.theme['surface'])

        cat_scrollable_frame.bind(
            "<Configure>",
            lambda e: cat_canvas.configure(scrollregion=cat_canvas.bbox("all"))
        )

        cat_canvas.create_window((0, 0), window=cat_scrollable_frame, anchor="nw", width=220)
        cat_canvas.configure(yscrollcommand=cat_scrollbar.set)
        
        # Bind sidebar to scroll
        cat_canvas.bind("<MouseWheel>", lambda e: _on_mousewheel(e, cat_canvas))
        cat_scrollable_frame.bind("<MouseWheel>", lambda e: _on_mousewheel(e, cat_canvas))

        cat_canvas.pack(side="left", fill="both", expand=True)
        cat_scrollbar.pack(side="right", fill="y")

        # Main Apps Grid Area (Scrollable)
        apps_container = tk.Frame(content_frame, bg=self.theme['surface'], bd=0)
        apps_container.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True)

        app_canvas = tk.Canvas(apps_container, bg=self.theme['surface'], highlightthickness=0)
        app_scrollbar = ttk.Scrollbar(apps_container, orient="vertical", command=app_canvas.yview)
        app_grid_frame = tk.Frame(app_canvas, bg=self.theme['surface'])

        app_canvas.bind("<MouseWheel>", lambda e: _on_mousewheel(e, app_canvas))
        app_grid_frame.bind("<MouseWheel>", lambda e: _on_mousewheel(e, app_canvas))

        app_grid_frame.bind(
            "<Configure>",
            lambda e: app_canvas.configure(scrollregion=app_canvas.bbox("all"))
        )

        # Ensure the grid frame stays as wide as the canvas
        def sync_width(event):
            app_canvas.itemconfig(grid_window, width=event.width)

        grid_window = app_canvas.create_window((0, 0), window=app_grid_frame, anchor="nw")
        app_canvas.bind("<Configure>", sync_width)
        app_canvas.configure(yscrollcommand=app_scrollbar.set)

        app_canvas.pack(side="left", fill="both", expand=True)
        app_scrollbar.pack(side="right", fill="y")

        # Variables for app selection
        app_vars = {}
        app_widgets = {}

        def update_selection_count(*args):
            count = sum(1 for var in app_vars.values() if var.get())
            diagnostic_label.config(text=f"Selected: {count} | Total: {len(INSTALLABLE_APPS)}")
            if count > 0:
                install_btn.config(state=tk.NORMAL, bg=self.theme['primary'], fg=self.theme['button_fg'])
            else:
                install_btn.config(state=tk.DISABLED, bg=self.theme['surface_alt'], fg=self.theme['label_fg_dim'])

        def apply_filter(*args):
            query = search_var.get().lower()
            current_cat = active_cat_var.get()

            # Hide all widgets first
            for widget in app_widgets.values():
                widget.grid_forget()

            row = 0
            col = 0
            cols = 3  # Fixed columns for the grid

            visible_count = 0
            for app_name, app_data in INSTALLABLE_APPS.items():
                match_query = query in app_name.lower() or query in app_data['description'].lower()
                match_cat = current_cat == "All Apps" or app_data['category'] == current_cat

                if match_query and match_cat:
                    if app_name in app_widgets:
                        widget = app_widgets[app_name]
                        widget.grid(row=row, column=col, padx=10, pady=10, sticky="nsew")
                        col += 1
                        if col >= cols:
                            col = 0
                            row += 1
                        visible_count += 1

            # Configure grid weights for uniform spacing
            for i in range(cols):
                app_grid_frame.grid_columnconfigure(i, weight=1)

            # Force update and scrollregion sync
            selection_label.config(text=f"Visible: {visible_count}/{len(INSTALLABLE_APPS)}")
            app_grid_frame.update_idletasks()
            app_canvas.config(scrollregion=app_canvas.bbox("all"))
            print(f"DEBUG: Apps visible after filter: {visible_count}")

        # Initialize App Cards
        creation_errors = 0
        for app_name, app_data in INSTALLABLE_APPS.items():
            try:
                var = tk.BooleanVar()
                app_vars[app_name] = var
                var.trace_add("write", update_selection_count)

                # App Card Frame
                card = tk.Frame(app_grid_frame, bg=self.theme['surface'], bd=1, relief=tk.RIDGE, highlightthickness=1,
                                highlightbackground=self.theme['surface_alt'])

                # Checkbox + Title
                cb = tk.Checkbutton(
                    card,
                    text=app_name,
                    variable=var,
                    font=('Segoe UI', 10, 'bold'),
                    bg=self.theme['surface'],
                    fg=self.theme['task_fg'],
                    selectcolor=self.theme['surface'],
                    activebackground=self.theme['surface_alt'],
                    activeforeground=self.theme['primary'],
                    anchor=tk.W,
                    bd=0
                )
                cb.pack(fill=tk.X, padx=10, pady=(10, 0))

                # Description
                desc = tk.Label(
                    card,
                    text=app_data['description'],
                    font=('Segoe UI', 8),
                    bg=self.theme['surface'],
                    fg=self.theme['label_fg_dim'],
                    wraplength=250,
                    justify=tk.LEFT,
                    anchor=tk.NW,
                    height=2
                )
                desc.pack(fill=tk.BOTH, expand=True, padx=12, pady=(2, 12))

                app_widgets[app_name] = card

                # Helper to toggle app when card is clicked
                def make_toggle_handler(v):
                    return lambda e: v.set(not v.get())

                toggle_handler = make_toggle_handler(var)
                card.bind("<Button-1>", toggle_handler)
                desc.bind("<Button-1>", toggle_handler)
                # Note: cb (Checkbutton) handles its own click

                # Bind card and children to scroll to prevent background bleed
                bind_scroll(card, app_canvas)
                bind_scroll(cb, app_canvas)
                bind_scroll(desc, app_canvas)
            except Exception as e:
                print(f"DEBUG: Failed to create card for {app_name}: {str(e)}")
                creation_errors += 1

        if creation_errors > 0:
            diagnostic_label.config(text=f"Errors: {creation_errors} cards failed", fg="#FF0000")

        # Category logic
        active_cat_var = tk.StringVar(value="All Apps")
        category_buttons = {}

        def select_category(cat_name):
            active_cat_var.set(cat_name)
            for name, btn in category_buttons.items():
                if name == cat_name:
                    btn.config(bg=self.theme['primary'], fg=self.theme['button_fg'])
                else:
                    btn.config(bg=self.theme['surface'], fg=self.theme['label_fg'])
            apply_filter()

        # Add "All Apps" category
        all_btn = tk.Button(
            cat_scrollable_frame,
            text=f"All Apps ({len(INSTALLABLE_APPS)})",
            command=lambda: select_category("All Apps"),
            font=('Segoe UI', 9, 'bold'),
            bg=self.theme['primary'],
            fg=self.theme['button_fg'],
            bd=0,
            padx=15,
            pady=10,
            anchor=tk.W,
            cursor="hand2"
        )
        all_btn.pack(fill=tk.X)
        category_buttons["All Apps"] = all_btn

        # Add other categories
        cat_names = get_categories()
        cat_counts = {}
        for app in INSTALLABLE_APPS.values():
            cat = app['category']
            cat_counts[cat] = cat_counts.get(cat, 0) + 1

        for cat in cat_names:
            btn = tk.Button(
                cat_scrollable_frame,
                text=f"{cat} ({cat_counts[cat]})",
                command=lambda c=cat: select_category(c),
                font=('Segoe UI', 9),
                bg=self.theme['surface'],
                fg=self.theme['label_fg'],
                bd=0,
                padx=15,
                pady=10,
                anchor=tk.W,
                cursor="hand2"
            )
            btn.pack(fill=tk.X)
            category_buttons[cat] = btn

        # Bottom Action Bar
        action_bar = tk.Frame(installer_win, bg=self.theme['bg'], height=100)
        action_bar.pack(fill=tk.X, side=tk.BOTTOM, padx=20, pady=20)

        def start_installation():
            selected_apps = [name for name, var in app_vars.items() if var.get()]
            if not selected_apps:
                return

            if messagebox.askyesno("Confirm Installation",
                                   f"Are you sure you want to install {len(selected_apps)} application(s)?\n\nThis will use Winget to download and install the software."):
                installer_win.destroy()
                # Run in background via existing task system
                threading.Thread(target=self.install_selected_apps, args=(selected_apps,), daemon=True).start()

        install_btn = tk.Button(
            action_bar,
            text=" START BATCH INSTALLATION ",
            font=('Segoe UI', 12, 'bold'),
            command=start_installation,
            bg=self.theme['surface_alt'],
            fg=self.theme['label_fg_dim'],
            state=tk.DISABLED,
            bd=0,
            padx=40,
            pady=15,
            cursor="hand2"
        )
        install_btn.pack(side=tk.RIGHT)

        close_btn = tk.Button(
            action_bar,
            text=" CANCEL ",
            font=('Segoe UI', 12),
            command=installer_win.destroy,
            bg=self.theme['button_secondary_bg'],
            fg=self.theme['button_secondary_fg'],
            bd=0,
            padx=40,
            pady=15,
            cursor="hand2"
        )
        close_btn.pack(side=tk.RIGHT, padx=15)

        # Connect search var to filter
        search_var.trace_add("write", apply_filter)

        # Initial display
        apply_filter()

    def install_selected_apps(self, app_list):
        """Worker method to install apps via Winget"""
        self.show_progress(True)
        self.queue.put(f"TASK_START:app_installer:App Installer")
        self.queue.put(f"PROGRESS:app_installer:Starting installation of {len(app_list)} apps...")
        
        success_count = 0
        fail_count = 0
        
        for i, app_name in enumerate(app_list):
            if app_name not in INSTALLABLE_APPS:
                continue
                
            winget_id = INSTALLABLE_APPS[app_name]['winget']
            self.queue.put(f"PROGRESS:app_installer:({i+1}/{len(app_list)}) Installing {app_name} [{winget_id}]...")
            
            try:
                # Use winget install --silent --accept-package-agreements --accept-source-agreements
                cmd = [
                    'winget', 'install', '--id', winget_id, 
                    '--silent', '--accept-package-agreements', '--accept-source-agreements'
                ]
                
                result = subprocess.run(
                    cmd, 
                    capture_output=True, 
                    text=True, 
                    check=False,
                    creationflags=CREATE_NO_WINDOW
                )
                
                if result.returncode == 0:
                    self.queue.put(f"PROGRESS:app_installer:Successfully installed {app_name}")
                    success_count += 1
                else:
                    # Check for "already installed" error codes
                    if "already installed" in result.stdout.lower() or result.returncode == 0x8A150030:
                        self.queue.put(f"PROGRESS:app_installer:{app_name} is already installed. Skipping.")
                        success_count += 1
                    else:
                        self.queue.put(f"PROGRESS:app_installer:Failed to install {app_name}. Error code: {result.returncode}")
                        fail_count += 1
                        
            except Exception as e:
                self.queue.put(f"PROGRESS:app_installer:Error installing {app_name}: {str(e)}")
                fail_count += 1
        
        self.queue.put(f"PROGRESS:app_installer:Batch installation complete. Success: {success_count}, Failed: {fail_count}")
        self.queue.put("TASK_END:app_installer")
        self.queue.put("TASKS_COMPLETE")

def parse_args():

    """Parse command line arguments"""
    parser = argparse.ArgumentParser(description="Windows System Cleaner")
    parser.add_argument("--clean-temp", type=int, choices=[0, 1], default=0,
                        help="Enable/disable cleaning temporary files (1/0)")
    parser.add_argument("--disk-cleanup", type=int, choices=[0, 1], default=0,
                        help="Enable/disable disk cleanup (1/0)")
    parser.add_argument("--disable-fast-startup", type=int, choices=[0, 1], default=0,
                        help="Enable/disable disabling fast startup (1/0)")
    parser.add_argument("--update-apps", type=int, choices=[0, 1], default=0,
                        help="Enable/disable updating apps (1/0)")
    parser.add_argument("--windows-updates", type=int, choices=[0, 1], default=0,
                        help="Enable/disable Windows updates (1/0)")
    parser.add_argument("--device-firmware", type=int, choices=[0, 1], default=0,
                        help="Enable/disable device firmware updates (1/0)")
    parser.add_argument("--repair-system", type=int, choices=[0, 1], default=0,
                        help="Enable/disable system repair (1/0)")
    parser.add_argument("--chk-dsk", type=int, choices=[0, 1], default=0,
                        help="Enable/disable chkdsk C: /r (1/0)")
    parser.add_argument("--windows-adjustments", type=int, choices=[0, 1], default=0,
                        help="Enable/disable Windows adjustments (1/0)")
    parser.add_argument("--flush-dns", type=int, choices=[0, 1], default=0,
                        help="Enable/disable flush DNS and renew IP (1/0)")
    parser.add_argument("--ipconfig-all", type=int, choices=[0, 1], default=0,
                        help="Enable/disable display IP configuration (1/0)")
    parser.add_argument("--change-dns", type=int, choices=[0, 1], default=0,
                        help="Enable/disable change DNS to 1.1.1.1 and 8.8.8.8 (1/0)")
    parser.add_argument("--autopilot-csv", type=int, choices=[0, 1], default=0,
                        help="Enable/disable AutoPilot CSV creation (1/0)")
    parser.add_argument("--pc-report", type=int, choices=[0, 1], default=0,
                        help="Enable/disable PC Report generation (1/0)")
    parser.add_argument("--chris-titus-utility", type=int, choices=[0, 1], default=0,
                        help="Enable/disable Chris Titus Windows Utility (1/0)")
    parser.add_argument("--stop-background-apps", type=int, choices=[0, 1], default=0,
                        help="Enable/disable stopping background apps (1/0)")
    parser.add_argument("--disable-startup-apps", type=int, choices=[0, 1], default=0,
                        help="Enable/disable disabling startup apps except OneDrive (1/0)")
    return parser.parse_args()


def is_frozen():
    """Check if the application is running as a frozen executable"""
    return getattr(sys, 'frozen', False)


def restart_as_admin():
    """Restart the application with administrator privileges"""
    try:
        # Get the path to the current executable
        executable = sys.executable

        # Build command line arguments
        if is_frozen():
            # Running as a frozen executable
            args = sys.argv[1:]  # Skip the first argument (the executable path)
        else:
            # Running as a script
            args = [os.path.abspath(sys.argv[0])]  # The script path
            if len(sys.argv) > 1:
                args.extend(sys.argv[1:])

        # Sanitize arguments
        safe_args = SecurityUtils.sanitize_command_args(args)

        # Start new process with admin rights
        # Using ShellExecuteW with runas verb to trigger UAC
        result = ctypes.windll.shell32.ShellExecuteW(
            None,  # hwnd
            "runas",  # verb
            executable,  # file to execute
            " ".join(safe_args),  # parameters
            None,  # current directory
            1  # show command (SW_SHOWNORMAL)
        )

        # Check if ShellExecuteW succeeded (returns >32 on success)
        if result <= 32:
            messagebox.showerror("Error", f"Failed to restart as administrator. Error code: {result}")
            return False

        # Exit the current instance
        sys.exit(0)
    except Exception as e:
        messagebox.showerror("Error", f"Failed to restart as administrator: {str(e)}")
        return False


def main():
    try:
        startup_log("Main function started")

        # Check if we're in a relaunch process
        if '--relaunched' in sys.argv:
            startup_log("Application relaunched with pythonw.exe")

        # Check if running as admin, if not restart
        if not ctypes.windll.shell32.IsUserAnAdmin():
            startup_log("Not running as admin, restarting with admin privileges")
            if not restart_as_admin():
                startup_log("Failed to restart as admin, continuing without admin rights")
                # Continue without admin rights but warn user
                messagebox.showwarning(
                    "Administrator Rights Required",
                    "This application requires administrator privileges to function properly.\n"
                    "Some features may not work correctly.\n\n"
                    "Please restart the application as administrator."
                )

        startup_log("Running with admin privileges")

        # Parse command line arguments
        args = parse_args()

        # Load theme preference if it exists
        theme = DARK_THEME  # Default to dark mode
        dark_mode = True
        try:
            if os.path.exists("theme_pref.json"):
                with open("theme_pref.json", "r") as f:
                    pref = json.load(f)
                    dark_mode = pref.get("dark_mode", True)
                    if not dark_mode:
                        theme = LIGHT_THEME
        except:
            pass

        # Load font size preference
        font_size_factor = 1.0
        try:
            if os.path.exists("font_size_pref.json"):
                with open("font_size_pref.json", "r") as f:
                    pref = json.load(f)
                    font_size_factor = pref.get("font_size_factor", 1.0)
        except:
            pass

        # Create the main window
        try:
            root = tk.Tk()
            startup_log("Main window created successfully")
        except Exception as e:
            startup_log(f"Failed to create main window: {str(e)}")
            messagebox.showerror("GUI Error", f"Failed to create GUI window:\n{str(e)}")
            sys.exit(1)

        startup_log("Creating main application")
        app = SystemCleanerGUI(root, theme)
        app.dark_mode_var.set(dark_mode)
        app.font_size_factor = font_size_factor
        startup_log("Main application created successfully")

        # Apply command line arguments if provided
        if args:
            app.clean_temp.set(args.clean_temp)
            app.disk_cleanup.set(args.disk_cleanup)
            app.disable_fast_startup.set(args.disable_fast_startup)
            app.update_apps.set(args.update_apps)
            app.windows_updates.set(args.windows_updates)
            app.device_firmware.set(args.device_firmware)
            app.repair_system.set(args.repair_system)
            app.chk_dsk.set(args.chk_dsk)
            app.windows_adjustments.set(args.windows_adjustments)
            app.flush_dns.set(args.flush_dns)
            app.ipconfig_all.set(args.ipconfig_all)
            app.change_dns.set(args.change_dns)
            app.autopilot_csv.set(args.autopilot_csv)
            app.pc_report.set(args.pc_report)
            app.chris_titus_utility.set(args.chris_titus_utility)
            app.stop_background_apps_var.set(args.stop_background_apps)
            app.disable_startup_apps_var.set(args.disable_startup_apps)

        startup_log("Main application created")

        # Start the main loop
        startup_log("Starting main loop")
        root.mainloop()
        startup_log("Main loop ended")

    except Exception as e:
        startup_log(f"Application error: {str(e)}")
        startup_log(f"Traceback: {traceback.format_exc()}")
        print(f"Error: {str(e)}")
        print(f"Traceback: {traceback.format_exc()}")
        messagebox.showerror("Application Error", f"An error occurred: {str(e)}")
        sys.exit(1)


if __name__ == "__main__":
    main()
